<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java线程同步概述</title>
    <url>/2021/04/20/Java%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>线程锁的那些概念：</p>
<p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。        先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。<span id="more"></span></p>
<table>
<thead>
<tr>
<th></th>
<th>可重入锁</th>
<th>不可重入锁</th>
<th>悲观锁</th>
<th>乐观锁</th>
</tr>
</thead>
<tbody><tr>
<td>概念简述</td>
<td>是否允许：同一个线程对共享区域重复加锁，Java可以理解成对同一个对象多次调用带有加锁机制的方法或是代码块synchronized，ReentrantLock都是可重入锁</td>
<td>与可重入对立的。一次只能加一次锁，不能重复加锁，或者可能造成死锁。【NonReentrantLock非可重入锁】</td>
<td>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。        先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。           而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。          乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的 ● 悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。● 乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升</td>
<td></td>
</tr>
<tr>
<td>示例</td>
<td><strong>{</strong>    <strong>public synchronized void doSomething() {</strong>        <strong>System.out.println(“可重入锁…”);</strong>        <strong>doOthers();</strong>    <strong>}</strong>    <strong>public synchronized void doOthers() {</strong>        <strong>System.out.println(“方法2执行…”);</strong>    <strong>}****}</strong></td>
<td>以：<strong>synchronized关键字为不可重入锁为例子：</strong>{    <strong>public synchronized voi</strong>d d<strong>oSomething() {</strong>        <strong>System.out.println(</strong>“<strong>会</strong>造<strong>成死锁，因为doSomething还未释放锁”);</strong>        <strong>doOthers();</strong>    <strong>}</strong>    <strong>public synchronized voi</strong>d d<strong>oOthers() {</strong>        <strong>System.out.println(</strong>“<strong>方</strong>法<strong>2执行…”);</strong>    <strong>}</strong>}</td>
<td><em>// ReentrantLock**private Reentran</em>t<strong>Lock lo</strong>ck = new ReentrantLock**();** // 需要保证多个线程使用的是同一<em>个锁**public void modi</em>f<strong>yPublic</strong>Resources() {    <em>lock.lock();</em>    <em>// 操作同步资源</em>    <em>lock.unlock();**}</em></td>
<td><em>// ————————- 乐观锁的调用方式**private AtomicInteger atomicInteger =</em> <strong>new Ato</strong>micInteger();  // 需要保证多个线程使用的是同<strong>一个A</strong>tomicInteger<em>atomicInteger.incrementAndGet(); //执行</em>自<strong>增1</strong></td>
</tr>
<tr>
<td>在上面的代码中，类中的两个方法都是被内置锁synchronized修饰的，doSomething()方法中调用doOthers()方法。因为内置锁是可重入的，所以同一个线程在调用doOthers()时可以直接获得当前对象的锁，进入doOthers()进行操作。       如果是一个不可重入锁，那么当前线程在调用doOthers()之前需要将执行doSomething()时获取当前对象的锁释放掉，实际上该对象锁已被当前线程所持有，且无法释放。所以此时会出现死锁。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>原理</td>
<td>计数器方法：当进入加锁时，计数器加一，代码区域执行完毕后，计数器减一。等于0表示没有线程使用。ReentrantLock和synchronized都是重入锁，那么我们通过重入锁ReentrantLock以及非可重入锁NonReentrantLock的源码来对比分析一下为什么非可重入锁在重复调用同步资源时会出现死锁。首先ReentrantLock和NonReentrantLock都继承父类AQS，其父类AQS中维护了一个同步状态status来计数重入次数，status初始值为0。当线程尝试获取锁时，可重入锁先尝试获取并更新status值，如果status == 0表示没有其他线程在执行同步代码，则把status置为1，当前线程开始执行。如果status != 0，则判断当前线程是否是获取到这个锁的线程，如果是的话执行status+1，且当前线程可以再次获取锁。而非可重入锁是直接去获取并尝试更新当前status的值，如果status != 0的话会导致其获取锁失败，当前线程阻塞。释放锁时，可重入锁同样先获取当前status的值，在当前线程是持有锁的线程的前提下。如果status-1 == 0，则表示当前线程所有重复获取锁的操作都已经执行完毕，然后该线程才会真正释放锁。而非可重入锁则是在确定当前线程是持有锁的线程之后，直接将status置为0，将锁释放。</td>
<td>CAS全称 Compare And Swap（比较与交换），是一种无锁算法。在不使用锁（没有线程被阻塞）的情况下实现多线程之间的变量同步。java.util.concurrent包中的原子类就是通过CAS来实现了乐观锁。CAS算法涉及到三个操作数：● 需要读写的内存值 V。● 进行比较的值 A。● 要写入的新值 B。当且仅当 V 的值等于 A 时，CAS通过原子方式用新值B来更新V的值（“比较+更新”整体是一个原子操作，使用汇编指令进行的原子操作），否则不会执行任何操作。一般情况下，“更新”是一个不断重试的操作。之前提到java.util.concurrent包中的原子类，就是通过CAS来实现了乐观锁。JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。CAS虽然很高效，但是它也存在三大问题，这里也简单说一下：1. ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。    ○ JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。2. 循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。3. 只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。    ○ Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>公平锁</th>
<th>非公平锁</th>
<th>共享锁【读锁】</th>
<th>排它锁【写锁】</th>
</tr>
</thead>
<tbody><tr>
<td>公平锁是指多个线程按照申请锁的顺序来获取锁，线程直接进入队列中排队，队列中的第一个线程才能获得锁。公平锁的优点是等待锁的线程不会饿死。缺点是整体吞吐效率相对非公平锁要低，等待队列中除第一个线程以外的所有线程都会阻塞，CPU唤醒阻塞线程的开销比非公平锁大。非公平锁是多个线程加锁时直接尝试获取锁，获取不到才会到等待队列的队尾等待。但如果此时锁刚好可用，那么这个线程可以无需阻塞直接获取到锁，所以非公平锁有可能出现后申请锁的线程先获取锁的场景。非公平锁的优点是可以减少唤起线程的开销，整体的吞吐效率高，因为线程有几率不阻塞直接获得锁，CPU不必唤醒所有线程。缺点是处于等待队列中的线程可能会饿死，或者等很久才会获得锁。</td>
<td>共享锁是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。</td>
<td>排它锁也叫独享锁，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。</td>
<td></td>
</tr>
<tr>
<td>ReentrantLock里面有一个内部类Sync，Sync继承AQS（AbstractQueuedSynchronizer），添加锁和释放锁的大部分操作实际上都是在Sync中实现的。它有公平锁FairSync和非公平锁NonfairSync两个子类。ReentrantLock默认使用非公平锁，也可以通过构造器来显示的指定使用公平锁。</td>
<td>独享锁与共享锁也是通过AQS来实现的，通过实现不同的方法，来实现独享或者共享</td>
<td></td>
<td></td>
</tr>
<tr>
<td>protected final boolean tryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {//判断是否队列的第一个，并且使用cas查看锁是否释放        if (!hasQueuedPredecessors() &amp;&amp;            compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0)            throw new Error(“Maximum lock count exceeded”);        setState(nextc);        return true;    }    return false;}</td>
<td>final boolean nonfairTryAcquire(int acquires) {    final Thread current = Thread.currentThread();    int c = getState();    if (c == 0) {//使用cas查看锁是否释放,释放了抢占式加锁        if (compareAndSetState(0, acquires)) {            setExclusiveOwnerThread(current);            return true;        }    }    else if (current == getExclusiveOwnerThread()) {        int nextc = c + acquires;        if (nextc &lt; 0) // overflow            throw new Error(“Maximum lock count exceeded”);        setState(nextc);        return true;    }    return false;}</td>
<td></td>
<td></td>
</tr>
<tr>
<td>公平锁就是通过同步队列来实现多个线程按照申请锁的顺序来获取锁，从而实现公平的特性。非公平锁加锁时不考虑排队等待问题，直接尝试获取锁，所以存在后申请却先获得锁的情况。</td>
<td>ReentrantReadWriteLock有两把锁：ReadLock和WriteLock，由词知意，一个读锁一个写锁，合称“读写锁”。再进一步观察可以发现ReadLock和WriteLock是靠内部类Sync实现的锁。Sync是AQS的一个子类，这种结构在CountDownLatch、ReentrantLock、Semaphore里面也都存在。在ReentrantReadWriteLock里面，读锁和写锁的锁主体都是Sync，但读锁和写锁的加锁方式不一样。读锁是共享锁，写锁是独享锁。读锁的共享锁可保证并发读非常高效，而读写、写读、写写的过程互斥，因为读锁和写锁是分离的。所以ReentrantReadWriteLock的并发性相比一般的互斥锁有了很大提升。那读锁和写锁的具体加锁方式有什么区别呢？在了解源码之前我们需要回顾一下其他知识。 在最开始提及AQS的时候我们也提到了state字段（int类型，32位），该字段用来描述有多少线程获持有锁。在独享锁中这个值通常是0或者1（如果是重入锁的话state值就是重入的次数），在共享锁中state就是持有锁的数量。但是在ReentrantReadWriteLock中有读、写两把锁，所以需要在一个整型变量state上分别描述读锁和写锁的数量（或者也可以叫状态）。于是将state变量“按位切割”切分成了两个部分，高16位表示读锁状态（读锁个数），低16位表示写锁状态（写锁个数）</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>自旋锁</th>
</tr>
</thead>
<tbody><tr>
<td>阻塞或唤醒一个线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长。因此在等待加锁的线程会一直 忙轮询，看看锁是否已被释放【会占用CPU资源】</td>
</tr>
<tr>
<td>自旋锁的实现原理同样也是CAS，AtomicInteger中调用unsafe进行自增操作的源码中的do-while循环就是一个自旋操作，如果修改数值失败则通过循环来执行自旋，直至修改成功。public final int getAndUpdate(IntUnaryOperator updateFunction) {    int prev, next;    do {        prev = get();        next = updateFunction.applyAsInt(prev);    } while (!compareAndSet(prev, next));//自旋等待    return prev;}</td>
</tr>
<tr>
<td>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</td>
</tr>
</tbody></table>
<p><img src="/images/youdao/6709.png"></p>
<p>Java提供的线程哪些关键字及类库:</p>
<table>
<thead>
<tr>
<th></th>
<th>synchronized关键字</th>
<th>volatile</th>
<th>ReentrantLock【AQS类】Java中的大部分同步类（Lock、Semaphore、ReentrantLock等）都是基于AbstractQueuedSynchronizer（简称为AQS）实现的。AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架</th>
<th>java.util.concurrent.atomic.</th>
</tr>
</thead>
<tbody><tr>
<td>锁特性</td>
<td>1：悲观锁2：可重入锁3：排它锁</td>
<td>保持了变量可见性，及提示线程对于这个经过这个关键字修饰过的变量必须从内存区域从新取值，而不是使用寄存器里缓存值</td>
<td>1：悲观锁2：可重入锁3：排它锁，共享锁4：公平锁，非公平锁</td>
<td>自旋锁</td>
</tr>
<tr>
<td>描述</td>
<td>synchronized关键字有四种锁的状态：无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁：这四种锁是指锁的状态，专门针对synchronized的。在介绍这四种锁状态之前还需要介绍一些额外的知识。首先为什么Synchronized能实现线程同步？在回答这个问题之前我们需要了解两个重要的概念：“Java对象头”、“Monitor”。Java对象头synchronized是悲观锁，在操作同步资源之前需要给同步资源先加锁，这把锁就是存在Java对象头里的，而Java对象头又是什么呢？我们以Hotspot虚拟机为例，Hotspot的对象头主要包括两部分数据：Mark Word（标记字段）、Klass Pointer（类型指针）。Mark Word：默认存储对象的HashCode，分代年龄和锁标志位信息。这些信息都是与对象自身定义无关的数据，所以Mark Word被设计成一个非固定的数据结构以便在极小的空间内存存储尽量多的数据。它会根据对象的状态复用自己的存储空间，也就是说在运行期间Mark Word里存储的数据会随着锁标志位的变化而变化。Klass Point：对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。MonitorMonitor可以理解为一个同步工具或一种同步机制，通常被描述为一个对象。每一个Java对象就有一把看不见的锁，称为内部锁或者Monitor锁。Monitor是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联，同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。现在话题回到synchronized，synchronized通过Monitor来实现线程同步，Monitor是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的线程同步。如同我们在自旋锁中提到的“阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长”。这种方式就是synchronized最初实现同步的方式，这就是JDK 6之前synchronized效率低的原因。这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”，JDK 6中为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”。所以目前锁一共有4种状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁。锁状态只能升级不能降级。通过上面的介绍，我们对synchronized的加锁机制以及相关知识有了一个了解，那么下面我们给出四种锁状态对应的的Mark Word内容，然后再分别讲解四种锁状态的思路以及特点：无锁无锁没有对资源进行锁定，所有的线程都能访问并修改同一个资源，但同时只有一个线程能修改成功。无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。偏向锁偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁，降低获取锁的代价。在大多数情况下，锁总是由同一线程多次获得，不存在多线程竞争，所以出现了偏向锁。其目标就是在只有一个线程执行同步代码块时能够提高性能。当一个线程访问同步代码块并获取锁时，会在Mark Word里存储锁偏向的线程ID。在线程进入和退出同步块时不再通过CAS操作来加锁和解锁，而是检测Mark Word里是否存储着指向当前线程的偏向锁。引入偏向锁是为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径，因为轻量级锁的获取及释放依赖多次CAS原子指令，而偏向锁只需要在置换ThreadID的时候依赖一次CAS原子指令即可。偏向锁只有遇到其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁，线程不会主动释放偏向锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有字节码正在执行），它会首先暂停拥有偏向锁的线程，判断锁对象是否处于被锁定状态。撤销偏向锁后恢复到无锁（标志位为“01”）或轻量级锁（标志位为“00”）的状态。偏向锁在JDK 6及以后的JVM里是默认启用的。可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，关闭之后程序默认会进入轻量级锁状态。轻量级锁是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。在代码进入同步块的时候，如果同步对象锁状态为无锁状态（锁标志位为“01”状态，是否为偏向锁为“0”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝，然后拷贝对象头中的Mark Word复制到锁记录中。拷贝成功后，虚拟机将使用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指针，并将Lock Record里的owner指针指向对象的Mark Word。如果这个更新动作成功了，那么这个线程就拥有了该对象的锁，并且对象Mark Word的锁标志位设置为“00”，表示此对象处于轻量级锁定状态。如果轻量级锁的更新操作失败了，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块继续执行，否则说明多个线程竞争锁。若当前只有一个等待线程，则该线程通过自旋进行等待。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁升级为重量级锁。重量级锁升级为重量级锁时，锁标志的状态值变为“10”，此时Mark Word中存储的是指向重量级锁的指针，此时等待锁的线程都会进入阻塞状态。</td>
<td><strong>volatile</strong>关键字可以用来提醒编译器它后面所定义的变量随时有可能改变，因此编译后的程序每次需要存储或读取这个变量的时候，都会直接从变量地址中读取数据。如果没有volatile关键字，则编译器可能优化读取和存储，可能暂时使用寄存器中的值，如果这个变量由别的程序更新了的话，将出现不一致的现象。<strong>Volatile</strong> 变量具有 synchronized 的可见性特性，但是不具备原子特性。这就是说线程能够自动发现 volatile 变量的最新值。Volatile 变量可用于提供线程安全，但是只能应用于非常有限的一组用例：多个变量之间或者某个变量的当前值与修改后值之间没有约束。因此，单独使用 volatile 还不足以实现计数器、互斥锁或任何具有与多个变量相关的不变式（Invariants）的类（例如 “start &lt;=end”）。<strong>出于简易性或可伸</strong>缩性的考虑，您可能倾向于使用 volatile 变量而不是锁。当使用 volatile 变量而非锁时，某些习惯用法（idiom）更加易于编码和阅读。此外，volatile 变量不会像锁那样造成线程阻塞，因此也很少造成可伸缩性问题。在某些情况下，如果读操作远远大于写操作，volatile 变量还可以提供优于锁的性能优势。</td>
<td>内部通过CAS机制实现锁一系列判断操作。AQS核心思想是，如果被请求的共享资源空闲，那么就将当前请求资源的线程设置为有效的工作线程，将共享资源设置为锁定状态；如果共享资源被占用，就需要一定的阻塞等待唤醒机制来保证锁分配。这个机制主要用的是CLH队列的变体实现的，将暂时获取不到锁的线程加入到队列中。AQS使用一个Volatile的int类型的成员变量来表示同步状态，通过内置的FIFO队列来完成资源获取的排队工作，通过CAS完成对State【锁状态】值的修改。详情：美团的博客 <a href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html</a></td>
<td>通过cas机制实现：一般自能支持单变量.并且借助了Java底层的unsafe类操作内存实现。public class AtomicInteger extends Number implements java.io.Serializable {    private static final long serialVersionUID = 6214790243416807050L;    // setup to use Unsafe.compareAndSwapInt for updates// 获取并操作内存的数据    private static final Unsafe unsafe = Unsafe.getUnsafe();    //存储value在AtomicInteger中的偏移量private static final long valueOffset;    static {        try {            valueOffset = unsafe.objectFieldOffset                (AtomicInteger.class.getDeclaredField(“value”));        } catch (Exception ex) { throw new Error(ex); }    }//存储AtomicInteger的int值，该属性需要借助volatile关键字保证其在线程间是可见的。    private volatile int value;// Unsafe.classpublic final int getAndAddInt(Object var1, long var2, int var4) {  int var5;  do {      var5 = this.getIntVolatile(var1, var2);  } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));  return var5;}// ————————- OpenJDK 8源代码 ————————-// Unsafe.javapublic final int getAndAddInt(Object o, long offset, int delta) {   int v;   do {       v = getIntVolatile(o, offset);   } while (!compareAndSwapInt(o, offset, v, v + delta));   return v;}根据OpenJDK 8的源码我们可以看出，getAndAddInt()循环获取给定对象o中的偏移量处的值v，然后判断内存值是否等于v。如果相等则将内存值设置为 v + delta，否则返回false，继续循环进行重试，直到设置成功才能退出循环，并且将旧值返回。整个“比较+更新”操作封装在compareAn<em>dSwapInt()中，在JNI里</em>是借助于一个CPU指令完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。后续JDK通过CPU的cmpxchg指令，去比较寄存器中的 A 和 内存中的值 V。如果相等，就把要写入的新值 B 存入内存中。如果不相等，就将内存值 V 赋值给寄存器中的值 A。然后通过Java代码中的while循环再次调用cmpxchg指令进行重试，直到设置成功为止。</td>
</tr>
<tr>
<td></td>
<td>综上，偏向锁通过对比Mark Word解决加锁问题，避免执行CAS操作。而轻量级锁是通过用CAS操作和自旋来解决加锁问题，避免线程阻塞和唤醒而影响性能。重量级锁是将除了拥有锁的线程以外的线程都阻塞。重量级锁会使用操作系统的Mutex Lock（互斥锁）来实现的线程同步</td>
<td>volatile：保持了变量在多个线程内的可见性，以及保证赋值操作的原子性：如 var = 0;</td>
<td></td>
<td>使用自旋锁机制：来改变变量的值，一般只能保护单个变量值，不能保护代码区域块。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的update,insert流程</title>
    <url>/2021/11/20/MySQL%E7%9A%84update-insert%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="MySQL的架构图"><a href="#MySQL的架构图" class="headerlink" title="MySQL的架构图"></a>MySQL的架构图</h3><p>一条SQL语句从客户端发送到服务端，需要经历很多流程 </p>
<ul>
<li>客户端需要与服务端建立连接，建立连接的时候，服务端会验证客户端的登录验证，登录用户权限等操作</li>
<li>处理SQL语句<br>登录成功后，客户端发送SQL语句，需要解析SQL，然后优化SQL语句的执行，判断不同的执行类型，让执行器执行。<br>如果是操作数据的操作，还需要从磁盘加载数据到内存做相应的处理。修改类的还需要回写到磁盘，以防数据丢失。<br>然后基于不同的SQL语句返回处理结果</li>
<li>客户端基于返回结果集做处理<br><img src="/images/db/mysql-struct.png" alt="mysql">  </li>
</ul>
<h3 id="分析一个update的执行流程"><a href="#分析一个update的执行流程" class="headerlink" title="分析一个update的执行流程"></a>分析一个update的执行流程</h3><p><img src="/images/db/mysql-update.png" alt="mysql-update"> </p>
<span id="more"></span>
<p>当执行一条更新的SQL语句的时候，需要经历很多流程。  </p>
<ul>
<li>执行需要先判断当前数据是否在内存中，如果没有需要从磁盘加载数据，到内存，然后记录当前的原始值，以备执行失败的时候回滚。</li>
<li>然后会更新值到内存，并写入到redo log 和bin log，这个时候数据在内存中是最新的，但是在磁盘中还是原始值。所以可以认为内存的是胀数据（如果MySQL崩溃，会在重启时候重放redo恢复已经完成的操作，所以数据最终是一致）。</li>
<li>然后MySQL根据策略刷入内存中的数据到磁盘，此时内存中的数据就和磁盘数据保持了一直（行的数据会有隐藏的列记录当前数据的最新版本号信息）</li>
<li>undo log，是用来记录历史数据和进行回滚，mvcc的非一致性读（当一个更新语句执行中，读语句会读一个最新的历史版本数据），redo log是用来进行崩溃时恢复的，保持事务数据完整性的。bin log记录数据的变更，进行数据重放，主从同步等</li>
</ul>
<h3 id="分析一个insert的执行流程"><a href="#分析一个insert的执行流程" class="headerlink" title="分析一个insert的执行流程"></a>分析一个insert的执行流程</h3><p>当执行一个insert语句的时候会相对复杂些  </p>
<ul>
<li>存储引擎需要，把数据先放入 insert buffer中，但是会和update的流程相似，需要写入到 undo log,redo log,bin log中。</li>
<li>而且如果是有 auto 自增主键ID的时候，还需要加 auto_lock(轻量级的表锁)，来生成自增ID</li>
<li>如果插入失败，引擎会执行一个反向操作。这个自增ID也废弃了</li>
</ul>
<h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>undo log的作用</p>
<ul>
<li>记录数据更新前的值，防止更新失败后进行回滚</li>
<li>记录数据的版本数据，在修改操作中，不防止读的操作。</li>
<li>与redo log协作保证事务的数据一致性</li>
<li>通常默认情况下，undo数据是存储在ibdata中的，但你也可以通过配置选项 innodb_undo_tablespaces 来将undo 回滚段分配到不同的文件中。<h3 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h3>redo log主要是用来保证数据的一致性的。<br>需要redo log是因为，为了提高实际数据写入到磁盘的效率，MySQL会把记录在内存中的数据批量写到磁盘中，而非每次更新的少批量数据实时更新到磁盘。那么这个时候就需要有个保证在数据库崩溃的时候，内存数据未刷入到磁盘时候的，来保证这些数据的一致性，因为毕竟这些数据已经做过了修改只是未刷新到磁盘。而redo log就是做这些事情的，因为redo log是顺序写，所以写的效率是很高。当崩溃重启后MySQL会检测redo log和数据，然后重放redo log保证数据的一致。<br>undo log记录了更新之前的数据，那么redo log就是记录更新的数据。再做redo log写之前，需要先写undo log。<br>redo log 包括两部分：一是内存中的日志缓冲(redo log buffer)，该部分日志是易失性的；二是磁盘上的重做日志文件(redo log file)，该部分日志是持久的，redo log 存储的是物理格式的日志，记录的是物理数据页面的修改信息，它是顺序写入 redo log file 中的。<br> 因为有了日志缓冲(redo log buffer),为了提高写入的效率。此时数据还在内存中，所以MySQL提供了配置，来让你选择写入的时机innodb_flush_log_at_trx_commit。  <ul>
<li>0：日志缓存区将每隔一秒写到日志文件中，并且将日志文件的数据刷新到磁盘上。该模式下在事务提交时不会主动触发写入磁盘的操作。<br>这个模式会丢失数据</li>
<li>1：每次事务提交时MySQL都会把日志缓存区的数据写入日志文件中，并且刷新到磁盘中，该模式为系统默认。这个是最安全的模式</li>
<li>2：每次事务提交时MySQL都会把日志缓存区的数据写入日志文件中【系统缓存中】，但是并不会同时刷新到磁盘上。该模式下，MySQL会每秒执行一次刷新磁盘操作。<br>对于数据安全性来说选择1是最好的模式</li>
</ul>
</li>
</ul>
<h4 id="redo-log记录的形式"><a href="#redo-log记录的形式" class="headerlink" title="redo log记录的形式"></a>redo log记录的形式</h4><p>redo log 实际上记录数据页的变更，而这种变更记录是没必要全部保存，因此 redo log<br>实现上采用了大小固定，循环写入的方式，当写到结尾时，会回到开头循环写日志。如下图：<br><img src="/images/db/mysql-redo.jpg" alt="mysql-redo"><br>  同时我们很容易得知， 在innodb中，既有 redo log 需要刷盘，还有 数据页 也需要刷盘， redo log 存在的意义主要就是降低对 数据页 刷盘的要求 。在上图中， write pos 表示 redo log 当前记录的 LSN (逻辑序列号)位置， check point 表示 数据页更改记录** 刷盘后对应 redo log 所处的 LSN (逻辑序列号)位置。 write pos 到 check point 之间的部分是 redo log 空着的部分，用于记录新的记录； check point 到 write pos 之间是 redo log 待落盘的数据页更改记录。当 write pos 追上 check point 时，会先推动 check point 向前移动，空出位置再记录新的日志。<br>  启动 innodb 的时候，不管上次是正常关闭还是异常关闭，总是会进行恢复操作。因为 redo log 记录的是数据页的物理变化，因此恢复的时候速度比逻辑日志(如 binlog )要快很多。 重启 innodb 时，首先会检查磁盘中数据页的 LSN ，如果数据页的 LSN 小于日志中的 LSN ，则会从 checkpoint 开始恢复。 还有一种情况，在宕机前正处于checkpoint 的刷盘过程，且数据页的刷盘进度超过了日志页的刷盘进度，此时会出现数据页中记录的 LSN 大于日志中的 LSN，这时超出日志进度的部分将不会重做，因为这本身就表示已经做过的事情，无需再重做。</p>
<h3 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h3><p>binlog记录了数据库系统所有的更新操作，主要是用来实现数据恢复和主从复制的。一方面，主从配置的MySQL集群可以利用binlog将主库中的更新操作传递到从库中，以此来实现主从数据的一致性；另一方面，数据库还可以利用binlog来进行数据的恢复。<br>redo log和binlog的产生方式不同。redo log是在物理存储引擎层产生，而binlog是在MySQL数据库的Server层产生的，并且binlog不仅针对InnoDB存储引擎，MySQL数据库中的任何存储引擎对数据库的更改都会产生binlog。<br>对于 InnoDB 存储引擎而言，只有在事务提交时才会记录 biglog ，此时记录还在内存中，那么 biglog是什么时候刷到磁盘中的呢？ mysql 通过 sync_binlog 参数控制 biglog 的刷盘时机，取值范围是 0-N：</p>
<ul>
<li>0：不去强制要求，由系统自行判断何时写入磁盘；</li>
<li>1：每次 commit 的时候都要将 binlog 写入磁盘；</li>
<li>N：每N个事务，才会将 binlog 写入磁盘。<br>所以为了保证数据的安全性，redo log和bin log两个参数的值都需要在1这个级别上<br>binlog 日志有三种格式，分别为 STATMENT 、 ROW 和 MIXED 。</li>
<li>STATMENT 二进制文件记录的是日志的逻辑SQL语句</li>
<li>ROW 基于行的复制，记录每次数据的变化，如果是批量更改语句等会产生大量的日志</li>
<li>MIXED 基于 STATMENT 和 ROW 两种模式的混合复制( mixed-based replication, MBR )，一般的复制使用 STATEMENT 模式保存 binlog ，对于 STATEMENT 模式无法复制的操作使用 ROW 模式保存 binlog</li>
</ul>
<h3 id="怎么保证数据的不丢失"><a href="#怎么保证数据的不丢失" class="headerlink" title="怎么保证数据的不丢失"></a>怎么保证数据的不丢失</h3><p>回顾下数据的写入流程<br>记录历史数据，更新内存的数据，写入redo log,写入bin log,更新redo log为commited状态</p>
<ul>
<li>当写入undo log，未写入redo log，这个时候崩溃了【内存的数据也未落入磁盘】，数据相当于没修改。不造成影响</li>
<li>当写入undo ，redo 为写入bin崩溃。这个时候会判断是否需要回滚等等操作。如果不做，会造成master的实际和从库【依据bin同步数据】实际数据不一致。</li>
<li>写入 undo,redo,bin未写入commit状态，重启的时候回依据commit状态做二次处理。<br>为什么不选择先写入 bin:<br>当先写入bin的时候，如果未写入redo，会造成从库数据的时候不一致性。<br>在MySQL内部，在事务提交时利用两阶段提交(内部XA的两阶段提交)很好地解决了上面提到的binlog和redo log的一致性问题：  </li>
<li>第一阶段： InnoDB Prepare阶段。此时SQL已经成功执行，并生成事务ID(xid)信息及redo和undo的内存日志。此阶段InnoDB会写事务的redo log，但要注意的是，此时redo log只是记录了事务的所有操作日志，并没有记录提交（commit）日志，因此事务此时的状态为Prepare。此阶段对binlog不会有任何操作。</li>
<li>第二阶段：commit 阶段，这个阶段又分成两个步骤。第一步写binlog（先调用write()将binlog内存日志数据写入文件系统缓存，再调用fsync()将binlog文件系统缓存日志数据永久写入磁盘）；第二步完成事务的提交（commit），此时在redo log中记录此事务的提交日志（增加commit 标签）。<br>综上所述，MySQL innodb依赖于undo ,redo,bin保证数据上完整的一致性</li>
</ul>
<p>参考：<br>《MySQL技术内幕InnoDB存储引擎》<br><a href="http://mysql.taobao.org/monthly/2016/02/01/">http://mysql.taobao.org/monthly/2016/02/01/</a></p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>avl平衡树</title>
    <url>/2021/04/20/avl%E5%B9%B3%E8%A1%A1%E6%A0%91/</url>
    <content><![CDATA[<p>avl树是自带有平衡条件的二叉树，平常的二叉树在插入数据的很可能造成树的左子树或者右子树过长。造成查询是线性。avl要保持树的深度是logN。最简单的想法是要求左右紫薯具有相同的高度。一颗avl树是其每个节点的左子树和右子树的高度最多差1的二叉查找树。<br><img src="/images/img/08-09/f27877b4-157b-40d1-976a-b8be7e8d586f.png"><br>当我们插入的时候必须保证avl树的特性，即是左右子树的高度差最多是1，分析插入的特性我们发现有以下四种情况<span id="more"></span></p>
<p>当我们插入的时候必须保证avl树的特性，即是左右子树的高度差最多是1，分析插入的特性我们发现有以下四种情况：</p>
<p>基于二叉树的定义可以发现，发生不满足的【不平衡的时候】存在以下四种情况</p>
<ul>
<li><p>1.当前节点的左子树的左子树在进行一次插入。熟称LL。</p>
</li>
<li><p>2.当前节点的左子树的右子树在进行一次插入。熟称LR。</p>
</li>
<li><p>3.当前节点的右子树的右子树在进行一次插入。熟称RR。</p>
</li>
<li><p>4.当前节点的右子树的左子树在进行一次插入。熟称RL</p>
</li>
</ul>
<p>操作avl时候一些特性:</p>
<p>当我们定义节点的时候，每个节点保存自己的高度因子：高度因子：空节点 是 -1，因子只能在 0，-1，1之间取值。新插入的节点默认高度因子是0;计算高度因子：节点的高度因子 = max(左子树的高度因子 , 右子树的高度因子) 加 1.当一个节点新插入子节点后需要重新 计算该节点的高度因子，用来检查是否符合平衡条件在失去平衡的时候，可以看出 1，4是镜像问题，2，3是镜像问题.</p>
<p>下图是LL失去平衡的例子:</p>
<p><img src="/images/img/08-09/71034a2b-0cea-41fb-b768-0ec9d848185e.png"></p>
<p>此时我们需要作出反转:</p>
<p><img src="/images/img/08-09/0f7fcac1-94d6-401c-85ad-696b4a6e8a2e.png"></p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public function leftSigon(Node node) &#123;          $k1 &#x3D; node-&gt;left;&#x2F;&#x2F;也即是 4 节点             $node-&gt;left &#x3D; $k1-&gt;right;&#x2F;&#x2F;</span><br><span class="line">             $k1-&gt;right  &#x3D; $node;&#x2F;&#x2F;4节点的右子树为</span><br><span class="line">             $node-&gt;height &#x3D; max($this-&gt;getHeight($node-&gt;left),$this-&gt;getHeight($node-&gt;right)) + 1;&#x2F;&#x2F;重新计算右子树的高度</span><br><span class="line">             $k1-&gt;height &#x3D; max($this-&gt;getHeight($k1-&gt;left),$this-&gt;getHeight($k1-&gt;right)) + 1;&#x2F;&#x2F;重新计算高度因子</span><br><span class="line">&#x2F;&#x2F;因为4节点的左子树没动所以不用重新计算高度</span><br><span class="line">             return $k1;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>当出现RR插入的时候，也就是 右右插入的时候其实和LL的镜像问题:</p>
<p><img src="/images/img/08-09/cb279e31-419d-460f-a609-154c9e041094.png"></p>
<p>所以RR的代码是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public function rightSigon(Node node) &#123;</span><br><span class="line">             $k1 &#x3D; node-&gt;right                ;&#x2F;&#x2F;也即是 8 节点</span><br><span class="line">             $node-&gt;right &#x3D; $k1-&gt;left;&#x2F;&#x2F;父节点的右节点为子节点的做节点【二叉树定义可知 右子树大于父节点，所以右子树下的左节点作为父节点的右子树】</span><br><span class="line">             $k1-&gt;left  &#x3D; $node;&#x2F;&#x2F;右子树的做节点为父节点，转换完毕</span><br><span class="line">             &#x2F;&#x2F;重新计算 高度因子值</span><br><span class="line">             $node-&gt;height &#x3D; max($this-&gt;getHeight($node-&gt;left),$this-&gt;getHeight($node-&gt;right)) + 1;</span><br><span class="line">             $k1-&gt;height &#x3D; max($this-&gt;getHeight($k1-&gt;left),$this-&gt;getHeight($k1-&gt;right)) + 1;</span><br><span class="line">             return $k1;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>

<p>当出现RL的时候：</p>
<p><img src="/images/img/08-09/ba9a5b91-f5bb-410c-b67a-d118ab2a7819.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RL代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">RLSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>-&gt;right); <span class="comment">//LL情况下旋转</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>);<span class="comment">//RR情况下旋转</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>LR是和RL镜像问题：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">LRSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          <span class="variable">$node</span>-&gt;left = <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>-&gt;left);<span class="comment">//先处理RR情况</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>);<span class="comment">//在处理LL情况</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>

<p>删除分析：当删除的元素只有右子树或者左子树，且右子树或左子树是叶子节点，也就是说右子树，左子树他们没有相应的子树时候就会失去平衡。</p>
<p><img src="/images/img/08-09/a2da191c-3896-4881-85a2-0f95ea8ebc94.png"></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delRecursion</span>(<span class="params">Node <span class="variable">$node</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$value</span> &gt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">        <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;right, <span class="variable">$value</span>);</span><br><span class="line">        <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$value</span> &lt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">        <span class="variable">$node</span>-&gt;left = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;left, <span class="variable">$value</span>);</span><br><span class="line">        <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left &amp;&amp; <span class="variable">$node</span>-&gt;right) &#123;</span><br><span class="line">            <span class="variable">$tmp</span> = <span class="keyword">$this</span>-&gt;findMin(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">            <span class="variable">$node</span>-&gt;value = <span class="variable">$tmp</span>-&gt;value;</span><br><span class="line">            <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;right, <span class="variable">$tmp</span>-&gt;value);</span><br><span class="line">            <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left || <span class="variable">$node</span>-&gt;right) &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left ? <span class="variable">$node</span>-&gt;left : <span class="variable">$node</span>-&gt;right;</span><br><span class="line">            <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="variable">$node</span>-&gt;left) &#123;</span><br><span class="line">        <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整代码:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: lhs</span></span><br><span class="line"><span class="comment"> * Date: 2019-07-05</span></span><br><span class="line"><span class="comment"> * Time: 13:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AVL平衡树</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$value</span> = <span class="literal">null</span>;<span class="comment">//值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$left</span> = <span class="literal">null</span>;<span class="comment">//左子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$right</span> = <span class="literal">null</span>;<span class="comment">//右子结点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$parent</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$height</span> = <span class="number">0</span>;<span class="comment">//高度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;value = <span class="variable">$value</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class AvlTree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AvlTree</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 空节点-1，如果是节点返回节点的高度。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">getHeight</span>(<span class="params"><span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$node</span>-&gt;height;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 左</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">leftSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> Node $k1 ;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="variable">$k1</span>           = <span class="variable">$node</span>-&gt;left;<span class="comment">//也即是 4 节点</span></span><br><span class="line">        <span class="variable">$node</span>-&gt;left   = <span class="variable">$k1</span>-&gt;right;</span><br><span class="line">        <span class="variable">$k1</span>-&gt;right    = <span class="variable">$node</span>;</span><br><span class="line">        <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left), <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$k1</span>-&gt;height   = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$k1</span>-&gt;left), <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$k1</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$k1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 右</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">rightSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> Node $k1 ;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="variable">$k1</span>          = <span class="variable">$node</span>-&gt;right;<span class="comment">//也即是 8 节点</span></span><br><span class="line">        <span class="variable">$node</span>-&gt;right = <span class="variable">$k1</span>-&gt;left;<span class="comment">//父节点的右节点为子节点的做节点【二叉树定义可知 右子树大于父节点，所以右子树下的左节点作为父节点的右子树】</span></span><br><span class="line">        <span class="variable">$k1</span>-&gt;left    = <span class="variable">$node</span>;<span class="comment">//右子树的做节点为父节点，转换完毕</span></span><br><span class="line">        <span class="comment">//重新计算 高度因子值</span></span><br><span class="line">        <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left), <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="variable">$k1</span>-&gt;height   = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$k1</span>-&gt;left), <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$k1</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$k1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">LRSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$node</span>-&gt;left = <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">RLSigon</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $x</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$x</span>, <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span> == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="variable">$node</span>         = <span class="keyword">new</span> Node(<span class="variable">$x</span>);</span><br><span class="line">            <span class="variable">$node</span>-&gt;left   = <span class="variable">$node</span>-&gt;right = <span class="literal">null</span>;</span><br><span class="line">            <span class="variable">$node</span>-&gt;height = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$x</span> &lt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">            <span class="variable">$node</span>-&gt;left = <span class="keyword">$this</span>-&gt;insert(<span class="variable">$x</span>, <span class="variable">$node</span>-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$x</span> &lt; <span class="variable">$node</span>-&gt;left-&gt;value) &#123;<span class="comment">//LL情况</span></span><br><span class="line">                    <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;LRSigon(<span class="variable">$node</span>);<span class="comment">//LR情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$x</span> &gt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">            <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;insert(<span class="variable">$x</span>, <span class="variable">$node</span>-&gt;right);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$x</span> &gt; <span class="variable">$node</span>-&gt;right-&gt;value) &#123;<span class="comment">//RR情况</span></span><br><span class="line">                    <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;RLSigon(<span class="variable">$node</span>);<span class="comment">//RL情况</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left), <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;<span class="comment">//重新计算高度因子</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $space</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">printTree</span>(<span class="params"><span class="variable">$node</span>, <span class="variable">$space</span> = <span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span>) &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$space</span> . <span class="variable">$node</span>-&gt;value . <span class="string">&quot;[&quot;</span> . <span class="variable">$node</span>-&gt;height . <span class="string">&quot;]&quot;</span> . PHP_EOL;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;printTree(<span class="variable">$node</span>-&gt;left, <span class="variable">$space</span> . <span class="string">&quot;   &quot;</span>);</span><br><span class="line">            <span class="keyword">$this</span>-&gt;printTree(<span class="variable">$node</span>-&gt;right, <span class="variable">$space</span> . <span class="string">&quot;   &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delRecursion</span>(<span class="params">Node <span class="variable">$node</span>, <span class="variable">$value</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$value</span> &gt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">            <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;right, <span class="variable">$value</span>);</span><br><span class="line">            <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;leftSigon(<span class="variable">$node</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$value</span> &lt; <span class="variable">$node</span>-&gt;value) &#123;</span><br><span class="line">            <span class="variable">$node</span>-&gt;left = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;left, <span class="variable">$value</span>);</span><br><span class="line">            <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right) - <span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left) == <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;rightSigon(<span class="variable">$node</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left &amp;&amp; <span class="variable">$node</span>-&gt;right) &#123;</span><br><span class="line">                <span class="variable">$tmp</span> = <span class="keyword">$this</span>-&gt;findMin(<span class="variable">$node</span>-&gt;right);</span><br><span class="line">                <span class="variable">$node</span>-&gt;value = <span class="variable">$tmp</span>-&gt;value;</span><br><span class="line">                <span class="variable">$node</span>-&gt;right = <span class="keyword">$this</span>-&gt;delRecursion(<span class="variable">$node</span>-&gt;right, <span class="variable">$tmp</span>-&gt;value);</span><br><span class="line">                <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;left || <span class="variable">$node</span>-&gt;right) &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left ? <span class="variable">$node</span>-&gt;left : <span class="variable">$node</span>-&gt;right;</span><br><span class="line">                <span class="variable">$node</span>-&gt;height = max(<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;left),<span class="keyword">$this</span>-&gt;getHeight(<span class="variable">$node</span>-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$node</span> = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> Node $node</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findMin</span>(<span class="params">Node <span class="variable">$node</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$node</span>-&gt;left) &#123;</span><br><span class="line">            <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$node</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$node</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$arr</span> = [<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">16</span>,<span class="number">15</span>,<span class="number">14</span>,<span class="number">13</span>];</span><br><span class="line"><span class="comment">//$arr = [6,5,7,4];</span></span><br><span class="line"><span class="comment">//$arr = [6,5,7];</span></span><br><span class="line"><span class="comment">//$arr = [6,7];</span></span><br><span class="line"><span class="variable">$avl</span> = <span class="keyword">new</span> AvlTree();</span><br><span class="line"><span class="keyword">foreach</span> (<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$val</span>) &#123;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$val</span> . <span class="string">&#x27;:::::&#x27;</span> . PHP_EOL;</span><br><span class="line">    <span class="variable">$node</span> = <span class="variable">$avl</span>-&gt;insert(<span class="variable">$val</span>, <span class="variable">$node</span>);</span><br><span class="line">   <span class="comment">// $avl-&gt;printTree($node);</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$node</span>-&gt;value . <span class="string">&#x27;:::::&#x27;</span> . PHP_EOL;</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;*****************&quot;</span> . PHP_EOL;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$avl</span>-&gt;printTree(<span class="variable">$node</span>);</span><br><span class="line"><span class="variable">$node</span> = <span class="variable">$avl</span>-&gt;delRecursion(<span class="variable">$node</span>,  <span class="string">&#x27;7&#x27;</span>);</span><br><span class="line"><span class="variable">$avl</span>-&gt;printTree(<span class="variable">$node</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>cap定理</title>
    <url>/2019/04/20/cap%E5%AE%9A%E7%90%86/</url>
    <content><![CDATA[<p>它指出对于一个<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算系统</a>来说，不可能同时满足以下三点：</p>
<ul>
<li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li>
<li><a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA&action=edit&redlink=1">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择[<a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86#cite_note-3">3]</a>。）</li>
</ul>
<p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项[<a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86#cite_note-4">4]</a>。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。<span id="more"></span></p>
<p>也就是说，在分布式系统中P一定存在的，因为种种原因，肯定会出现节点之间网络不互通的情况【比如某个分区断网，断电】。所以要在P的情况下载一致性和可用性之间做出选择。</p>
<p>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障，使得有些节点之间不连通了，整个网络就分成了几块区域。数据就散布在了这些不连通的区域中。这就叫分区。</p>
<p>​            当你一个数据项只在一个节点中保存，那么分区出现后，和这个节点不连通的部分就访问不到这个数据了。这时分区就是无法容忍的。如果要容忍，那么就会出现数据不一致性，因为网络之间不互通无法做到所有节点数据都更新。</p>
<p>​       提高分区容忍性的办法就是一个数据项复制到多个节点上，那么出现分区之后，这一数据项就可能分布到各个区里。容忍性就提高了。</p>
<p>​         然而，要把数据复制到多个节点，就会带来一致性的问题，就是多个节点上面的数据可能是不一致的。要保证一致，每次写操作就都要等待全部节点写成功，而这等待又会带来可用性的问题。这个时候回锁住分区的服务器知道他们都更新成功，才能对外提供服务，所以降低了可用性。</p>
<p>​     总的来说就是，数据存在的节点越多，分区容忍性越高，但要复制更新的数据就越多，一致性就越难保证。为了保证一致性，更新所有节点数据所需要的时间就越长，可用性就会降低。</p>
<p>例子：</p>
<p>​      让我们考虑一个非常简单的分布式系统。我们的系统由两个服务器$ G_1 $和$ G_2 组成。这两个服务器都跟踪相同的变量$ v $，其初始值为$ v_0 。$ G_1 $和$ G_2 $可以彼此通信，也可以与外部客户端通信。这是我们的系统的外观。</p>
<p>​    <img src="/images/7492.png" alt="0"></p>
<p>客户端可以请求从任何服务器进行写入和读取。服务器收到请求后，将执行所需的任何计算，然后响应客户端。例如，这是写的样子。</p>
<p>​    <img src="/images/7495.png" alt="0"></p>
<p>一致性：</p>
<p>​     在写操作完成之后开始的任何读操作必须返回该值，或者以后的写操作的结果</p>
<p>在一致的系统中，客户端将值写入任何服务器并获得响应后，它期望从其读取的任何服务器取回该值（或更新鲜的值）。</p>
<p>这是一个<strong>不一致的</strong>系统的示例。【此时G1服务器和G2服务未同步完成数据更新】</p>
<p>​    <img src="/images/7500.png" alt="0"></p>
<p>我们的客户将$ v_1 $写入$ G_1 $并且$ G_1 $确认，但是当它从$ G_2 $读取时，它会得到陈旧的数据：$ v_0 $。</p>
<p>另一方面，这是一个<strong>一致的</strong> 系统的示例。</p>
<p>​    <img src="/images/7504.png" alt="0"></p>
<p>在此系统中，$ G_1 $将其值复制到$ G_2 $，然后再向客户端发送确认。因此，当客户端从$ G_2 $中读取时，它将获得$ v $的最新值：$ v_1 $。</p>
<p>可用性：</p>
<p>​        系统中非故障节点收到的每个请求都必须导致响应</p>
<p>在可用的系统中，如果我们的客户端向服务器发送请求并且服务器没有崩溃，则服务器最终必须响应客户端。不允许服务器忽略客户端的请求。如上边的不一致性，提高了可用性，但是会造成数据不一致性。</p>
<p><strong>分区容差</strong>：</p>
<p>​    网络将被允许任意丢失从一个节点发送到另一节点的许多消息</p>
<p>这意味着可以丢弃任何彼此发送的消息$ G_1 $和$ G_2 $。如果所有消息都被丢弃，那么我们的系统将如下所示。</p>
<p>​    <img src="/images/7513.png" alt="0"></p>
<p>为了容忍分区，我们的系统必须能够在任意网络分区下正常运行。</p>
<p>此时，我们要在C和A之间做一个选择，如果选择C，那么节点之间会一致等待节点之间的互通或数据同步完成，期间会造成服务可用性降低【对客户端请求挂起等等】；如果选择A那么，节点之间会出现数据不一致性。</p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>cap</tag>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>explain</title>
    <url>/2021/04/20/explain/</url>
    <content><![CDATA[<p>explain关键字可以模拟MySQL优化器执行SQL语句，可以很好的分析SQL语句或表结构的性能瓶颈。<br>explain的执行的结果：<br><img src="/images/db/explain-show.jpg" alt="explain"></p>
<span id="more"></span>
<h3 id="explain包含的字段"><a href="#explain包含的字段" class="headerlink" title="explain包含的字段"></a>explain包含的字段</h3><ul>
<li><p>Id 对于select查询语句的标记序号，或者再有子查询时标识selelct子句或者操作表的顺序，数字越大越先执行。如果数字一样从上往下先执行。</p>
</li>
<li><p>Select_type 查询类型，表示语句执行的类型，如simple表示不包含union或者select子查询的简单select的查询。</p>
</li>
<li><p>table 查询的表名字</p>
</li>
<li><p>partitions 查询的分区</p>
</li>
<li><p>type 查询的类型，all,index,rang,ref,eq_ref,const,system,null等类型表示查询执行的优劣。 </p>
</li>
<li><p>possible_keys 可能使用的索引，但是不一定使用</p>
</li>
<li><p>key使用到的索引</p>
</li>
<li><p>key_len 使用的索引的长度</p>
</li>
<li><p>ref 如果是使用的常数等值查询，这里会显示const，如果是连接查询，被驱动表的执行计划这里会显示驱动表的关联字段，如果是条件使用了表达式或者函数，或者条件列发生了内部隐式转换，这里可能显示为func</p>
</li>
<li><p>rows 表示MySQL认为执行查询必须检查的行数</p>
</li>
<li><p>filtered 指示将被表条件过滤的表行的估计百分比。最大值为100，这表示未过滤行。值从100减小表示过滤量增加。 <code>rows</code>显示检查的估计行数，<code>rows</code>× <code>filtered</code>显示将与下表连接的行数。例如，如果 <code>rows</code>为1000且 <code>filtered</code>为50.00（50％），则与下表连接的行数为1000×50％= 500.需要和rows合并起来看，如最上边的多，使用常量数值进行查询，此值为100表示为过滤。</p>
</li>
<li><p>extra 有关MySQL如何解析查询的其他信息。如use index,等等。</p>
</li>
</ul>
<hr>
<h3 id="type-查询的连接类型"><a href="#type-查询的连接类型" class="headerlink" title="type 查询的连接类型"></a>type 查询的连接类型</h3><p>以下列表描述了连接类型，从最佳类型到最差类型：</p>
<ul>
<li><p>system 该表只有一行，这是const 链接类型的特例</p>
</li>
<li><p>const  常量查询，一般都是在唯一键，匹配到一行的因为只有一行，所以优化器的其余部分可以将这一行中列的值视为常量。 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const"><code>const</code></a>表非常快，因为它们只能读取一次。</p>
</li>
<li><p>eq_ref 对于先前表中的每行组合，从此表中读取一行。除了 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_system"><code>system</code></a>和 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_const"><code>const</code></a>类型，这是最好的联接类型。当连接使用索引的所有部分且索引为<code>PRIMARY KEY</code>（主键）或<code>UNIQUE NOT NULL</code>index（唯一索引）时使用。在使用联表的时候其实也是两个使用都是主键或是唯一索引。</p>
<p><a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a>可以用于使用<code>=</code>运算符进行比较的索引列 。比较值可以是常量，也可以是使用在此表之前读取的表中列的表达式。在以下示例中，MySQL可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a>联接进行处理 *<code>ref_table</code>*：</p>
<figure class="highlight plain"><figcaption><span>* FROM *ref_table*,*other_table*  WHERE *ref_table*.*key_column*</span></figcaption><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>Ref 与eq_ref的却别是使用不是唯一索引，有个一列或是常量值查询可能匹配到多个行数据.可用于使用<code>=</code>或<code>&lt;=&gt;</code> 运算符进行比较的索引列</p>
<figure class="highlight plain"><figcaption><span>* FROM *ref_table* WHERE *key_column*</span></figcaption><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>Fulltext 使用全文索引</p>
</li>
<li><p>Ref_or_null 连接类型类似于 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref"><code>ref</code></a>，但是除了MySQL还会额外搜索包含<code>NULL</code>值的行。此联接类型优化最常用于解析子查询。在以下示例中，MySQL可以使用 <a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_ref_or_null"><code>ref_or_null</code></a>联接进行处理*<code>ref_table</code>*：</p>
<figure class="highlight plain"><figcaption><span>* FROM *ref_table*  WHERE *key_column*</span></figcaption><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>Index_merge 表示使用了索引合并的优化方法。一般实在有索引的查询使用了or查询。</p>
<figure class="highlight plain"><figcaption><span>* FROM *tbl_name* WHERE *key1* </span></figcaption><table><tr><td class="code"><pre><span class="line">  </span><br></pre></td></tr></table></figure></li>
<li><p>unique_subquery 此类型替换 以下形式的<a href="https://dev.mysql.com/doc/refman/5.7/en/explain-output.html#jointype_eq_ref"><code>eq_ref</code></a>某些 <code>IN</code>子查询,子句查询的是主键或是唯一索引</p>
<figure class="highlight plain"><figcaption><span>IN (SELECT `primary_key` FROM *single_table* WHERE *some_expr*)</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* index_subquery 此类型和unique_subquery查询类型差不多，但是子句查询的是 不是唯一索引类型。它代替&#96;IN&#96;子查询，但适用于以下形式的子查询中的非唯一索引</span><br><span class="line"></span><br><span class="line">* range 使用索引选择行，仅检索给定范围内的行。的&#96;key&#96; 输出行中的列指示使用哪个索引。将&#96;key_len&#96;包含已使用的时间最长的关键部分。</span><br><span class="line"></span><br><span class="line">  [&#96;range&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;explain-output.html#jointype_range)当一个键列使用任何的相比于恒定可使用 [&#96;&#x3D;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_equal)， [&#96;&lt;&gt;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_not-equal)， [&#96;&gt;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_greater-than)， [&#96;&gt;&#x3D;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_greater-than-or-equal)， [&#96;&lt;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_less-than)， [&#96;&lt;&#x3D;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_less-than-or-equal)， [&#96;IS NULL&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_is-null)， [&#96;&lt;&#x3D;&gt;&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_equal-to)， [&#96;BETWEEN&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_between)， [&#96;LIKE&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;string-comparison-functions.html#operator_like)，或 [&#96;IN()&#96;](https:&#x2F;&#x2F;dev.mysql.com&#x2F;doc&#x2F;refman&#x2F;5.7&#x2F;en&#x2F;comparison-operators.html#operator_in)</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;SELECT * FROM *tbl_name*  WHERE *key_column* &#x3D; 10; SELECT * FROM *tbl_name*  WHERE *key_column* BETWEEN 10 and 20; SELECT * FROM *tbl_name*  WHERE *key_column* IN (10,20,30); SELECT * FROM *tbl_name*  WHERE *key_part1* &#x3D; 10 AND *key_part2* IN (10,20,30);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>Index 类型是all的一种特例表示不是全扫描表数据，而是全部扫描索引树。因为索引文件通常比数据文件小，也就是虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘读的。发生在，查询是覆盖索引值如 select id from table.或者是在查询数据单数按照主键索引排序读取的时候。如：</p>
<p><img src="/images/db/explain-type-index-2.jpg" alt="index-2"></p>
</li>
</ul>
<p>如果不是order by type将是all</p>
<ul>
<li>All 表示全表扫描表示是最慢的查询。</li>
</ul>
<hr>
<p>select_type表示查询语句的类型。</p>
<ul>
<li><p>simple 一般都是单表查询。</p>
</li>
<li><p>primary 查询中若包含任何复杂的子部分，最外层查询则被标记为主查询.如 value in (select id from table1)语句</p>
</li>
<li><p>Subquery 子查询的意思，表示在where或是select中的子查询语句</p>
</li>
<li><p>union 表示使用union 的联表语句如：select * from t1 union select * from t2;</p>
</li>
<li><p>Derived 表示from的子查询语句需要递归的执行，</p>
</li>
</ul>
<hr>
<p>  Extra 查询的一些额外信息，可以提示是否使用的索引，排序是否使用到索引等等</p>
<ul>
<li><p>Use filesort 既是用不到索引的排序，需要额外排序，一般是order by的不是索引字段或者使用不上索引造成。<strong>filesort</strong> 使用的算法是QuickSort，即对需要排序的记录生成元数据进行分块排序，然后再使用mergesort方法合并块。其中filesort可以使用的<strong>内存空间</strong>大小为参数 sort_buffer_size 的值，默认为2M。当排序记录太多 <strong>sort_buffer_size</strong> 不够用时，mysql会使用<strong>临时文件来存放各个分块</strong>，然后各个分块排序后再多次合并分块最终全局完成排序</p>
</li>
<li><p>Use temporary用了临时表保存中间结果，MySQL在对结果排序时使用临时表，常见于排序order by 和分组查询group by 例子：</p>
</li>
<li><p>Use index 使用到索引.表示相应的select操作中使用了覆盖索引（Covering Index）,避免访问了表的数据行，效率不错！ 如果同时出现using where，表明索引被用来执行索引键值的查找 如果没有同时出现using where，表明索引用来读取数据而非执行查找动作</p>
</li>
<li><p>Use where 使用where条件</p>
</li>
<li><p>Impossible where where条件匹配不到值。</p>
</li>
<li><p>Using join buffer 使用连接缓存</p>
</li>
<li><p>distinct 一般是在链表时出现，一旦mysql匹配到联合行就不匹配了，链表的字段都是唯一索引。</p>
</li>
<li><p>select tables optimized away select操作已经优化到极致了</p>
</li>
</ul>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>go 实现一个简单的rpc</title>
    <url>/2021/12/05/go-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84rpc/</url>
    <content><![CDATA[<h3 id="rpc-的一个流程"><a href="#rpc-的一个流程" class="headerlink" title="rpc 的一个流程"></a>rpc 的一个流程</h3><p>当一个请求过来的，经过网关，网关调用应用服务，应用服务也需要调其他的服务。这个时候我们要考虑的问题。  </p>
<ul>
<li>服务之间的发现<br> 我们需要一个发现服务和注册服务的地方，既是注册中心。还需要监控服务的可用性</li>
<li>服务是多机器部署的，怎么均衡服务节点的流量<br> 负载均衡的实现，保证流量不被打到某一台或者特定的几台节点上，其他节点无流量</li>
<li>调用超时问题<br> 需要关心网关调用服务，或者服务之间调用的超时问题</li>
<li>服务负载问题<br> 如果某一个服务集群负载过高怎么办</li>
<li>服务的节点管理等等<br>怎么样管理和监控服务节点</li>
<li>服务之间交互的协议<br><img src="/images/gateway.jpg" alt="gateway"></li>
</ul>
<span id="more"></span>
<h3 id="协议的格式"><a href="#协议的格式" class="headerlink" title="协议的格式"></a>协议的格式</h3><p>[版本号]|[数据包长度]|[requestID]|[请求报文类型]|[报文编码格式]|[实际报文内容]的封包格式</p>
<h3 id="request-请求体结构"><a href="#request-请求体结构" class="headerlink" title="request 请求体结构"></a>request 请求体结构</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	ServerName <span class="keyword">string</span></span><br><span class="line">	MethodName <span class="keyword">string</span></span><br><span class="line">	Params []<span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一个RPC的请求流程"><a href="#一个RPC的请求流程" class="headerlink" title="一个RPC的请求流程"></a>一个RPC的请求流程</h3><p>客户端建立与服务端的链接 -&gt; 基于客户端代理类，调用需要请求的方法 -&gt; 生成请求体request，基于编码格式和协议格式，做数据转换-&gt;发送到服务端-》服务端接受到二进制报文，基于编码和协议格式，做反解码操作-》基于request的指定的server类和方法名调用注册的server方法返回数据-&gt; 服务端把返回数据，编码返回给客户端-&gt;客户端反解码，拿到调用结果</p>
<h3 id="调式"><a href="#调式" class="headerlink" title="调式"></a>调式</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> -start server -port <span class="number">9099</span></span><br><span class="line"><span class="keyword">go</span> run main.<span class="keyword">go</span> -start client -port <span class="number">9099</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">初始代码：https:&#x2F;&#x2F;github.com&#x2F;lihongsheng&#x2F;go-simple-rpc.git</span><br></pre></td></tr></table></figure>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-InnoDB-索引的数据结构及算法原理</title>
    <url>/2019/08/12/MySQL-InnoDB-%E7%B4%A2%E5%BC%95%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="数据结构及算法基础"><a href="#数据结构及算法基础" class="headerlink" title="数据结构及算法基础"></a>数据结构及算法基础</h3><h4 id="索引的本质"><a href="#索引的本质" class="headerlink" title="索引的本质"></a>索引的本质</h4><p>MySQL官方对索引的定义为：索引（Index）是帮助MySQL高效获取数据的数据结构。提取句子主干，就可以得到索引的本质：索引是数据结构。</p>
<p>​        我们知道，数据库查询是数据库的最主要功能之一。我们都希望查询数据的速度能尽可能的快，因此数据库系统的设计者会从查询算法的角度进行优化。最基本的查询算法当然是<a href="http://en.wikipedia.org/wiki/Linear_search">顺序查找</a>（linear search），这种复杂度为O(n)的算法在数据量很大时显然是糟糕的，好在计算机科学的发展提供了很多更优秀的查找算法，例如<a href="http://en.wikipedia.org/wiki/Binary_search_algorithm">二分查找</a>（binary search）、<a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉树查找</a>（binary tree search）等。如果稍微分析一下会发现，每种查找算法都只能应用于特定的数据结构之上，例如二分查找要求被检索数据有序，而二叉树查找只能应用于<a href="http://en.wikipedia.org/wiki/Binary_search_tree">二叉查找树</a>上，但是数据本身的组织结构不可能完全满足各种数据结构（例如，理论上不可能同时将两列都按顺序进行组织），所以，在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p>
<p>看一个例子:</p>
<p><img src="/images/img/08-12/d2eb2d3c-72d0-435c-a5a1-d507879a547a.png"></p>
<p>图1展示了一种可能的索引方式。左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址（注意逻辑上相邻的记录在磁盘上也并不是一定物理相邻的）。为了加快Col2的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指针，这样就可以运用二叉查找在(O(log_2n))的复杂度内获取到相应数据。</p>
<p>虽然这是一个货真价实的索引，但是实际的数据库系统几乎没有使用二叉查找树或其进化品种<a href="http://en.wikipedia.org/wiki/Red-black_tree">红黑树</a>（red-black tree）实现的，原因会在下文介绍。</p>
<p>先看看几种树形结构：</p>
<ul>
<li>搜索二叉树：每个节点有两个子节点，数据量的增大必然导致高度的快速增加，显然这个不适合作为大量数据存储的基础结构</li>
<li>B树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m - 1；一个节点的子节点数量会比关键字个数多1，这样关键字就变成了子节点的分割标志。一般会在图示中把关键字画到子节点中间，非常形象，也容易和后面的B+树区分。由于数据同时存在于叶子节点和非叶子结点中，无法简单完成按顺序遍历B树中的关键字，必须用中序遍历的方法。</li>
<li>B+树：一棵m阶B树是一棵平衡的m路搜索树。最重要的性质是每个非根节点所包含的关键字个数 j 满足：┌m/2┐ - 1 &lt;= j &lt;= m；子树的个数最多可以与关键字一样多。非叶节点存储的是子树里最小的关键字。同时数据节点只存在于叶子节点中，且叶子节点间增加了横向的指针，这样顺序遍历所有数据将变得非常容易</li>
<li>B*树：一棵m阶B树是一棵平衡的m路搜索树。最重要的两个性质是1每个非根节点所包含的关键字个数 j 满足：┌m2/3┐ - 1 &lt;= j &lt;= m；2非叶节点间添加了横向指针</li>
</ul>
<p><img src="/images/img/08-12/34ef527e-ff06-4e6b-a8f0-454dae2044d2.png"></p>
<h4 id="B-Tree和B-Tree"><a href="#B-Tree和B-Tree" class="headerlink" title="B-Tree和B+Tree"></a>B-Tree和B+Tree</h4><p>目前大部分数据库系统及文件系统都采用B-Tree或其变种B+Tree作为索引结构，在本文的下一节会结合存储器原理及计算机存取原理讨论为什么B-Tree和B+Tree在被如此广泛用于索引，这一节先单纯从数据结构角度描述它们。</p>
<h5 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h5><p>为了描述B-Tree，首先定义一条数据记录为一个二元组[key, data]，key为记录的键值，对于不同数据记录，key是互不相同的；data为数据记录除key外的数据。那么B-Tree是满足下列条件的数据结构：</p>
<p>d为大于1的一个正整数，称为B-Tree的度。</p>
<p>h为一个正整数，称为B-Tree的高度。</p>
<p>每个非叶子节点由n-1个key和n个指针组成，其中d&lt;=n&lt;=2d。</p>
<p>每个叶子节点最少包含一个key和两个指针，最多包含2d-1个key和2d个指针，叶节点的指针均为null 。</p>
<p>所有叶节点具有相同的深度，等于树高h。</p>
<p>key和指针互相间隔，节点两端是指针。</p>
<p>一个节点中的key从左到右非递减排列。</p>
<p>所有节点组成树结构。</p>
<p>每个指针要么为null，要么指向另外一个节点。</p>
<p>如果某个指针在节点node最左边且不为null，则其指向节点的所有key小于(v(key_1))，其中(v(key_1))为node的第一个key的值。</p>
<p>如果某个指针在节点node最右边且不为null，则其指向节点的所有key大于(v(key_m))，其中(v(key_m))为node的最后一个key的值。</p>
<p>如果某个指针在节点node的左右相邻key分别是(key_i)和(key_{i+1})且不为null，则其指向节点的所有key小于(v(key_{i+1}))且大于(v(key_i))。</p>
<p>图2是一个d=2的B-Tree示意图。</p>
<p><img src="/images/img/08-12/ffef08a4-15cc-45a9-a987-7d313c391095.png"></p>
<p>由于B-Tree的特性，在B-Tree中按key检索数据的算法非常直观：首先从根节点进行二分查找，如果找到则返回对应节点的data，否则对相应区间的指针指向的节点递归进行查找，直到找到节点或找到null指针，前者查找成功，后者查找失败。B-Tree上查找算法的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, key) &#123;</span><br><span class="line">    <span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    foreach(node.key)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(node.key[i] == key) <span class="keyword">return</span> node.data[i];</span><br><span class="line">            <span class="keyword">if</span>(node.key[i] &gt; key) <span class="keyword">return</span> BTree_Search(point[i]-&gt;node);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BTree_Search(point[i+<span class="number">1</span>]-&gt;node);</span><br><span class="line">&#125;</span><br><span class="line">data = BTree_Search(root, my_key);</span><br></pre></td></tr></table></figure>

<p>关于B-Tree有一系列有趣的性质，例如一个度为d的B-Tree，设其索引N个key，则其树高h的上限为(log_d((N+1)/2))，检索一个key，其查找节点个数的渐进复杂度为(O(log_dN))。从这点可以看出，B-Tree是一个非常有效率的索引数据结构。<br>   另外，由于插入删除新的数据记录会破坏B-Tree的性质，因此在插入删除时，需要对树进行一个分裂、合并、转移等操作以保持B-Tree性质，本文不打算完整讨论B-Tree这些内容，因为已经有许多资料详细说明了B-Tree的数学性质及插入删除算法，有兴趣的朋友可以在本文末的参考文献一栏找到相应的资料进行阅读。</p>
<h5 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h5><p>B-Tree有许多变种，其中最常见的是B+Tree，例如MySQL就普遍使用B+Tree实现其索引结构。<br>与B-Tree相比，B+Tree有以下不同点：<br>  每个节点的指针上限为2d而不是2d+1。<br>  内节点不存储data，只存储key；叶子节点不存储指针。<br>  图3是一个简单的B+Tree示意<br><img src="/images/img/08-12/17eb383c-3c04-4405-a1b6-e03d61d8156c.png"><br>由于并不是所有节点都具有相同的域，因此B+Tree中叶节点和内节点一般大小不同。这点与B-Tree不同，虽然B-Tree中不同节点存放的key和指针可能数量不一致，但是每个节点的域和上限是一致的，所以在实现中B-Tree往往对每个节点申请同等大小的空间。<br>一般来说，B+Tree比B-Tree更适合实现外存储索引结构，具体原因与外存储器原理及计算机存取原理有关，将在下面讨论。</p>
<h5 id="带有顺序访问指针的B-Tree"><a href="#带有顺序访问指针的B-Tree" class="headerlink" title="带有顺序访问指针的B+Tree"></a>带有顺序访问指针的B+Tree</h5><p>一般在数据库系统或文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针。也就是数据域也是一个链表。</p>
<p><img src="/images/img/08-12/825d6a18-d61a-48ad-a72d-f83024ecdaa2.png"></p>
<p>如图4所示，在B+Tree的每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree。做这个优化的目的是为了提高区间访问的性能，例如图4中如果要查询key为从18到49的所有数据记录，当找到18后，只需顺着节点和指针顺序遍历就可以一次性访问到所有数据节点，极大提到了区间查询效率。</p>
<p>这一节对B-Tree和B+Tree进行了一个简单的介绍，下一节结合存储器存取原理介绍为什么目前B+Tree是数据库系统实现索引的首选数据结构。</p>
<h3 id="为什么使用B-Tree（B-Tree）"><a href="#为什么使用B-Tree（B-Tree）" class="headerlink" title="为什么使用B-Tree（B+Tree）"></a>为什么使用B-Tree（B+Tree）</h3><p>上文说过，红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构，这一节将结合计算机组成原理相关知识讨论B-/+Tree作为索引的理论基础。</p>
<p>一般来说，索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。这样的话，索引查找过程中就要产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。换句话说，索引的结构组织要尽量减少查找过程中磁盘I/O的存取次数。下面先介绍内存和磁盘存取原理，然后再结合这些原理分析B-/+Tree作为索引的效率。</p>
<h3 id="主存存取原理"><a href="#主存存取原理" class="headerlink" title="主存存取原理"></a>主存存取原理</h3><p>目前计算机使用的主存基本都是随机读写存储器（RAM），现代RAM的结构和存取原理比较复杂，这里本文抛却具体差别，抽象出一个十分简单的存取模型来说明RAM的工作原理.</p>
<p><img src="/images/img/08-12/6377f0be-0586-4a3d-95c4-6ffbbaba0677.png"></p>
<p>从抽象角度看，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据。每个存储单元有唯一的地址，现代主存的编址规则比较复杂，这里将其简化成一个二维地址：通过一个行地址和一个列地址可以唯一定位到一个存储单元。图5展示了一个4 x 4的主存模型。</p>
<p>主存的存取过程如下：</p>
<ul>
<li><p> 当系统需要读取主存时，则将地址信号放到地址总线上传给主存，主存读到地址信号后，解析信号并定位到指定存储单元，然后将此存储单元数据放到数据总线上，供其它部件读取。</p>
</li>
<li><p> 写主存的过程类似，系统将要写入单元地址和数据分别放在地址总线和数据总线上，主存读取两个总线的内容，做相应的写操作。</p>
</li>
</ul>
<p>这里可以看出，主存存取的时间仅与存取次数呈线性关系，因为不存在机械操作，两次存取的数据的“距离”不会对时间有任何影响，例如，先取A0再取A1和先取A0再取D3的时间消耗是一样的。</p>
<h4 id="磁盘存取原理"><a href="#磁盘存取原理" class="headerlink" title="磁盘存取原理"></a>磁盘存取原理</h4><p>上文说过，索引一般以文件形式存储在磁盘上，索引检索需要磁盘I/O操作。与主存不同，磁盘I/O存在机械运动耗费，因此磁盘I/O的时间消耗是巨大的。<br>图6是磁盘的整体结构示意图。<br><img src="/images/img/08-12/baa61fb8-fd5d-431d-ac62-bd4197111471.png"><br>一个磁盘由大小相同且同轴的圆形盘片组成，磁盘可以转动（各个磁盘必须同步转动）。在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每个磁头负责存取一个磁盘的内容。磁头不能转动，但是可以沿磁盘半径方向运动（实际是斜切向运动），每个磁头同一时刻也必须是同轴的，即从正上方向下看，所有磁头任何时候都是重叠的（不过目前已经有多磁头独立技术，可不受此限制）。图7是磁盘结构的示意图。</p>
<p><img src="/images/img/08-12/57f77a1f-140f-440c-8993-b59269ca5e64.png"></p>
<p>盘片被划分成一系列同心环，圆心是盘片中心，每个同心环叫做一个磁道，所有半径相同的磁道组成一个柱面。磁道被沿半径线划分成一个个小的段，每个段叫做一个扇区，每个扇区是磁盘的最小存储单元。为了简单起见，我们下面假设磁盘只有一个盘片和一个磁头。</p>
<p>当需要从磁盘读取数据时，系统会将数据逻辑地址传给磁盘，磁盘的控制电路按照寻址逻辑将逻辑地址翻译成物理地址，即确定要读的数据在哪个磁道，哪个扇区。为了读取这个扇区的数据，需要将磁头放到这个扇区上方，为了实现这一点，磁头需要移动对准相应磁道，这个过程叫做寻道，所耗费时间叫做寻道时间，然后磁盘旋转将目标扇区旋转到磁头下，这个过程耗费的时间叫做旋转时间。</p>
<h4 id="局部性原理与磁盘预读"><a href="#局部性原理与磁盘预读" class="headerlink" title="局部性原理与磁盘预读"></a>局部性原理与磁盘预读</h4><p>由于存储介质的特性，磁盘本身存取就比主存慢很多，再加上机械运动耗费，磁盘的存取速度往往是主存的几百分分之一，因此为了提高效率，要尽量减少磁盘I/O。为了达到这个目的，磁盘往往不是严格按需读取，而是每次都会预读，即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存。这样做的理论依据是计算机科学中著名的局部性原理：</p>
<p>当一个数据被用到时，其附近的数据也通常会马上被使用。</p>
<p>程序运行期间所需要的数据通常比较集中。</p>
<p>由于磁盘顺序读取的效率很高（不需要寻道时间，只需很少的旋转时间），因此对于具有局部性的程序来说，预读可以提高I/O效率。</p>
<p>预读的长度一般为页（page）的整倍数。页是计算机管理存储器的逻辑块，硬件及操作系统往往将主存和磁盘存储区分割为连续的大小相等的块，每个存储块称为一页（在许多操作系统中，页得大小通常为4k），主存和磁盘以页为单位交换数据。当程序要读取的数据不在主存中时，会触发一个缺页异常，此时系统会向磁盘发出读盘信号，磁盘会找到数据的起始位置并向后连续读取一页或几页载入内存中，然后异常返回，程序继续运行。</p>
<h3 id="B-Tree索引的性能分析"><a href="#B-Tree索引的性能分析" class="headerlink" title="B-/+Tree索引的性能分析"></a>B-/+Tree索引的性能分析</h3><p>到这里终于可以分析B-/+Tree索引的性能了。</p>
<p>上文说过一般使用磁盘I/O次数评价索引结构的优劣。先从B-Tree分析，根据B-Tree的定义，可知检索一次最多需要访问h个节点。数据库系统的设计者巧妙利用了磁盘预读原理，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：</p>
<p>每次新建节点时，直接申请一个页的空间，这样就保证一个节点物理上也存储在一个页里，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p>
<p>B-Tree中一次检索最多需要h-1次I/O（根节点常驻内存），渐进复杂度为(O(h)=O(log_dN))。一般实际应用中，出度d是非常大的数字，通常超过100，因此h非常小（通常不超过3）。</p>
<p>综上所述，用B-Tree作为索引结构效率是非常高的。</p>
<p>而红黑树这种结构，h明显要深的多。由于逻辑上很近的节点（父子）物理上可能很远，无法利用局部性，所以红黑树的I/O渐进复杂度也为O(h)，效率明显比B-Tree差很多。</p>
<p>上文还说过，B+Tree更适合外存索引，原因和内节点出度d有关。从上面分析可以看到，d越大索引的性能越好，而出度的上限取决于节点内key和data的大小：</p>
<p>(d_{max}=floor(pagesize / (keysize + datasize + pointsize)))</p>
<p>floor表示向下取整。由于B+Tree内节点去掉了data域，因此可以拥有更大的出度，拥有更好的性能。</p>
<p>这一章从理论角度讨论了与索引相关的数据结构与算法问题，下一章将讨论B+Tree是如何具体实现为MySQL中索引，同时将结合MyISAM和InnDB存储引擎介绍非聚集索引和聚集索引两种不同的索引实现形式。</p>
<h3 id="MySQL索引实现"><a href="#MySQL索引实现" class="headerlink" title="MySQL索引实现"></a>MySQL索引实现</h3><p>在MySQL中，索引属于存储引擎级别的概念，不同存储引擎对索引的实现方式是不同的，本文主要讨论MyISAM和InnoDB两个存储引擎的索引实现方式。</p>
<h4 id="MyISAM索引实现"><a href="#MyISAM索引实现" class="headerlink" title="MyISAM索引实现"></a>MyISAM索引实现</h4><p>MyISAM引擎使用B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址。下图是MyISAM索引的原理图：</p>
<p><img src="/images/img/08-12/d27d352f-13f1-4bcc-82f0-bd2239426067.png" alt="img"></p>
<p>这里设表一共有三列，假设我们以Col1为主键，则图8是一个MyISAM表的主索引（Primary key）示意。可以看出MyISAM的索引文件仅仅保存数据记录的地址。在MyISAM中，主索引和辅助索引（Secondary key）在结构上没有任何区别，只是主索引要求key是唯一的，而辅助索引的key可以重复。如果我们在Col2上建立一个辅助索引，则此索引的结构如下图所示：</p>
<p><img src="/images/img/08-12/556c595a-a446-4c38-b048-434b34fe5c43.png" alt="img"></p>
<p>同样也是一颗B+Tree，data域保存数据记录的地址。因此，MyISAM中索引检索的算法为首先按照B+Tree搜索算法搜索索引，如果指定的Key存在，则取出其data域的值，然后以data域的值为地址，读取相应数据记录。</p>
<p>MyISAM的索引方式也叫做“非聚集”的，之所以这么称呼是为了与InnoDB的聚集索引区分。</p>
<h4 id="InnoDB索引实现"><a href="#InnoDB索引实现" class="headerlink" title="InnoDB索引实现"></a>InnoDB索引实现</h4><p>虽然InnoDB也使用B+Tree作为索引结构，但具体实现方式却与MyISAM截然不同。</p>
<p>第一个重大区别是InnoDB的数据文件本身就是索引文件。从上文知道，MyISAM索引文件和数据文件是分离的，索引文件仅保存数据记录的地址。而在InnoDB中，表数据文件本身就是按B+Tree组织的一个索引结构，这棵树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。</p>
<p><img src="/images/img/08-12/12519adc-1cbf-4f48-8a50-62dfd20d99a3.png" alt="img"></p>
<p>图10是InnoDB主索引（同时也是数据文件）的示意图，可以看到叶节点包含了完整的数据记录。这种索引叫做聚集索引。因为InnoDB的数据文件本身要按主键聚集，所以InnoDB要求表必须有主键（MyISAM可以没有），如果没有显式指定，则MySQL系统会自动选择一个可以唯一标识数据记录的列作为主键，如果不存在这种列，则MySQL自动为InnoDB表生成一个隐含字段作为主键，这个字段长度为6个字节，类型为长整形。</p>
<p>第二个与MyISAM索引的不同是InnoDB的辅助索引data域存储相应记录主键的值而不是地址。换句话说，InnoDB的所有辅助索引都引用主键作为data域。例如，图11为定义在Col3上的一个辅助索引：</p>
<p><img src="/images/img/08-12/df93031d-5940-41d4-9c4d-2aa6ecae8d3b.png" alt="img"></p>
<p>这里以英文字符的ASCII码作为比较准则。聚集索引这种实现方式使得按主键的搜索十分高效，但是辅助索引搜索需要检索两遍索引：首先检索辅助索引获得主键，然后用主键到主索引中检索获得记录。辅助索引使用主键作为”指针” 而不是使用地址值作为指针的好处是，减少了当出现行移动或者数据页分裂时辅助索引的维护工作，使用主键值当作指针会让辅助索引占用更多的空间，换来的好处是InnoDB在移动行时无须更新辅助索引中的这个”指针”。也就是说行的位置（实现中通过16K的Page来定位，后面会涉及）会随着数据库里数据的修改而发生变化（前面的B+树节点分裂以及Page的分裂），使用聚簇索引就可以保证不管这个主键B+树的节点如何变化，辅助索引树都不受影响。</p>
<p>了解不同存储引擎的索引实现方式对于正确使用和优化索引都非常有帮助，例如知道了InnoDB的索引实现后，就很容易明白为什么不建议使用过长的字段作为主键，因为所有辅助索引都引用主索引，过长的主索引会令辅助索引变得过大。再例如，用非单调的字段作为主键在InnoDB中不是个好主意，因为InnoDB数据文件本身是一颗B+Tree，非单调的主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。</p>
<p>myisam 与innodb的对比</p>
<p><img src="/images/img/08-12/61ec8897-b142-4261-ae27-697878c671c5.png" alt="img"></p>
<h5 id="innodb-的Page结构"><a href="#innodb-的Page结构" class="headerlink" title="innodb 的Page结构"></a>innodb 的Page结构</h5><p>理解InnoDB的实现不得不提Page结构，Page是整个InnoDB存储的最基本构件，也是InnoDB磁盘管理的最小单位，与数据库相关的所有内容都存储在这种Page结构里。Page分为几种类型，常见的页类型有数据页（B-tree Node）Undo页（Undo Log Page）系统页（System Page） 事务数据页（Transaction System Page）等。单个Page的大小是16K（编译宏UNIV_PAGE_SIZE控制），每个Page使用一个32位的int值来唯一标识，这也正好对应InnoDB最大64TB的存储容量（16Kib * 2^32 = 64Tib）。一个Page的基本结构如下图所示：</p>
<p><img src="/images/img/08-12/784af9c4-c1bd-4308-bfa1-35a67d3149a8.png" alt="img"></p>
<p>每个Page都有通用的头和尾，但是中部的内容根据Page的类型不同而发生变化。Page的头部里有我们关心的一些数据，下图把Page的头部详细信息显示出来：</p>
<p><img src="/images/img/08-12/d3b75cc6-767a-4bc4-897f-8bf5f5831457.png" alt="img"></p>
<p>我们重点关注和数据组织结构相关的字段：Page的头部保存了两个指针，分别指向前一个Page和后一个Page，头部还有Page的类型信息和用来唯一标识Page的编号。根据这两个指针我们很容易想象出Page链接起来就是一个双向链表的结构。</p>
<p><img src="/images/img/08-12/84d7d8e4-07cb-48ad-8885-53d4388d223a.png" alt="img"></p>
<p>再看看Page的主体内容，我们主要关注行数据和索引的存储，他们都位于Page的User Records部分，User Records占据Page的大部分空间，User Records由一条一条的Record组成，每条记录代表索引树上的一个节点（非叶子节点和叶子节点）。在一个Page内部，单链表的头尾由固定内容的两条记录来表示，字符串形式的”Infimum”代表开头，”Supremum”代表结尾。这两个用来代表开头结尾的Record存储在System Records的段里，这个System Records和User Records是两个平行的段。InnoDB存在4种不同的Record，它们分别是1主键索引树非叶节点 2主键索引树叶子节点 3辅助键索引树非叶节点 4辅助键索引树叶子节点。这4种节点的Record格式有一些差异，但是它们都存储着Next指针指向下一个Record。后续我们会详细介绍这4种节点，现在只需要把Record当成一个存储了数据同时含有Next指针的单链表节点即可。</p>
<p><img src="/images/img/08-12/8102e4aa-7839-4d2c-8ff7-91184f31cf79.png" alt="img"></p>
<p>User Record在Page内以单链表的形式存在，最初数据是按照插入的先后顺序排列的，但是随着新数据的插入和旧数据的删除，数据物理顺序会变得混乱，但他们依然保持着逻辑上的先后顺序。</p>
<p><img src="/images/img/08-12/e91c2bdb-839f-4ec2-bed9-8623bdf6ec71.png" alt="img"></p>
<p>把User Record的组织形式和若干Page组合起来，就看到了稍微完整的形式。</p>
<p><img src="/images/img/08-12/14baf9dd-3aba-4036-ad86-93252c61e093.png" alt="img"></p>
<p><img src="/images/img/08-12/810298f0-1122-4f0d-8135-0038202927d3.png" alt="img"></p>
<p>现在看下如何定位一个Record：</p>
<ul>
<li><p>1 通过根节点开始遍历一个索引的B+树，通过各层非叶子节点最终到达一个Page，这个Page里存放的都是叶子节点。</p>
</li>
<li><p> 2 在Page内从”Infimum”节点开始遍历单链表（这种遍历往往会被优化），如果找到该键则成功返回。如果记录到达了”supremum”，说明当前Page里没有合适的键，这时要借助Page的Next Page指针，跳转到下一个Page继续从”Infimum”开始逐个查找。</p>
</li>
</ul>
<p><img src="/images/img/08-12/5d08a381-893c-401d-a28a-656f1acabfe8.png" alt="img"></p>
<p>细看下不同类型的Record里到底存储了什么数据，根据B+树节点的不同，User Record可以被分成四种格式，下图种按照颜色予以区分。</p>
<p><strong>主索引树非叶节点（绿色</strong></p>
<ul>
<li><p>1 子节点存储的主键里最小的值（Min Cluster Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。</p>
</li>
<li><p>2 最小的值所在的Page的编号（Child Page Number），作用是定位Record。</p>
</li>
</ul>
<p><strong>2 主索引树叶子节点（黄色）</strong></p>
<ul>
<li><p>1 主键（Cluster Key Fields），B+树必须的，也是数据行的一部分</p>
</li>
<li><p> 2 除去主键以外的所有列（Non-Key Fields），这是数据行的除去主键的其他所有列的集合。</p>
</li>
</ul>
<p>　　这里的1和2两部分加起来就是一个完整的数据行。</p>
<p>　<strong>3 辅助索引树非叶节点非（蓝色）</strong></p>
<ul>
<li><p> 1 子节点里存储的辅助键值里的最小的值（Min Secondary-Key on Child），这是B+树必须的，作用是在一个Page里定位到具体的记录的位置。</p>
</li>
<li><p> 2 主键值（Cluster Key Fields），非叶子节点为什么要存储主键呢？因为辅助索引是可以不唯一的，但是B+树要求键的值必须唯一，所以这里把辅助键的值和主键的值合并起来作为在B+树中的真正键值，保证了唯一性。但是这也导致在辅助索引B+树中非叶节点反而比叶子节点多了4个字节。（即下图中蓝色节点反而比红色多了4字节）</p>
</li>
<li><p>3 最小的值所在的Page的编号（Child Page Number），作用是定位Record。</p>
</li>
</ul>
<p>　<strong>4 辅助索引树叶子节点（红色）</strong></p>
<ul>
<li><p> 1 辅助索引键值（Secondary Key Fields），这是B+树必须的。</p>
</li>
<li><p> 2 主键值（Cluster Key Fields），用来在主索引树里再做一次B+树检索来找到整条记录。</p>
</li>
</ul>
<p><img src="/images/img/08-12/4dbb98e7-2855-4e62-ad48-5a27d1aefcb6.png" alt="img"></p>
<p>下面是本篇最重要的部分了，结合B+树的结构和前面介绍的4种Record的内容，我们终于可以画出一幅全景图。由于辅助索引的B+树与主键索引有相似的结构，这里只画出了主键索引树的结构图，只包含了”主键非叶节点”和”主键叶子节点”两种节点，也就是上图的的绿色和黄色的部分。</p>
<p><img src="/images/img/08-12/d9c5e5d5-8570-4b26-8ac9-381c04f7f520.png" alt="img"></p>
<p>把上图还原成下面这个更简洁的树形示意图，这就是B+树的一部分。注意Page和B+树节点之间并没有一一对应的关系，Page只是作为一个Record的保存容器，它存在的目的是便于对磁盘空间进行批量管理，上图中的编号为47的Page在树形结构上就被拆分成了两个独立节点。</p>
<p><img src="/images/img/08-12/625f5bfc-fed7-4a6b-b1f6-97ffbc8ed0f1.png" alt="img"></p>
<h3 id="索引使用策略及优化"><a href="#索引使用策略及优化" class="headerlink" title="索引使用策略及优化"></a>索引使用策略及优化</h3><p>MySQL的优化主要分为结构优化（Scheme optimization）和查询优化（Query optimization）。本章讨论的高性能索引策略主要属于结构优化范畴。本章的内容完全基于上文的理论基础，实际上一旦理解了索引背后的机制，那么选择高性能的策略就变成了纯粹的推理，并且可以理解这些策略背后的逻辑。</p>
<h4 id="示例数据库"><a href="#示例数据库" class="headerlink" title="示例数据库"></a>示例数据库</h4><p>为了讨论索引策略，需要一个数据量不算小的数据库作为示例。本文选用MySQL官方文档中提供的示例数据库之一：employees。这个数据库关系复杂度适中，且数据量较大。下图是这个数据库的E-R关系图（引用自MySQL官方手册）：</p>
<p><img src="/images/img/08-12/3c8a7b0f-24c0-4298-87da-ae86cd98f4ef.png" alt="img"></p>
<p>MySQL官方文档中关于此数据库的页面为<a href="http://dev.mysql.com/doc/employee/en/employee.html%E3%80%82%E9%87%8C%E9%9D%A2%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E4%BA%86%E6%AD%A4%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%8C%E5%B9%B6%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E5%92%8C%E5%AF%BC%E5%85%A5%E6%96%B9%E6%B3%95%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%9C%89%E5%85%B4%E8%B6%A3%E5%AF%BC%E5%85%A5%E6%AD%A4%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84MySQL%E5%8F%AF%E4%BB%A5%E5%8F%82%E8%80%83%E6%96%87%E4%B8%AD%E5%86%85%E5%AE%B9%E3%80%82">http://dev.mysql.com/doc/employee/en/employee.html。里面详细介绍了此数据库，并提供了下载地址和导入方法，如果有兴趣导入此数据库到自己的MySQL可以参考文中内容。</a></p>
<h4 id="最左前缀原理与相关优化"><a href="#最左前缀原理与相关优化" class="headerlink" title="最左前缀原理与相关优化"></a>最左前缀原理与相关优化</h4><p>高效使用索引的首要条件是知道什么样的查询会使用到索引，这个问题和B+Tree中的“最左前缀原理”有关，下面通过例子说明最左前缀原理。</p>
<p>这里先说一下联合索引的概念。在上文中，我们都是假设索引只引用了单个的列，实际上，MySQL中的索引可以以一定顺序引用多个列，这种索引叫做联合索引，一般的，一个联合索引是一个有序元组&lt;a1, a2, …, an&gt;，其中各个元素均为数据表的一列，实际上要严格定义索引需要用到关系代数，但是这里我不想讨论太多关系代数的话题，因为那样会显得很枯燥，所以这里就不再做严格定义。另外，单列索引可以看成联合索引元素数为1的特例。</p>
<p>以employees.titles表为例，下面先查看其上都有哪些索引：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SHOW</span> INDEX <span class="keyword">FROM</span> employees.titles;</span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> <span class="keyword">Table</span>  <span class="operator">|</span> Non_unique <span class="operator">|</span> Key_name <span class="operator">|</span> Seq_in_index <span class="operator">|</span> Column_name <span class="operator">|</span> <span class="keyword">Collation</span> <span class="operator">|</span> <span class="keyword">Cardinality</span> <span class="operator">|</span> <span class="keyword">Null</span> <span class="operator">|</span> Index_type <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">2</span> <span class="operator">|</span> title       <span class="operator">|</span> A         <span class="operator">|</span>        <span class="keyword">NULL</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">0</span> <span class="operator">|</span> <span class="keyword">PRIMARY</span>  <span class="operator">|</span>            <span class="number">3</span> <span class="operator">|</span> from_date   <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">|</span> titles <span class="operator">|</span>          <span class="number">1</span> <span class="operator">|</span> emp_no   <span class="operator">|</span>            <span class="number">1</span> <span class="operator">|</span> emp_no      <span class="operator">|</span> A         <span class="operator">|</span>      <span class="number">443308</span> <span class="operator">|</span>      <span class="operator">|</span> BTREE      <span class="operator">|</span></span><br><span class="line"><span class="operator">+</span><span class="comment">--------+------------+----------+--------------+-------------+-----------+-------------+------+------------+</span></span><br></pre></td></tr></table></figure>

<p>从结果中可以到titles表的主索引为&lt;emp_no, title, from_date&gt;，还有一个辅助索引<emp_no>。为了避免多个索引使事情变复杂（MySQL的SQL优化器在多索引时行为比较复杂），这里我们将辅助索引drop掉：ALTER TABLE employees.titles DROP INDEX emp_no;这样就可以专心分析索引PRIMARY的行为了。</p>
<h5 id="情况一：全列匹配。"><a href="#情况一：全列匹配。" class="headerlink" title="情况一：全列匹配。"></a>情况一：全列匹配。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure>

<p>很明显，当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。这里有一点需要注意，理论上索引对顺序是敏感的，但是由于MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引，例如我们将where中的条件顺序颠倒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date&#x3D;&#39;1986-06-26&#39; AND emp_no&#x3D;&#39;10001&#39; AND title&#x3D;&#39;Senior Engineer&#39;;+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref               | rows | Extra |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+|  1 | SIMPLE      | titles | const | PRIMARY       | PRIMARY | 59      | const,const,const |    1 |       |+----+-------------+--------+-------+---------------+---------+---------+-------------------+------+-------+</span><br></pre></td></tr></table></figure>

<p>效果是一样的。</p>
<h5 id="情况二：最左前缀匹配。"><a href="#情况二：最左前缀匹配。" class="headerlink" title="情况二：最左前缀匹配。"></a>情况二：最左前缀匹配。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 |       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------+</span><br></pre></td></tr></table></figure>

<p>当查询条件精确匹配索引的左边连续一个或几个列时，如<emp_no>或&lt;emp_no, title&gt;，所以可以被用到，但是只能用到一部分，即条件所组成的最左前缀。上面的查询从分析结果看用到了PRIMARY索引，但是key_len为4，说明只用到了索引的第一列前缀。</p>
<h5 id="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"><a href="#情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。" class="headerlink" title="情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。"></a>情况三：查询条件用到了索引中列的精确匹配，但是中间某个条件未提供。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>此时索引使用情况和情况二相同，因为title未提供，所以查询只用到了索引的第一列，而后面的from_date虽然也在索引中，但是由于title不存在而无法和左前缀连接，因此需要对结果进行扫描过滤from_date（这里由于emp_no唯一，所以不存在扫描）。如果想让from_date也使用索引而不是where过滤，可以增加一个辅助索引&lt;emp_no, from_date&gt;，此时上面的查询会使用这个索引。除此之外，还可以使用一种称之为“隔离列”的优化方法，将emp_no与from_date之间的“坑”填上。</p>
<p>首先我们看下title一共有几种不同的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT DISTINCT(title) FROM employees.titles;+--------------------+| title              |+--------------------+| Senior Engineer    || Staff              || Engineer           || Senior Staff       || Assistant Engineer || Technique Leader   || Manager            |+--------------------+</span><br></pre></td></tr></table></figure>

<p>只有7种。在这种成为“坑”的列值比较少的情况下，可以考虑用“IN”来填补这个“坑”从而形成最左前缀：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no&#x3D;&#39;10001&#39;AND title IN (&#39;Senior Engineer&#39;, &#39;Staff&#39;, &#39;Engineer&#39;, &#39;Senior Staff&#39;, &#39;Assistant Engineer&#39;, &#39;Technique Leader&#39;, &#39;Manager&#39;)AND from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |    7 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>这次key_len为59，说明索引被用全了，但是从type和rows看出IN实际上执行了一个range查询，这里检查了7个key。看下两种查询的性能比较：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW PROFILES;+----------+------------+-------------------------------------------------------------------------------+| Query_ID | Duration   | Query                                                                         |+----------+------------+-------------------------------------------------------------------------------+|       10 | 0.00058000 | SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND from_date&#x3D;&#39;1986-06-26&#39;||       11 | 0.00052500 | SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title IN ...          |+----------+------------+-------------------------------------------------------------------------------+</span><br></pre></td></tr></table></figure>

<p>“填坑”后性能提升了一点。如果经过emp_no筛选后余下很多数据，则后者性能优势会更加明显。当然，如果title的值很多，用填坑就不合适了，必须建立辅助索引。</p>
<h5 id="情况四：查询条件没有指定索引第一列。"><a href="#情况四：查询条件没有指定索引第一列。" class="headerlink" title="情况四：查询条件没有指定索引第一列。"></a>情况四：查询条件没有指定索引第一列。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE from_date&#x3D;&#39;1986-06-26&#39;;+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>

<p>由于不是最左前缀，索引这样的查询显然用不到索引。</p>
<h5 id="情况五：匹配某列的前缀字符串。"><a href="#情况五：匹配某列的前缀字符串。" class="headerlink" title="情况五：匹配某列的前缀字符串。"></a>情况五：匹配某列的前缀字符串。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND title LIKE &#39;Senior%&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 56      | NULL |    1 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>此时可以用到索引，<del>但是如果通配符不是只出现在末尾，则无法使用索引。</del>（原文表述有误，如果通配符%不出现在开头，则可以用到索引，但根据具体情况不同可能只会用其中一个前缀）</p>
<h5 id="情况六：范围查询。"><a href="#情况六：范围查询。" class="headerlink" title="情况六：范围查询。"></a>情况六：范围查询。</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no &lt; &#39;10010&#39; and title&#x3D;&#39;Senior Engineer&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>范围列可以用到索引（必须是最左前缀），但是范围列后面的列无法用到索引。同时，索引最多用于一个范围列，因此如果查询条件中有两个范围列则无法全用到索引。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no &lt; &#39;10010&#39;AND title&#x3D;&#39;Senior Engineer&#39;AND from_date BETWEEN &#39;1986-01-01&#39; AND &#39;1986-12-31&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 4       | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>可以看到索引对第二个范围索引无能为力。这里特别要说明MySQL一个有意思的地方，那就是仅用explain可能无法区分范围索引和多值匹配，因为在type中这两者都显示为range。同时，用了“between”并不意味着就是范围查询，例如下面的查询：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titlesWHERE emp_no BETWEEN &#39;10001&#39; AND &#39;10010&#39;AND title&#x3D;&#39;Senior Engineer&#39;AND from_date BETWEEN &#39;1986-01-01&#39; AND &#39;1986-12-31&#39;;+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+| id | select_type | table  | type  | possible_keys | key     | key_len | ref  | rows | Extra       |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+|  1 | SIMPLE      | titles | range | PRIMARY       | PRIMARY | 59      | NULL |   16 | Using where |+----+-------------+--------+-------+---------------+---------+---------+------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>看起来是用了两个范围查询，但作用于emp_no上的“BETWEEN”实际上相当于“IN”，也就是说emp_no实际是多值精确匹配。可以看到这个查询用到了索引全部三个列。因此在MySQL中要谨慎地区分多值匹配和范围匹配，否则会对MySQL的行为产生困惑。</p>
<h5 id="情况七：查询条件中含有函数或表达式。"><a href="#情况七：查询条件中含有函数或表达式。" class="headerlink" title="情况七：查询条件中含有函数或表达式。"></a>情况七：查询条件中含有函数或表达式。</h5><p>很不幸，如果查询条件中含有函数或表达式，则MySQL不会为这列使用索引（虽然某些在数学意义上可以使用）。例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no&#x3D;&#39;10001&#39; AND left(title, 6)&#x3D;&#39;Senior&#39;;+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+| id | select_type | table  | type | possible_keys | key     | key_len | ref   | rows | Extra       |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+|  1 | SIMPLE      | titles | ref  | PRIMARY       | PRIMARY | 4       | const |    1 | Using where |+----+-------------+--------+------+---------------+---------+---------+-------+------+-------------+</span><br></pre></td></tr></table></figure>

<p>虽然这个查询和情况五中功能相同，但是由于使用了函数left，则无法为title列应用索引，而情况五中用LIKE则可以。再如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.titles WHERE emp_no - 1&#x3D;&#39;10000&#39;;+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table  | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | titles | ALL  | NULL          | NULL | NULL    | NULL | 443308 | Using where |+----+-------------+--------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>

<p>显然这个查询等价于查询emp_no为10001的函数，但是由于查询条件是一个表达式，MySQL无法为其使用索引。看来MySQL还没有智能到自动优化常量表达式的程度，因此在写查询语句时尽量避免表达式出现在查询中，而是先手工私下代数运算，转换为无表达式的查询语句。</p>
<h4 id="索引选择性与前缀索引"><a href="#索引选择性与前缀索引" class="headerlink" title="索引选择性与前缀索引"></a>索引选择性与前缀索引</h4><p>既然索引可以加快查询速度，那么是不是只要是查询语句需要，就建上索引？答案是否定的。因为索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。</p>
<p>第一种情况是表记录比较少，例如一两千条甚至只有几百条记录的表，没必要建索引，让查询做全表扫描就好了。至于多少条记录才算多，这个个人有个人的看法，我个人的经验是以2000作为分界线，记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。</p>
<p>另一种不建议建索引的情况是索引的选择性较低。所谓索引的选择性（Selectivity），是指不重复的索引值（也叫基数，Cardinality）与表记录数（#T）的比值：</p>
<p>Index Selectivity = Cardinality / #T</p>
<p>显然选择性的取值范围为(0, 1]，选择性越高的索引价值越大，这是由B+Tree的性质决定的。例如，上文用到的employees.titles表，如果title字段经常被单独查询，是否需要建索引，我们看一下它的选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(title))&#x2F;count(*) AS Selectivity FROM employees.titles;+-------------+| Selectivity |+-------------+|      0.0000 |+-------------+</span><br></pre></td></tr></table></figure>
<p>title的选择性不足0.0001（精确值为0.00001579），所以实在没有什么必要为其单独建索引。</p>
<p>有一种与索引选择性有关的索引优化策略叫做前缀索引，就是用列的前缀代替整个列作为索引key，当前缀长度合适时，可以做到既使得前缀索引的选择性接近全列索引，同时因为索引key变短而减少了索引文件的大小和维护开销。下面以employees.employees表为例介绍前缀索引的选择和使用。</p>
<p>从图12可以看到employees表只有一个索引<emp_no>，那么如果我们想按名字搜索一个人，就只能全表扫描了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EXPLAIN SELECT * FROM employees.employees WHERE first_name&#x3D;&#39;Eric&#39; AND last_name&#x3D;&#39;Anido&#39;;+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 300024 | Using where |+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+</span><br></pre></td></tr></table></figure>

<p>如果频繁按名字搜索员工，这样显然效率很低，因此我们可以考虑建索引。有两种选择，建<first_name>或&lt;first_name, last_name&gt;，看下两个索引的选择性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT count(DISTINCT(first_name))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.0042 |+-------------+SELECT count(DISTINCT(concat(first_name, last_name)))&#x2F;count(*) AS Selectivity FROM employees.employees;+-------------+| Selectivity |+-------------+|      0.9313 |+-------------+</span><br></pre></td></tr></table></figure>

<p><first_name>显然选择性太低，&lt;first_name, last_name&gt;选择性很好，但是first_name和last_name加起来长度为30，有没有兼顾长度和选择性的办法？可以考虑用first_name和last_name的前几个字符建立索引，例如&lt;first_name, left(last_name, 3)&gt;，看看其选择性：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(concat(first_name, <span class="keyword">left</span>(last_name, <span class="number">3</span>))))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;<span class="operator">+</span><span class="comment">-------------+| Selectivity |+-------------+|      0.7879 |+-------------+</span></span><br></pre></td></tr></table></figure>

<p>选择性还不错，但离0.9313还是有点距离，那么把last_name前缀加到4：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">count</span>(<span class="keyword">DISTINCT</span>(concat(first_name, <span class="keyword">left</span>(last_name, <span class="number">4</span>))))<span class="operator">/</span><span class="built_in">count</span>(<span class="operator">*</span>) <span class="keyword">AS</span> Selectivity <span class="keyword">FROM</span> employees.employees;<span class="operator">+</span><span class="comment">-------------+| Selectivity |+-------------+|      0.9007 |+-------------+</span></span><br></pre></td></tr></table></figure>

<p>这时选择性已经很理想了，而这个索引的长度只有18，比&lt;first_name, last_name&gt;短了接近一半，我们把这个前缀索引 建上：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> employees.employeesADD INDEX `first_name_last_name4` (first_name, last_name(<span class="number">4</span>));</span><br></pre></td></tr></table></figure>

<p>此时再执行一遍按名字查询，比较分析一下与建索引前的结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> PROFILES;<span class="operator">+</span><span class="comment">----------+------------+---------------------------------------------------------------------------------+| Query_ID | Duration   | Query                                                                           |+----------+------------+---------------------------------------------------------------------------------+|       87 | 0.11941700 | SELECT * FROM employees.employees WHERE first_name=&#x27;Eric&#x27; AND last_name=&#x27;Anido&#x27; ||       90 | 0.00092400 | SELECT * FROM employees.employees WHERE first_name=&#x27;Eric&#x27; AND last_name=&#x27;Anido&#x27; |+----------+------------+---------------------------------------------------------------------------------+</span></span><br></pre></td></tr></table></figure>

<p>性能的提升是显著的，查询速度提高了120多倍。</p>
<p>前缀索引兼顾索引大小和查询速度，但是其缺点是不能用于ORDER BY和GROUP BY操作，也不能用于Covering index（即当索引本身包含查询所需全部数据时，不再访问数据文件本身）。</p>
<h4 id="InnoDB的主键选择与插入优化"><a href="#InnoDB的主键选择与插入优化" class="headerlink" title="InnoDB的主键选择与插入优化"></a>InnoDB的主键选择与插入优化</h4><p>在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。</p>
<p>经常看到有帖子或博客讨论主键选择问题，有人建议使用业务无关的自增主键，有人觉得没有必要，完全可以使用如学号或身份证号这种唯一字段作为主键。不论支持哪种论点，大多数论据都是业务层面的。如果从数据库索引优化角度看，使用InnoDB引擎而不使用自增主键绝对是一个糟糕的主意。</p>
<p>上文讨论过InnoDB的索引实现，InnoDB使用聚集索引，数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15/16），则开辟一个新的页（节点）。</p>
<p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。如下图所示：</p>
<p><img src="/images/img/08-12/7e6521f2-3f59-4266-b63c-b098ac816947.png" alt="img"></p>
<p>这样就会形成一个紧凑的索引结构，近似顺序填满。由于每次插入时也不需要移动已有数据，因此效率很高，也不会增加很多开销在维护索引上。</p>
<p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置。</p>
<p><img src="/images/img/08-12/f2963ad4-aa24-4b0d-8eb2-a918ee194f8e.png" alt="img"></p>
<p>此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p>
<p>因此，只要可以，请尽量在InnoDB上采用自增字段做主键。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文章来源：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;shijingxiang&#x2F;articles&#x2F;4743324.html</span><br><span class="line">文章来源：https:&#x2F;&#x2F;blog.codinglabs.org&#x2F;articles&#x2F;theory-of-mysql-index.html</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
        <tag>mysql</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>heap堆</title>
    <url>/2019/08/07/heap%E5%A0%86/</url>
    <content><![CDATA[<h3 id="堆是解决优先级队列，topK问题的常见算法。"><a href="#堆是解决优先级队列，topK问题的常见算法。" class="headerlink" title="堆是解决优先级队列，topK问题的常见算法。"></a>堆是解决优先级队列，topK问题的常见算法。</h3><p>二叉堆的结构性质：堆是一个完全被填满的二叉树，一颗高位h的二叉树有 2^h到2^h+1 - 1个节点。</p>
<p>堆的性质：父节点的键值总是不大于它的孩子节点的键值（小顶堆）, 堆可以分为小顶堆和大顶堆。 以0开头的 数组中i处的左子节点为 2 * i + 1 右子节点在 2 * i + 2，子节点的父节点在 （i-1）/2处。具有有序性，但是不是说对插入的值是完全按照 单调的顺序排序的。<span id="more"></span></p>
<p><img src="/images/img/08-07/c5b78405-6523-4b41-af40-13448b431648.png"></p>
<p>可以看出看出位于数组下标三的左子节点和右子节点符合定义，在 2 * 3 + 1 = 7【数组下标】； 2 * 3 + 2 = 8【数组下标8】<!--more--></p>
<h3 id="插入的操作"><a href="#插入的操作" class="headerlink" title="插入的操作"></a>插入的操作</h3><p>先插入到数组最后一个坐标下，如果可以放在最后一个坐标【符合二叉堆的性质】大于父节点【小顶堆】。如果不符合需要朝着父节点的方向一步一步上移。</p>
<p>如上图插入14的过程.</p>
<p>1:插入底部</p>
<p><img src="/images/img/08-07/f41c8b2d-e2ed-4d18-a1ea-b9a0f28931a9.png"></p>
<p> 2:上移 14 与父节点互换值</p>
<p><img src="/images/img/08-07/fef77d6f-6a19-478a-8268-ea7f6f5a2883.png"></p>
<p>3:判断继续上移与父节点【21】互换值</p>
<p><img src="/images/img/08-07/d09b977c-8f72-4536-ab8f-e194698dead6.png"></p>
<p>到达条件退出上浮操作</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params">&amp;<span class="variable">$arr</span>, <span class="variable">$value</span></span>) </span>&#123;</span><br><span class="line">      <span class="variable">$arr</span>[] = <span class="variable">$value</span>;</span><br><span class="line">      <span class="variable">$len</span>  = count(<span class="variable">$arr</span>) - <span class="number">1</span>;</span><br><span class="line">      <span class="variable">$i</span> = <span class="variable">$len</span>;</span><br><span class="line">      <span class="keyword">while</span>(<span class="variable">$i</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="variable">$j</span> = (<span class="variable">$i</span> - <span class="number">1</span>)/<span class="number">2</span>;<span class="comment">//找到父节点</span></span><br><span class="line">             <span class="keyword">if</span> (<span class="variable">$j</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$j</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$i</span>]) &#123;</span><br><span class="line">                     <span class="variable">$tmp</span> = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">                     <span class="variable">$arr</span>[<span class="variable">$i</span>] = <span class="variable">$arr</span>[<span class="variable">$j</span>];</span><br><span class="line">                     <span class="variable">$arr</span>[<span class="variable">$j</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">                     <span class="variable">$i</span> = <span class="variable">$j</span>;<span class="comment">//往上上浮</span></span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">             &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>删除其实和插入类似，把数组第一个节点数据取出作为返回数据，把数组最后一个元素取出用于比较，重新比较让结构符合二叉堆的性质。其实删除的是最后一个数组节点，其他数据通过比较运算一个放到合适的节点。</p>
<p>1:取出第一个数组的值 13 和最后一个值31</p>
<p><img src="/images/img/08-07/a0afaf79-7cd1-4918-9ccb-08683554ed02.png"></p>
<p>2:14 和 16比较 那个大小 决定往哪一个方向走，是往 14 左子树走，还是往16 的左子树走。用最后一个值【31】 与 当前走向的节点比较，如果最后一个值【31】如果大于当前节点继续往下进行。</p>
<p><img src="/images/img/08-07/cf29c3be-1f7d-44e0-a97e-903e66443c21.png"></p>
<p><img src="/images/img/08-07/98d16f4f-2cc1-44ab-a048-be8e7cc36694.png"></p>
<p><img src="/images/img/08-07/9640dfdc-cc2d-40b3-a3a1-347824df31c9.png"></p>
<p><img src="/images/img/08-07/bf50d17f-e654-40b2-a687-9da633fae3a1.png"></p>
<p>代码实现：上图那些空的其实还保留着原来的值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params">&amp;<span class="variable">$arr</span></span>) </span>&#123;</span><br><span class="line">    <span class="variable">$midValue</span> = <span class="variable">$arr</span>[<span class="number">0</span>]; <span class="comment">//取得第一个元素</span></span><br><span class="line">    <span class="variable">$len</span> = count(<span class="variable">$arr</span>) - <span class="number">1</span>;<span class="comment">//取得数组的长度</span></span><br><span class="line">    <span class="variable">$lastVal</span>  = <span class="variable">$arr</span>[<span class="variable">$len</span>];<span class="comment">//取得最后一个值</span></span><br><span class="line">    <span class="variable">$j</span> = <span class="number">0</span>;<span class="comment">//从头开始</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">2</span> * <span class="variable">$j</span> &lt;= <span class="variable">$i</span>) &#123;<span class="comment">//防止节点超出数组长度</span></span><br><span class="line">           <span class="variable">$left</span>    =  <span class="number">2</span> * <span class="variable">$j</span> + <span class="number">1</span>;<span class="comment">//左子节点</span></span><br><span class="line">           <span class="variable">$right</span>  =  <span class="number">2</span> * <span class="variable">$j</span> + <span class="number">2</span>;<span class="comment">//右子节点</span></span><br><span class="line">           <span class="variable">$t</span> = <span class="variable">$left</span>;<span class="comment">//走向，初始往左边走</span></span><br><span class="line">           <span class="keyword">if</span> (<span class="variable">$arr</span>[<span class="variable">$right</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$right</span>] &lt; <span class="variable">$arr</span>[<span class="variable">$left</span>]) &#123;<span class="comment">//决定往左子树走，还是右子树走</span></span><br><span class="line">                <span class="variable">$t</span> = <span class="variable">$right</span>; <span class="comment">//往右边走</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$lastVal</span> &gt; <span class="variable">$arr</span>[<span class="variable">$j</span>]) &#123;</span><br><span class="line">                 <span class="variable">$arr</span>[<span class="variable">$j</span>] = <span class="variable">$arr</span>[<span class="variable">$t</span>];<span class="comment">//把子节点上浮，继续往下走</span></span><br><span class="line">                 <span class="variable">$j</span> = <span class="variable">$t</span>;<span class="comment">//下次比较的数组下标</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           &#125;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="variable">$arr</span>[<span class="variable">$j</span>] = <span class="variable">$lastVal</span>;<span class="comment">//重新放入最后一个节点，如上图的操作 最后 $j 的坐标值 是 10 但是下边的删除语句删除它了，保证此二叉堆还是一个满二叉堆且符合二叉堆性质</span></span><br><span class="line">    <span class="variable">$unset</span>[<span class="variable">$arr</span>[<span class="variable">$len</span>]];<span class="comment">//删除最后一个元素</span></span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$arr</span>;<span class="comment">//返回数组</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//全部代码</span></span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by PhpStorm.</span></span><br><span class="line"><span class="comment"> * User: lhs</span></span><br><span class="line"><span class="comment"> * Date: 2019-06-18</span></span><br><span class="line"><span class="comment"> * Time: 10:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class heap</span></span><br><span class="line"><span class="comment"> * 二叉堆【优先级队列】</span></span><br><span class="line"><span class="comment"> * 二叉堆的定义是：父节点的键值总是不大于它的孩子节点的键值（小顶堆）, 堆可以分为小顶堆和大顶堆。</span></span><br><span class="line"><span class="comment"> *     在数组中i处的左子节点为 2 * i + 1 右子节点在 2 * i + 2，子节点的父节点在 （i-1）/2处</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$heapArr</span> = [];</span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$heapSize</span> = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $testArr</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"><span class="variable">$testArr</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $val</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">insert</span>(<span class="params"><span class="variable">$val</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;heapSize++;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;heapArr[<span class="keyword">$this</span>-&gt;heapSize] = <span class="variable">$val</span>;</span><br><span class="line">        <span class="variable">$i</span>                              = (count(<span class="keyword">$this</span>-&gt;heapArr) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$i</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="variable">$j</span> = (<span class="variable">$i</span> - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$j</span> &gt;= <span class="number">0</span> &amp;&amp; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$i</span>] &lt; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>]) &#123;</span><br><span class="line">                <span class="variable">$tmp</span>               = <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$i</span>];</span><br><span class="line">                <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$i</span>] = <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>];</span><br><span class="line">                <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>] = <span class="variable">$tmp</span>;</span><br><span class="line">                <span class="variable">$i</span>                 = <span class="variable">$j</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">delete</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$i</span>       = (count(<span class="keyword">$this</span>-&gt;heapArr) - <span class="number">1</span>);</span><br><span class="line">        <span class="variable">$minVal</span>  = <span class="keyword">$this</span>-&gt;heapArr[<span class="number">0</span>];</span><br><span class="line">        <span class="variable">$lastVal</span> = <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$i</span>];</span><br><span class="line">        <span class="variable">$j</span>       = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">2</span> * <span class="variable">$j</span> &lt;= <span class="variable">$i</span>) &#123;</span><br><span class="line">            <span class="variable">$left</span>  = <span class="number">2</span> * <span class="variable">$j</span> + <span class="number">1</span>;</span><br><span class="line">            <span class="variable">$right</span> = <span class="number">2</span> * <span class="variable">$j</span> + <span class="number">2</span>;</span><br><span class="line">            <span class="variable">$t</span>     = <span class="variable">$left</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$left</span>] &amp;&amp; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$right</span>] &amp;&amp; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$right</span>] &lt; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$left</span>]) &#123;</span><br><span class="line">                <span class="variable">$t</span> = <span class="variable">$right</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$lastVal</span> &gt; <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>]) &#123;</span><br><span class="line">                <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>] = <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$t</span>];</span><br><span class="line">                <span class="variable">$j</span>                 = <span class="variable">$t</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$j</span>] = <span class="variable">$lastVal</span>;</span><br><span class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;heapArr[<span class="variable">$i</span>]);</span><br><span class="line">        <span class="keyword">$this</span>-&gt;heapSize--;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$minVal</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">sort</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$arr</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//构建二叉堆</span></span><br><span class="line">        <span class="variable">$length</span> = count(<span class="variable">$arr</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = (<span class="variable">$length</span> - <span class="number">2</span>) / <span class="number">2</span>; <span class="variable">$i</span> &gt;= <span class="number">0</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">            <span class="variable">$arr</span> = <span class="keyword">$this</span>-&gt;down(<span class="variable">$arr</span>, <span class="variable">$i</span>, <span class="variable">$length</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        var_dump(<span class="variable">$arr</span>);</span><br><span class="line">        <span class="comment">//进行堆排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="variable">$length</span> - <span class="number">1</span>; <span class="variable">$i</span> &gt;= <span class="number">1</span>; <span class="variable">$i</span>--) &#123;</span><br><span class="line">            <span class="comment">//把堆顶的元素与最后一个元素交换</span></span><br><span class="line">            <span class="variable">$temp</span>    = <span class="variable">$arr</span>[<span class="variable">$i</span>];</span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$i</span>] = <span class="variable">$arr</span>[<span class="number">0</span>];</span><br><span class="line">            <span class="variable">$arr</span>[<span class="number">0</span>]  = <span class="variable">$temp</span>;</span><br><span class="line">            <span class="comment">//下沉调整</span></span><br><span class="line">            <span class="variable">$arr</span> = <span class="keyword">$this</span>-&gt;down(<span class="variable">$arr</span>, <span class="number">0</span>, <span class="variable">$i</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> array $arr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $parent</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> int $length</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">down</span>(<span class="params"><span class="keyword">array</span> <span class="variable">$arr</span>, <span class="keyword">int</span> <span class="variable">$parent</span>, <span class="keyword">int</span> <span class="variable">$length</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//临时保证要下沉的元素</span></span><br><span class="line">        <span class="variable">$temp</span> = <span class="variable">$arr</span>[<span class="variable">$parent</span>];</span><br><span class="line">        <span class="comment">//定位左孩子节点位置</span></span><br><span class="line">        <span class="variable">$child</span> = <span class="number">2</span> * <span class="variable">$parent</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//开始下沉</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$child</span> &lt; <span class="variable">$length</span>) &#123;</span><br><span class="line">            <span class="comment">//如果右孩子节点比左孩子小，则定位到右孩子</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$child</span> + <span class="number">1</span> &lt; <span class="variable">$length</span> &amp;&amp; <span class="variable">$arr</span>[<span class="variable">$child</span>] &gt; <span class="variable">$arr</span>[<span class="variable">$child</span> + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="variable">$child</span>++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果父节点比孩子节点小或等于，则下沉结束</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$temp</span> &lt;= <span class="variable">$arr</span>[<span class="variable">$child</span>]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//单向赋值</span></span><br><span class="line">            <span class="variable">$arr</span>[<span class="variable">$parent</span>] = <span class="variable">$arr</span>[<span class="variable">$child</span>];</span><br><span class="line">            <span class="variable">$parent</span>       = <span class="variable">$child</span>;</span><br><span class="line">            <span class="variable">$child</span>        = <span class="number">2</span> * <span class="variable">$parent</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable">$arr</span>[<span class="variable">$parent</span>] = <span class="variable">$temp</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$arr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$testArr</span> = [</span><br><span class="line">    <span class="number">31</span>,</span><br><span class="line">    <span class="number">21</span>,</span><br><span class="line">    <span class="number">19</span>,</span><br><span class="line">    <span class="number">68</span>,</span><br><span class="line">    <span class="number">26</span>,</span><br><span class="line">    <span class="number">65</span>,</span><br><span class="line">    <span class="number">19</span>,</span><br><span class="line">    <span class="number">14</span>,</span><br><span class="line">    <span class="number">13</span>,</span><br><span class="line">    <span class="number">16</span>,</span><br><span class="line">    <span class="number">32</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable">$heap</span> = <span class="keyword">new</span> heap();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*foreach ($testArr as $val) &#123;</span></span><br><span class="line"><span class="comment">    $heap-&gt;insert($val);</span></span><br><span class="line"><span class="comment">&#125;*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var_dump($heap-&gt;heapArr);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> json_encode(<span class="variable">$heap</span>-&gt;getTree(<span class="variable">$array</span>,<span class="number">0</span>));</span><br><span class="line"><span class="comment">//var_dump($heap-&gt;heapArr);</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>java线程</title>
    <url>/2021/04/20/java%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>一个进程是一个独立的程序运行单位：包括了内存，编译好的二进制代码，寄存器，堆践等等。</p>
<p>线程是最小的逻辑执行单元，只有在运行的时候才会有自身的寄存器等等。</p>
<p>一个进程可以多个线程。</p>
<ul>
<li>由于线程共享公共变量，所以对于公共变量的更改要加锁以便防止并发改，或者一个线程执行到一半，又有另外的线程更改。造成数据不一致。<span id="more"></span></li>
</ul>
<p>Java线程的创建或是执行方式：</p>
<p>1:使用lambda方式实现及实现Runnable接口</p>
<pre><code>                      <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Runnable r = ()-&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> toAccount = (<span class="keyword">int</span>) (bank.size() * Math.random());</span><br><span class="line">            <span class="keyword">double</span> amount = balance * Math.random();</span><br><span class="line">            System.out.print(formAccount);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            System.out.print(toAccount);</span><br><span class="line">            System.out.print(<span class="string">&quot;-&quot;</span>);</span><br><span class="line">            System.out.print(amount);</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            bank.tranfer(formAccount, toAccount, amount);</span><br><span class="line">            Thread.sleep(<span class="number">10</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception $e) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Thread t = <span class="keyword">new</span> Thread(r);</span><br><span class="line">t.start();</span><br></pre></td></tr></table></figure>
</code></pre>
<p>​             </p>
<p>2:继承并实现thread的run方法</p>
<p>二：线程的状态</p>
<p>​      new（新建）</p>
<p>​      runnable（可运行）</p>
<p>​      blocked（阻塞）</p>
<p>​      waiting（等待）</p>
<p>​       timed waiting (计时等待)</p>
<p>​       terminated（被终止）</p>
<p>三：线程之间的锁机制</p>
<p>​       3.1使用Lock和Condition</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="keyword">private</span> Lock bankLock;</span><br><span class="line">    <span class="keyword">private</span> Condition sufficientFunds;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs the bank.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n the number of accounts</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBalance the initial balance for each account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> initialBalance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts, initialBalance);</span><br><span class="line">        bankLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        sufficientFunds = bankLock.newCondition();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers money from one account to another.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from the account to transfer from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to the account to transfer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount the amount to transfer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tranfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (accounts[from] &lt; amount)</span><br><span class="line">                sufficientFunds.await();</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.print(Thread.currentThread()) ;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, amount, from, to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; Total Balance: %10.2f%n&quot;</span>, getTotalBalance());</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            sufficientFunds.signalAll();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bankLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> item : accounts) &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bankLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​                                 </p>
<p>3.2使用synchronized</p>
<p> synchronized关键字类似于lock用来锁定代码执行区域。</p>
<p>​       public synchronized void methodName()</p>
<p> {</p>
<p>​       local;</p>
<p>​              …method</p>
<p>​        unlock;</p>
<p>}</p>
<pre><code>   <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> Thread;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bank</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span>[] accounts;</span><br><span class="line">    <span class="comment">//private Lock bankLock;</span></span><br><span class="line">    <span class="comment">//private Condition sufficientFunds;</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs the bank.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n the number of accounts</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> initialBalance the initial balance for each account</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bank</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">double</span> initialBalance)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        accounts = <span class="keyword">new</span> <span class="keyword">double</span>[n];</span><br><span class="line">        Arrays.fill(accounts, initialBalance);</span><br><span class="line">        <span class="comment">//bankLock = new ReentrantLock();</span></span><br><span class="line">        <span class="comment">//sufficientFunds = bankLock.newCondition();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Transfers money from one account to another.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from the account to transfer from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to the account to transfer to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount the amount to transfer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">tranfer</span><span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to, <span class="keyword">double</span> amount)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (accounts[from] &lt; amount)</span><br><span class="line">                wait();</span><br><span class="line">            accounts[from] -= amount;</span><br><span class="line">            System.out.print(Thread.currentThread()) ;</span><br><span class="line">            System.out.printf(<span class="string">&quot; %10.2f from %d to %d&quot;</span>, amount, from, to);</span><br><span class="line">            accounts[to] += amount;</span><br><span class="line">            System.out.printf(<span class="string">&quot; Total Balance: %10.2f%n&quot;</span>, getTotalBalance());</span><br><span class="line">            System.out.print(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">            notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    public void tranfer(int from, int to, double amount) throws InterruptedException</span></span><br><span class="line"><span class="comment">//    &#123;</span></span><br><span class="line"><span class="comment">//        bankLock.lock();</span></span><br><span class="line"><span class="comment">//        try &#123;</span></span><br><span class="line"><span class="comment">//            while (accounts[from] &lt; amount)</span></span><br><span class="line"><span class="comment">//                sufficientFunds.await();</span></span><br><span class="line"><span class="comment">//            accounts[from] -= amount;</span></span><br><span class="line"><span class="comment">//            System.out.print(Thread.currentThread()) ;</span></span><br><span class="line"><span class="comment">//            System.out.printf(&quot; %10.2f from %d to %d&quot;, amount, from, to);</span></span><br><span class="line"><span class="comment">//            accounts[to] += amount;</span></span><br><span class="line"><span class="comment">//            System.out.printf(&quot; Total Balance: %10.2f%n&quot;, getTotalBalance());</span></span><br><span class="line"><span class="comment">//            System.out.print(&quot;\n&quot;);</span></span><br><span class="line"><span class="comment">//            sufficientFunds.signalAll();</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125; finally &#123;</span></span><br><span class="line"><span class="comment">//            bankLock.unlock();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">double</span> <span class="title">getTotalBalance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//bankLock.lock();</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">double</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">double</span> item : accounts) &#123;</span><br><span class="line">                sum += item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">// bankLock.unlock();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> accounts.length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>四：线程安全的集合</p>
<p>五：线程池</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>java注解写一个简单路由示例</title>
    <url>/2021/04/22/java%E6%B3%A8%E8%A7%A3%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%B7%AF%E7%94%B1%E7%A4%BA%E4%BE%8B/</url>
    <content><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>注解是放在Java源码的类、方法、字段、参数前的一种特殊“注释”。是附加在代码中的一些元信息，用于编译和运行时进行解析和使用，起到说明、配置的功能。注解不会影响代码的实际逻辑，仅仅起到辅助性的作用。包含在java.lang.annotation包中。</p>
<p>​     注释不会打包到class文件中，注解则可以被编译器打包进入class文件，因此，注解是一种用作标注的“元数据”。</p>
<h4 id="注解大致分为三类"><a href="#注解大致分为三类" class="headerlink" title="注解大致分为三类"></a>注解大致分为三类</h4><ul>
<li> 第一类是由编译器使用的注解【这类注解不会被编译进入<code>.class</code>文件，它们在编译后就被编译器扔掉了。】<span id="more"></span></li>
</ul>
<ul>
<li><code>@Override</code>：让编译器检查该方法是否正确地实现了覆写；</li>
<li><code>@SuppressWarnings</code>：告诉编译器忽略此处代码产生的警告</li>
</ul>
<ul>
<li><p>第二类是由工具处理<code>.class</code>文件使用的注解</p>
<p>有些工具会在加载class的时候，对class做动态修改，实现一些特殊的功能。这类注解会被编译进入<code>.class</code>文件，但加载结束后并不会存在于内存中。这类注解只被一些底层库使用，一般我们不必自己处理。</p>
</li>
<li><p>第三类是在程序运行期能够读取的注解【使用@Retention(RetentionPolicy.RUNTIME) 注解修饰】</p>
<p>它们在加载后一直存在于JVM中，这也是最常用的注解。例如，一个配置了<code>@PostConstruct</code>的方法会在调用构造方法后自动被调用（这是Java代码读取该注解实现的功能，JVM并不会识别该注解）。</p>
</li>
</ul>
<h4 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h4><p>Java语言使用<code>@interface</code>语法来定义注解（<code>Annotation</code>），它的格式如下.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义注解路由</span></span><br><span class="line"><span class="keyword">package</span> route;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="comment">//描述注解的作用域</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span></span><br><span class="line"><span class="comment">//定义注解的使用期间</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> pathMap &#123;</span><br><span class="line">  <span class="comment">//给注解定义一个参数</span></span><br><span class="line">    <span class="function">String <span class="title">uri</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解的参数类似无参数方法，可以用<code>default</code>设定一个默认值（强烈推荐）.</p>
<ul>
<li><p>元注解</p>
<p>有一些注解可以修饰其他注解，这些注解就称为元注解（meta annotation）。Java标准库已经定义了一些元注解，我们只需要使用元注解，通常不需要自己去编写元注解。</p>
<p>最常用的元注解是<code>@Target</code>。使用<code>@Target</code>可以定义<code>Annotation</code>能够被应用于源码的哪些位置：</p>
<ul>
<li><p>类或接口：<code>ElementType.TYPE</code>；</p>
</li>
<li><p>字段：<code>ElementType.FIELD</code>；</p>
</li>
<li><p>方法：<code>ElementType.METHOD</code>；</p>
</li>
<li><p>构造方法：<code>ElementType.CONSTRUCTOR</code>；</p>
</li>
<li><p>方法参数：<code>ElementType.PARAMETER</code>。</p>
</li>
</ul>
<p>另一个重要的元注解<code>@Retention</code>定义了<code>Annotation</code>的生命周期：</p>
<ul>
<li><p>仅编译期：<code>RetentionPolicy.SOURCE</code>；</p>
</li>
<li><p>仅class文件：<code>RetentionPolicy.CLASS</code>；</p>
</li>
<li><p>运行期：<code>RetentionPolicy.RUNTIME</code>。</p>
</li>
</ul>
</li>
</ul>
<p>如果<code>@Retention</code>不存在，则该<code>Annotation</code>默认为<code>CLASS</code>。因为通常我们自定义的<code>Annotation</code>都是<code>RUNTIME</code>，所以，务必要加上<code>@Retention(RetentionPolicy.RUNTIME)</code>这个元注解.</p>
<h4 id="处理注解"><a href="#处理注解" class="headerlink" title="处理注解"></a>处理注解</h4><p>Java的注解本身对代码逻辑没有任何影响。根据<code>@Retention</code>的配置：</p>
<ul>
<li><code>SOURCE</code>类型的注解在编译期就被丢掉了；</li>
<li><code>CLASS</code>类型的注解仅保存在class文件中，它们不会被加载进JVM；</li>
<li><code>RUNTIME</code>类型的注解会被加载进JVM，并且在运行期可以被程序读取。</li>
</ul>
<p>如何使用注解完全由工具决定。<code>SOURCE</code>类型的注解主要由编译器使用，因此我们一般只使用，不编写。<code>CLASS</code>类型的注解主要由底层工具库使用，涉及到class的加载，一般我们很少用到。只有<code>RUNTIME</code>类型的注解不但要使用，还经常需要编写。</p>
<p>​    因为注解定义后也是一种<code>class</code>，所有的注解都继承自<code>java.lang.annotation.Annotation</code>，因此，读取注解，需要使用反射API。</p>
<p>Java提供的使用反射API读取<code>Annotation</code>的方法包括。</p>
<p>判断某个注解是否存在于<code>Class</code>、<code>Field</code>、<code>Method</code>或<code>Constructor</code>：</p>
<ul>
<li><p><code>Class.isAnnotationPresent(Class)</code></p>
</li>
<li><p><code>Field.isAnnotationPresent(Class)</code></p>
</li>
<li><p><code>Method.isAnnotationPresent(Class)</code></p>
</li>
<li><p><code>Constructor.isAnnotationPresent(Class)</code></p>
</li>
</ul>
<p>使用反射API读取Annotation：</p>
<ul>
<li><code>Class.getAnnotation(Class)</code></li>
<li><code>Field.getAnnotation(Class)</code></li>
<li><code>Method.getAnnotation(Class)</code></li>
<li><code>Constructor.getAnnotation(Class)</code></li>
</ul>
<h4 id="简单的路由设计"><a href="#简单的路由设计" class="headerlink" title="简单的路由设计"></a>简单的路由设计</h4><p>第一步编写路由注解：上边的pathMap,用来在controller里使用。</p>
<p>第二步编写使用注解的controller：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package route;</span><br><span class="line">&#x2F;&#x2F;使用注解定义路径</span><br><span class="line">@pathMap(uri &#x3D; &quot;&#x2F;test&quot;)</span><br><span class="line">public class Controller &#123;</span><br><span class="line">    @pathMap(uri &#x3D; &quot;hello&quot;)</span><br><span class="line">    public void hello()</span><br><span class="line">    &#123;</span><br><span class="line">        System.out.println(&quot;hello&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>第三步由于需要使用反射，或者自动加载某些controller类，所以需要扩展一个自己的自动加载类,用来加载controller类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> route;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">loadClass</span> <span class="keyword">extends</span> <span class="title">ClassLoader</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;String&gt; filePathArr;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">loadClass</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePathArr = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> loadClass <span class="title">addFilePath</span><span class="params">(String filePath)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePathArr.add(filePath);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Class.forName(className)方法，内部实际调用的方法是  Class.forName(className,true,classloader);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第2个boolean参数表示类是否需要初始化，  Class.forName(className)默认是需要初始化。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 一旦初始化，就会触发目标对象的 static块代码执行，static参数也也会被再次初始化。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * ClassLoader.loadClass(className)方法，内部实际调用的方法是  ClassLoader.loadClass(className,false);</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 第2个 boolean参数，表示目标对象是否进行链接，false表示不进行链接，由上面介绍可以，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 不进行链接意味着不进行包括初始化等一些列步骤，那么静态块和静态对象就不会得到执行</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fileName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; findClass(String fileName) <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] data = <span class="keyword">this</span>.loadByte(fileName);</span><br><span class="line">            <span class="keyword">return</span> defineClass(fileName, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception</span><br><span class="line">    &#123;</span><br><span class="line">        name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] data;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> len = fis.available();</span><br><span class="line">        data = <span class="keyword">new</span> <span class="keyword">byte</span>[len];</span><br><span class="line">        fis.read(data);</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第四步：编写路由类,加载和解析使用注解的controller</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;处理注解的route类</span><br><span class="line">package route;</span><br><span class="line"></span><br><span class="line">import java.lang.annotation.Annotation;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">public class route &#123;</span><br><span class="line"></span><br><span class="line">    private HashMap&lt;String,Object&gt; controllers &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    private HashMap&lt;String,Action&gt; action &#x3D; new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    protected class Action</span><br><span class="line">    &#123;</span><br><span class="line">        private Object object;</span><br><span class="line"></span><br><span class="line">        private Method method;</span><br><span class="line"></span><br><span class="line">        public Action(Object object,Method method) &#123;</span><br><span class="line">            this.method &#x3D; method;</span><br><span class="line">            this.object &#x3D; object;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public Object call() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                method.invoke(object);</span><br><span class="line">            &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(String classPath) throws Exception</span><br><span class="line">    &#123;</span><br><span class="line">        Class&lt;?&gt;  cls &#x3D; (new loadClass()).addFilePath(&quot;.&#x2F;&quot;).loadClass(classPath);</span><br><span class="line">        &#x2F;&#x2F; 反射class中所有方法</span><br><span class="line">        Method[] methods &#x3D; cls.getDeclaredMethods();</span><br><span class="line">        Annotation[] annotations;</span><br><span class="line">        String rootPath &#x3D; &quot;&quot;;</span><br><span class="line">      &#x2F;&#x2F;获取类的注解</span><br><span class="line">        annotations &#x3D; cls.getAnnotations();</span><br><span class="line">        for (Annotation annotation : annotations) &#123;</span><br><span class="line">            &#x2F;&#x2F; 如果注解类型是RouteMapping, 解析其URI</span><br><span class="line">            if (annotation.annotationType() &#x3D;&#x3D; pathMap.class) &#123;</span><br><span class="line">                pathMap anno &#x3D; (pathMap) annotation;</span><br><span class="line">                &#x2F;&#x2F; 路由uri</span><br><span class="line">                rootPath &#x3D; anno.uri();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        String startWith,endWith;</span><br><span class="line">        if(!rootPath.startsWith(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            rootPath &#x3D; &quot;&#x2F;&quot; + rootPath;</span><br><span class="line">        &#125;</span><br><span class="line">        if(!rootPath.endsWith(&quot;&#x2F;&quot;)) &#123;</span><br><span class="line">            rootPath &#x3D; rootPath + &quot;&#x2F;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">				&#x2F;&#x2F;遍历方法的所有注解</span><br><span class="line">        for (Method method : methods) &#123;</span><br><span class="line">            &#x2F;&#x2F; 反射方法所有注解</span><br><span class="line">            annotations &#x3D; method.getAnnotations();</span><br><span class="line">            for (Annotation annotation : annotations) &#123;</span><br><span class="line">                &#x2F;&#x2F; 如果注解类型是RouteMapping, 解析其URI</span><br><span class="line">                if (annotation.annotationType() &#x3D;&#x3D; pathMap.class) &#123;</span><br><span class="line">                    pathMap anno &#x3D; (pathMap)annotation;</span><br><span class="line">                    &#x2F;&#x2F; 路由uri</span><br><span class="line">                    String uri &#x3D; anno.uri();</span><br><span class="line">                    &#x2F;&#x2F; 保存Bean单例</span><br><span class="line">                    if (!controllers.containsKey(cls.getName())) &#123;</span><br><span class="line">                        controllers.put(cls.getName(), cls.newInstance());</span><br><span class="line">                    &#125;</span><br><span class="line">                    &#x2F;&#x2F; 保存uri -&gt; (obj,method)</span><br><span class="line">                    System.out.println(rootPath + uri);</span><br><span class="line">                    action.put(rootPath + uri, new Action(controllers.get(cls.getName()), method));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test(String urlPath) &#123;</span><br><span class="line">        Action ac &#x3D; action.get(urlPath);</span><br><span class="line">        if (ac !&#x3D; null) &#123;</span><br><span class="line">            ac.call();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            System.out.println(urlPath + &quot; is not found&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] argv) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            route r &#x3D; new route();</span><br><span class="line">            r.add(&quot;route.Controller&quot;);</span><br><span class="line">            r.test(&quot;&#x2F;test&#x2F;hello&quot;);</span><br><span class="line">        &#125;catch (Exception e) &#123;</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>linux-常用命令总结</title>
    <url>/2019/07/28/linux-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>命令帮助</p>
<p>   whatis command 查看命令的作用</p>
<p>   info command 查看命令的详情</p>
<p>   man command 查看命令的怎么使用，说明文档</p>
<p>   which 查看命令二进制文件所在地方<span id="more"></span></p>
<p>文件及目录：</p>
<p>​      目录及文件的创建</p>
<p>​      mkdir:创建目录 参数 -m 设置权限，-p递归创建 -v 显示创建信息</p>
<p>​        mkdir -p /dir1/dir2</p>
<p>​     rm 删除文件或是目录</p>
<p>​        rm -rf 递归删除目录及文件。</p>
<p>​       递归删除删除某一类后缀名 find ./rm/. -name “*.txt” |xargs rm -f</p>
<p>​    mv 移动文件或者文件夹到另外一个目录下，-i 提示是否覆盖 -f强制覆盖 -v打印移动信息 </p>
<p>​      mv fileName1 fileName2 更改文件名</p>
<p>​     mv dir1 dir2 目标目录存在则移动dir1到dir2，dir2不存在更改目录命名</p>
<p>​     mv file dir将文件移动到目录下</p>
<p>   cp ：复制文件或是目录</p>
<p>   ls 显示目录下下文件 ls -al ,ls -alt</p>
<p>  cd 进入目录，pwd显示当前所在文件路径</p>
<p>  scp 拷贝远程到本机或者本机到远程</p>
<p>​     scp local/dir root@IP:/server/dir</p>
<p>  split 切割文件</p>
<p>  查找文件及目录</p>
<p>  find ./ -name 文件名</p>
<p>  查看文件内容</p>
<p>​    cat -n 显示行号</p>
<p>​    tail -f 实时跟踪文件变更</p>
<p>​    wc -l 查看文件总行数</p>
<p>​    head -10 查看文件开头十行</p>
<p>​    tail -10查看文件最后十行</p>
<p>   grep 匹配文件内容</p>
<p>   cat file | grep</p>
<p>   egrep 查找文件内容</p>
<p> 改变文件属性</p>
<p>  chown 改变文件所属用户组。chmod 改变文件读写执行权限</p>
<p>链接</p>
<p>  ln -s fiel newfile 建立软连接【软连接保存了指向目标文件的路径信息】  </p>
<p> ln cc ccAgain :硬连接；删除一个，将仍能找到；</p>
<p>一些特殊符号</p>
<p> | 管道符号，用于把一个命令的输出的内容传递另外一个命令里 find . -name “*.txt” |xargs rm -f</p>
<p> &gt; ,&gt;&gt; 重定向符号</p>
<p> df,du磁盘相关：du -sh  -h是人性化显示 s是递归整个目录的大小</p>
<p>网络攻击：</p>
<p>​    netstat:查看网络端口和服务</p>
<p>​         </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -a     #列出所有端口netstat -at    #列出所有tcp端口</span><br><span class="line">netstat -au    #列出所有udp端口    </span><br><span class="line">netstat -l        #只显示监听端口</span><br><span class="line">netstat -lt       #只列出所有监听 tcp 端口</span><br><span class="line">netstat -lu       #只列出所有监听 udp 端口netstat -lx       #只列出所有监听 UNIX 端口    netstat -antp | grep 6379 查找某一个端口netstat -an | grep &#39;:80&#39;netstat -anp|grep 8081 | grep LISTEN|awk &#39;&#123;printf $7&#125;&#39;|cut -d&#x2F; -f1 通过端口找进程IDnetstat -ntu | grep :80 | awk &#39;&#123;print $5&#125;&#39; | cut -d: -f1 | awk &#39;&#123;++ip[$1]&#125; END &#123;for(i in ip) print ip[i],&quot;\t&quot;,i&#125;&#39; | sort -nr 查看连接某服务端口最多的的IP地址：netstat -anpo | grep &quot;php-cgi&quot; | wc -l 查看phpcgi进程数，如果接近预设值，说明不够用，需要增加                     </span><br></pre></td></tr></table></figure>



<p>​    route 查看路由状态</p>
<p>   ping 发送ping报</p>
<p>   traceroute IP 探测前往地址IP的路由路径</p>
<p>性能监控：</p>
<p>   top ,htop</p>
<p>   sar -u 查看CPU利用率</p>
<p>   free -m 查看内存使用情况</p>
<p> 进程相关：</p>
<p>   ps:查找进程的命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">linux上进程有5种状态: 1. 运行(正在运行或在运行队列中等待) 2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) ps工具标识进程的5种状态码: D 不可中断 uninterruptible sleep (usually IO) R 运行 runnable (on run queue) S 中断 sleeping T 停止 traced or stopped Z 僵死 a defunct (”zombie”) process 1．命令格式：ps[参数]2．命令功能：用来显示当前进程的状态3．命令参数：a  显示所有进程-a 显示同一终端下的所有程序-A 显示所有进程c  显示进程的真实名称-N 反向选择-e 等于“-A”e  显示环境变量f  显示程序间的关系-H 显示树状结构r  显示当前终端的进程T  显示当前终端的所有程序u  指定用户的所有进程-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程 -C&lt;命令&gt; 列出指定命令的状况--lines&lt;行数&gt; 每页显示的行数--width&lt;字符数&gt; 每页显示的字符数--help 显示帮助信息--version 显示版本显示例子： ps auxps -ef ps -fe| grep colin115|grep HOST |awk &#39;&#123;print $2&#125;&#39; | xargs kill -9; &#x2F;&#x2F;将用户colin115下所有进程名中包含HOST的进程终止: </span><br></pre></td></tr></table></figure>

<p>使用命令pmap 进程ID，来输出进程内存的状况，可以用来分析线程堆栈；</p>
<p>kill pid 杀死进程，kill -9 pid杀死相关进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令参数：</span><br><span class="line"></span><br><span class="line">-l  信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line"></span><br><span class="line">-a  当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line"></span><br><span class="line">-p  指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line"></span><br><span class="line">-s  指定发送信号</span><br><span class="line"></span><br><span class="line">-u  指定用户注意：1、kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)，这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。也可以用kill向进程发送特定的信号。例如：kill -2 123它的效果等同于在前台运行PID为123的进程时按下Ctrl+C键。但是，普通用户只能使用不带signal参数的kill命令或最多使用-9信号。2、kill可以带有进程ID号作为参数。当用kill向这些进程发送信号时，必须是这些进程的主人。如果试图撤销一个没有权限撤销的进程或撤销一个不存在的进程，就会得到一个错误信息。3、可以向多个进程发信号或终止它们。4、当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。5、应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。说明：</span><br><span class="line"></span><br><span class="line">只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。	下面是常用的信号：</span><br><span class="line"></span><br><span class="line">HUP    1    终端断线</span><br><span class="line"></span><br><span class="line">INT     2    中断（同 Ctrl + C）</span><br><span class="line"></span><br><span class="line">QUIT    3    退出（同 Ctrl + \）</span><br><span class="line"></span><br><span class="line">TERM   15    终止</span><br><span class="line"></span><br><span class="line">KILL    9    强制终止</span><br><span class="line"></span><br><span class="line">CONT   18    继续（与STOP相反， fg&#x2F;bg命令）</span><br><span class="line"></span><br><span class="line">STOP    19    暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure>



<p>文本处理：</p>
<p>   sed:命令处理文本内容</p>
<p>   tr:将字符进行替换压缩和删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-c或——complerment：取代所有不属于第一字符集的字符；-d或——delete：删除所有属于第一字符集的字符；</span><br><span class="line">-s或--squeeze-repeats：把连续重复的字符以单独一个字符表示；</span><br><span class="line">-t或--truncate-set1：先删除第一字符集较第二字符集多出的字符。</span><br><span class="line">例子：</span><br><span class="line">    echo &quot;HELLO WORLD&quot; | tr &#39;A-Z&#39; &#39;a-z&#39; 将输入字符由大写转换为小写：hello world    echo &quot;hello 123 world 456&quot; | tr -d &#39;0-9&#39; 使用tr删除字符：hello world    echo &quot;thissss is      a text linnnnnnne.&quot; | tr -s &#39; sn&#39; 用tr压缩字符，可以压缩输入中重复的字符：this is a text line.</span><br></pre></td></tr></table></figure>

<p>​    grep :文本搜索工具：是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p>
<p>​            选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> --text  # 不要忽略二进制数据。-A &lt;显示行数&gt;   --after-context&#x3D;&lt;显示行数&gt;   # 除了显示符合范本样式的那一行之外，并显示该行之后的内容。</span><br><span class="line">-b --byte-offset                           # 在显示符合范本样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-B&lt;显示行数&gt;   --before-context&#x3D;&lt;显示行数&gt;   # 除了显示符合样式的那一行之外，并显示该行之前的内容。</span><br><span class="line">-c --count    # 计算符合范本样式的列数。</span><br><span class="line">-C&lt;显示行数&gt; --context&#x3D;&lt;显示行数&gt;或-&lt;显示行数&gt; # 除了显示符合范本样式的那一列之外，并显示该列之前后的内容。</span><br><span class="line">-d&lt;进行动作&gt; --directories&#x3D;&lt;动作&gt;  # 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep命令将回报信息并停止动作。</span><br><span class="line">-e&lt;范本样式&gt; --regexp&#x3D;&lt;范本样式&gt;   # 指定字符串作为查找文件内容的范本样式。</span><br><span class="line">-E --extended-regexp             # 将范本样式为延伸的普通表示法来使用，意味着使用能使用扩展正则表达式。</span><br><span class="line">-f&lt;范本文件&gt; --file&#x3D;&lt;规则文件&gt;     # 指定范本文件，其内容有一个或多个范本样式，让grep查找符合范本条件的文件内容，格式为每一列的范本样式。</span><br><span class="line">-F --fixed-regexp   # 将范本样式视为固定字符串的列表。</span><br><span class="line">-G --basic-regexp   # 将范本样式视为普通的表示法来使用。</span><br><span class="line">-h --no-filename    # 在显示符合范本样式的那一列之前，不标示该列所属的文件名称。</span><br><span class="line">-H --with-filename  # 在显示符合范本样式的那一列之前，标示该列的文件名称。</span><br><span class="line">-i --ignore-case    # 忽略字符大小写的差别。</span><br><span class="line">-l --file-with-matches   # 列出文件内容符合指定的范本样式的文件名称。</span><br><span class="line">-L --files-without-match # 列出文件内容不符合指定的范本样式的文件名称。</span><br><span class="line">-n --line-number         # 在显示符合范本样式的那一列之前，标示出该列的编号。</span><br><span class="line">-q --quiet或--silent     # 不显示任何信息。</span><br><span class="line">-R&#x2F;-r  --recursive       # 此参数的效果和指定“-d recurse”参数相同。</span><br><span class="line">-s --no-messages  # 不显示错误信息。</span><br><span class="line">-v --revert-match # 反转查找。</span><br><span class="line">-V --version      # 显示版本信息。   </span><br><span class="line">-w --word-regexp  # 只显示全字符合的列。</span><br><span class="line">-x --line-regexp  # 只显示全列符合的列。</span><br><span class="line">-y # 此参数效果跟“-i”相同。</span><br><span class="line">-o # 只输出文件中匹配到的部分。</span><br><span class="line">-m &lt;num&gt; --max-count&#x3D;&lt;num&gt; # 找到num行结果后停止查找，用来限制匹配行数</span><br></pre></td></tr></table></figure>

<h3 id="规则表达式"><a href="#规则表达式" class="headerlink" title="规则表达式"></a>规则表达式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">^    # 锚定行的开始 如：&#39;^grep&#39;匹配所有以grep开头的行。    </span><br><span class="line">$    # 锚定行的结束 如：&#39;grep$&#39; 匹配所有以grep结尾的行。</span><br><span class="line">.    # 匹配一个非换行符的字符 如：&#39;gr.p&#39;匹配gr后接一个任意字符，然后是p。    </span><br><span class="line">*    # 匹配零个或多个先前字符 如：&#39;*grep&#39;匹配所有一个或多个空格后紧跟grep的行。    </span><br><span class="line">.*   # 一起用代表任意字符。   </span><br><span class="line">[]   # 匹配一个指定范围内的字符，如&#39;[Gg]rep&#39;匹配Grep和grep。    </span><br><span class="line">[^]  # 匹配一个不在指定范围内的字符，如：&#39;[^A-FH-Z]rep&#39;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span><br><span class="line">\(..\)  # 标记匹配字符，如&#39;\(love\)&#39;，love被标记为1。    </span><br><span class="line">\&lt;      # 锚定单词的开始，如:&#39;\&lt;grep&#39;匹配包含以grep开头的单词的行。    </span><br><span class="line">\&gt;      # 锚定单词的结束，如&#39;grep\&gt;&#39;匹配包含以grep结尾的单词的行。    </span><br><span class="line">x\&#123;m\&#125;  # 重复字符x，m次，如：&#39;0\&#123;5\&#125;&#39;匹配包含5个o的行。    </span><br><span class="line">x\&#123;m,\&#125;   # 重复字符x,至少m次，如：&#39;o\&#123;5,\&#125;&#39;匹配至少有5个o的行。    </span><br><span class="line">x\&#123;m,n\&#125;  # 重复字符x，至少m次，不多于n次，如：&#39;o\&#123;5,10\&#125;&#39;匹配5--10个o的行。   </span><br><span class="line">\w    # 匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#39;G\w*p&#39;匹配以G后跟零个或多个文字或数字字符，然后是p。   </span><br><span class="line">\W    # \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span><br><span class="line">\b    # 单词锁定符，如: &#39;\bgrep\b&#39;只匹配grep。  </span><br></pre></td></tr></table></figure>

<p> 常见用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在文件中搜索一个单词，命令会返回一个包含 “match_pattern” 的文本行：grep &quot;match_pattern&quot; file_name</span><br><span class="line">输出除之外的所有行 -v 选项grep -v &quot;match_pattern&quot; file_name使用正则表达式 -E 选项：</span><br><span class="line">grep -E &quot;[1-9]+&quot;</span><br><span class="line">只输出文件中匹配到的部分 -o 选项：</span><br><span class="line">echo this is a test line. | grep -o -E &quot;[a-z]+\.&quot; 输出:line.</span><br><span class="line">搜索多个文件并查找匹配文本在哪些文件中：</span><br><span class="line">    grep -l &quot;text&quot; file1 file2 file3...在多级目录中对文本进行递归搜索：</span><br><span class="line">grep &quot;text&quot; . -r -n</span><br><span class="line"># .表示当前目录。</span><br></pre></td></tr></table></figure>

<p>xargs：是给其他命令传递参数的一个过滤器，也是组合多个命令的一个工具。它擅长将标准输入数据转换成命令行参数，xargs 能够处理管道或者 stdin 并将其转换成特定命令的命令参数。xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。xargs 的默认命令是 echo，空格是默认定界符。这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。xargs 是构建单行命令的重要组件之一。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用作替换工具，读取输入数据重新格式化后输出。cat test.txt | xargs</span><br><span class="line">a b c d e f g h i j k l m n o p q r s t u v w x y z</span><br><span class="line">使用 -n 进行多行输出cat test.txt | xargs -n3</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j k l</span><br><span class="line">m n o</span><br><span class="line">p q r</span><br><span class="line">s t u</span><br><span class="line">v w x</span><br><span class="line">y z</span><br><span class="line">使用 -d 分割输入echo &quot;nameXnameXnameXname&quot; | xargs -dX</span><br><span class="line">name name name name</span><br><span class="line">结合 -I 选项xargs 的一个 选项 -I ，使用 -I 指定一个替换字符串&#123;&#125;，这个字符串在 xargs 扩展时会被替换掉，当 -I 与 xargs 结合使用，每一个参数命令都会被执行一次：复制所有图片文件到 &#x2F;data&#x2F;images 目录下：</span><br><span class="line">ls *.jpg | xargs -n1 -I cp &#123;&#125; &#x2F;data&#x2F;images</span><br><span class="line">xargs 结合 find 使用用 rm 删除太多的文件时候，可能得到一个错误信息：&#x2F;bin&#x2F;rm Argument list too long. 用 xargs去避免这个问题：find . -type f -name &quot;*.log&quot; -print0 | xargs -0 rm -f</span><br><span class="line">使用 -p 选项确认执行的命令-p选项会在执行每一个命令时弹出确认，当你需要非常准确的确认每一次操作时可以使用 -p 参数，比如，查找当前目录下 .log 文件，每一次删除都需要确认：find . -maxdepth 1 -name &quot;*.log&quot; | xargs -p -I&#123;&#125; rm &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>awk:命令</p>
<p>是一种编程语言，用于在linux/unix下对文本和数据进行处理。数据可以来自标准输入(stdin)、一个或多个文件，或其它命令的输出。它支持用户自定义函数和动态正则表达式等先进功能，是linux/unix下的一个强大编程工具。它在命令行中使用，但更多是作为脚本来使用。awk有很多内建的功能，比如数组、函数等，这是它和C语言的相同之处，灵活性是awk最大的优势。</p>
<p><strong>常用命令选项</strong></p>
<ul>
<li><strong>-F fs</strong> fs指定输入分隔符，fs可以是字符串或正则表达式，如-F:</li>
<li><strong>-v var=value</strong> 赋值一个用户定义变量，将外部变量传递给awk</li>
<li><strong>-f scripfile</strong> 从脚本文件中读取awk命令</li>
<li><strong>-m[fr] val</strong> 对val值设置内在限制，-mf选项限制分配给val的最大块数目；-mr选项限制记录的最大数目。这两个功能是Bell实验室版awk的扩展功能，在标准awk中不适用。</li>
</ul>
<h2 id="awk模式和操作"><a href="#awk模式和操作" class="headerlink" title="awk模式和操作"></a>awk模式和操作</h2><p>awk脚本是由模式和操作组成的。</p>
<h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式可以是以下任意一个：</p>
<ul>
<li>/正则表达式/：使用通配符的扩展集。</li>
<li>关系表达式：使用运算符进行操作，可以是字符串或数字的比较测试。</li>
<li>模式匹配表达式：用运算符<code>~</code>（匹配）和<code>!~</code>（不匹配）。</li>
<li>BEGIN语句块、pattern语句块、END语句块：参见awk的工作原理</li>
</ul>
<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><p>操作由一个或多个命令、函数、表达式组成，之间由换行符或分号隔开，并位于大括号内，主要部分是：</p>
<ul>
<li><p>变量或数组赋值</p>
</li>
<li><p>输出命令</p>
</li>
<li><p>内置函数</p>
</li>
<li><p>控制流语句</p>
</li>
<li><h3 id=""><a href="#" class="headerlink" title=""></a></h3></li>
<li><h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3></li>
<li><h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3></li>
<li><h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3></li>
<li><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3></li>
<li><h2 id="awk脚本基本结构"><a href="#awk脚本基本结构" class="headerlink" title="awk脚本基本结构"></a>awk脚本基本结构</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN&#123; print &quot;start&quot; &#125; pattern&#123; commands &#125; END&#123; print &quot;end&quot; &#125;&#39; file</span><br></pre></td></tr></table></figure>

<p>一个awk脚本通常由：BEGIN语句块、能够使用模式匹配的通用语句块、END语句块3部分组成，这三个部分是可选的。任意一个部分都可以不出现在脚本中，脚本通常是被 <strong>单引号</strong> 或 <strong>双引号</strong> 中，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN&#123; i&#x3D;0 &#125; &#123; i++ &#125; END&#123; print i &#125;&#39; filename</span><br><span class="line">awk &quot;BEGIN&#123; i&#x3D;0 &#125; &#123; i++ &#125; END&#123; print i &#125;&quot; filename</span><br></pre></td></tr></table></figure>

<h3 id="awk的工作原理"><a href="#awk的工作原理" class="headerlink" title="awk的工作原理"></a>awk的工作原理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk &#39;BEGIN&#123; commands &#125; pattern&#123; commands &#125; END&#123; commands &#125;&#39;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>第一步：执行<code>BEGIN&#123; commands &#125;</code>语句块中的语句；</p>
</li>
<li><p>第二步：从文件或标准输入(stdin)读取一行，然后执行<code>pattern&#123; commands &#125;</code>语句块，它逐行扫描文件，从第一行到最后一行重复这个过程，直到文件全部被读取完毕。</p>
</li>
<li><p>第三步：当读至输入流末尾时，执行<code>END&#123; commands &#125;</code>语句块。</p>
<p><strong>BEGIN语句块</strong> 在awk开始从输入流中读取行 <strong>之前</strong> 被执行，这是一个可选的语句块，比如变量初始化、打印输出表格的表头等语句通常可以写在BEGIN语句块中。</p>
<p><strong>END语句块</strong> 在awk从输入流中读取完所有的行 <strong>之后</strong> 即被执行，比如打印所有行的分析结果这类信息汇总都是在END语句块中完成，它也是一个可选语句块。</p>
<p><strong>pattern语句块</strong> 中的通用命令是最重要的部分，它也是可选的。如果没有提供pattern语句块，则默认执行<code>&#123; print &#125;</code>，即打印每一个读取到的行，awk读取的每一行都会执行该语句块。</p>
<p><strong>示例</strong></p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo -e &quot;A line 1\nA line 2&quot; | awk &#39;BEGIN&#123; print &quot;Start&quot; &#125; &#123; print &#125; END&#123; print &quot;End&quot; &#125;&#39;</span><br><span class="line">Start</span><br><span class="line">A line 1</span><br><span class="line">A line 2</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>当使用不带参数的<code>print</code>时，它就打印当前行，当<code>print</code>的参数是以逗号进行分隔时，打印时则以空格作为定界符。在awk的print语句块中双引号是被当作拼接符使用，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo | awk &#39;&#123; var1&#x3D;&quot;v1&quot;; var2&#x3D;&quot;v2&quot;; var3&#x3D;&quot;v3&quot;; print var1,var2,var3; &#125;&#39; </span><br><span class="line">v1 v2 v3</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="特殊变量：-NR-NF-0-1-2"><a href="#特殊变量：-NR-NF-0-1-2" class="headerlink" title="特殊变量： NR NF $0 $1 $2"></a><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/base/03_text_processing.html#id34">特殊变量： NR NF $0 $1 $2</a></h3><p>NR:表示记录数量，在执行过程中对应当前行号；</p>
<p>NF:表示字段数量，在执行过程总对应当前行的字段数；</p>
<p>$0:这个变量包含执行过程中当前行的文本内容；</p>
<p>$1:第一个字段的文本内容；</p>
<p>$2:第二个字段的文本内容；</p>
<p>使用-F来设置定界符（默认为空格）:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">awk -F: &#39;&#123;print $NF&#125;&#39; &#x2F;etc&#x2F;passwd</span><br><span class="line">查找指定进程并输出进程IDps aux | grep java|awk &#39;&#123;print $2&#125;&#39;|xargs echo</span><br></pre></td></tr></table></figure>

<p><strong>uniq:消除重复行</strong></p>
<p><strong>sort：排序</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sort unsort.txt | uniq -c 统计各行在文件中出现的次数</span><br></pre></td></tr></table></figure>

<p><strong>wc 统计行和字符的工具</strong></p>
<p><strong>cut:按列分割文本</strong></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql锁</title>
    <url>/2021/04/20/mysql%E9%94%81/</url>
    <content><![CDATA[<p>锁的作用<br>​     锁是为了控制对共享资源的并发访问和操作。数据库系统使用锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性。<br>两种锁的概念：</p>
<ul>
<li><p>Latch:闩锁，这是一种轻量级锁，用于线程中的临界资源的操作【例如，操作缓冲池中的LRU列表，删除、添加、移动LRU列表中的元素，为了保证一致性，必须有锁的介入】。锁定的时间非常短，而且没有死锁检测机制。</p>
</li>
<li><p>lock:用于数据事务的锁，并且在一般在commit和rollback后释放。有死锁检测机制。</p>
<span id="more"></span>
<p>锁的类型<br>​       表锁：myisam 锁<br>​       共享锁：允许事物读取一行数据【S锁】<br>​       排它锁：允许事物更新或是删除一条数据【X锁】<br>myIsam对于并发操作处理方式:<br>​    MySQL对于删除和插入的处理，对于删除操作，myisam只是标记这行被删除，并没有真正的去作删除处理。在插入的时候回看看有没有标记的删除的行【成为空洞】，如果有会填补这些空洞，没有会插入到行末尾。<br>   尽管myisam是表锁，但是也指出并发的读，并发插入的操作，读只能读取到当前的数据，新插入的数据是看不见的，这避免了非一致读问题。但是中间有些数据改动的话还是不支持非一致读。<br>   通过设置concurrent_insert这个人值，可以改变myisam的插入并发的控制。</p>
<ul>
<li><p>0：MySQL不支持并发插入，所有插入都会设置互斥锁。</p>
</li>
<li><p>1：默认值，如果没有空洞就指出并发插入。</p>
</li>
<li><p>2：所有的并发插入都设置在表尾部。</p>
</li>
</ul>
</li>
</ul>
<p>Innodb:</p>
<ul>
<li>共享锁【S锁】<br>对于共享锁，支持对于一行加了S锁，可以在加s锁，但是不支持加X锁。</li>
<li>排它锁【X锁】<br>对于排它锁，加了排它锁的行，不支持在加任何其他锁</li>
</ul>
<p>​    </p>
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>php数组的实现</title>
    <url>/2020/04/20/php%E6%95%B0%E7%BB%84%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>PHP 数组的底层实现是散列表（也叫 hashTable )，散列表是根据键（Key）直接访问内存存储位置的数据结构，它的 key - value 之间存在一个映射函数，可以根据 key 通过映射函数得到的散列值直接索引到对应的 value 值，无需通过关键字比较，在理想情况下，不考虑散列冲突，散列表的查找效率是非常高的，时间复杂度是 O (1)。<span id="more"></span></p>
<p>我们先了解几个基础概念.</p>
<p>​        散列：是一种用常数平均时间执行查找，删除，添加的技术。通常是把输入的字符换算成一个固定数字或是字符串返回。也就是同一个字符串无论输入几次计算散列（hash）值，在条件不变的情况，都是同一个输出值。</p>
<p>一个常见的散列函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hash(<span class="keyword">char</span> *str,<span class="keyword">int</span> tableSize)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hashVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">        hashVal = (hashVal &lt;&lt; <span class="number">5</span>) + *str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hashVal % tableSize</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* time33算法</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> time33(<span class="keyword">char</span> *str)&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> hash = <span class="number">5381</span>;</span><br><span class="line">    <span class="keyword">while</span>(*str != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">        hash += (hash &lt;&lt; <span class="number">5</span> ) + (*str++);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (hash &amp; <span class="number">0x7FFFFFFF</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">PHP7 数组hash值得算法</span></span><br><span class="line"><span class="comment"> * DJBX33A (Daniel J. Bernstein, Times 33 with Addition)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This is Daniel J. Bernstein&#x27;s popular `times 33&#x27; hash function as</span></span><br><span class="line"><span class="comment"> * posted by him years ago on comp.lang.c. It basically uses a function</span></span><br><span class="line"><span class="comment"> * like ``hash(i) = hash(i-1) * 33 + str[i]&#x27;&#x27;. This is one of the best</span></span><br><span class="line"><span class="comment"> * known hash functions for strings. Because it is both computed very</span></span><br><span class="line"><span class="comment"> * fast and distributes very well.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The magic of number 33, i.e. why it works better than many other</span></span><br><span class="line"><span class="comment"> * constants, prime or not, has never been adequately explained by</span></span><br><span class="line"><span class="comment"> * anyone. So I try an explanation: if one experimentally tests all</span></span><br><span class="line"><span class="comment"> * multipliers between 1 and 256 (as RSE did now) one detects that even</span></span><br><span class="line"><span class="comment"> * numbers are not useable at all. The remaining 128 odd numbers</span></span><br><span class="line"><span class="comment"> * (except for the number 1) work more or less all equally well. They</span></span><br><span class="line"><span class="comment"> * all distribute in an acceptable way and this way fill a hash table</span></span><br><span class="line"><span class="comment"> * with an average percent of approx. 86%.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If one compares the Chi^2 values of the variants, the number 33 not</span></span><br><span class="line"><span class="comment"> * even has the best value. But the number 33 and a few other equally</span></span><br><span class="line"><span class="comment"> * good numbers like 17, 31, 63, 127 and 129 have nevertheless a great</span></span><br><span class="line"><span class="comment"> * advantage to the remaining numbers in the large set of possible</span></span><br><span class="line"><span class="comment"> * multipliers: their multiply operation can be replaced by a faster</span></span><br><span class="line"><span class="comment"> * operation based on just one shift plus either a single addition</span></span><br><span class="line"><span class="comment"> * or subtraction operation. And because a hash function has to both</span></span><br><span class="line"><span class="comment"> * distribute good _and_ has to be very fast to compute, those few</span></span><br><span class="line"><span class="comment"> * numbers should be preferred and seems to be the reason why Daniel J.</span></span><br><span class="line"><span class="comment"> * Bernstein also preferred it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *                  -- Ralf S. Engelschall &lt;rse@engelschall.com&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> zend_always_inline zend_ulong <span class="title">zend_inline_hash_func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    zend_ulong hash = Z_UL(<span class="number">5381</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* variant with the hash unrolled eight times */</span></span><br><span class="line">    <span class="keyword">for</span> (; len &gt;= <span class="number">8</span>; len -= <span class="number">8</span>) &#123;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">        hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (len) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="comment">/* fallthrough... */</span></span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: hash = ((hash &lt;&lt; <span class="number">5</span>) + hash) + *str++; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">break</span>;</span><br><span class="line">EMPTY_SWITCH_DEFAULT_CASE()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Hash value can&#x27;t be zero, so we always set the high bit */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SIZEOF_ZEND_LONG == 8</span></span><br><span class="line">    <span class="keyword">return</span> hash | Z_UL(<span class="number">0x8000000000000000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> SIZEOF_ZEND_LONG == 4</span></span><br><span class="line">    <span class="keyword">return</span> hash | Z_UL(<span class="number">0x80000000</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">error</span> <span class="meta-string">&quot;Unknown SIZEOF_ZEND_LONG&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​          </p>
<p>2：虽然散列能实现快速的定位到元素在数组中的位置，但是不同的字符串通过散列计算有可能会得到同一个散列值。这叫做hash冲突，常见的解决hash冲突的是拉链法，或者叫做列表法，也是在同一个数组的位置上存储了一个链表。这也是PHP的解决方法。</p>
<p>3：PHP5的数组实现：</p>
<p>​      查找关键字时，PHP将计算哈希值，然后遍历“可能”值的链接列表，直到找到匹配的条目。</p>
<p>这是链接冲突解决的说明：</p>
<p>​    <img src="/images/youdao/6207.png" alt="0"></p>
<p>此外，PHP哈希表是<em>有序的</em>：如果遍历数组，您将以插入元素的顺序获得元素。为此，存储桶必须是另一个指定顺序的链表的一部分。由于与上述相同的原因（并且支持反向顺序遍历），这再次是一个双链表。前向指针存储在中pListNext，后向指针存储在中pListLast。另外，哈希表结构具有指向列表开头（pListHead）和列表结尾（）的指针pListLast。下面是这个链表可能看起来怎么样的元素的例子”a”，”b”，”c”（按顺序）：</p>
<p>​    <img src="/images/youdao/6211.png" alt="0"></p>
<p>4：php7数组的实现：</p>
<p>​    PHP7对数组底层实现进行了优化，使得元素的插入顺序和数据的存储顺序保存了一致。</p>
<p>1：下图对PHP数组结构做了接单的梳理</p>
<p>​    <img src="/images/youdao/6222.png" alt="0"></p>
<p>2：PHP有序性的实现方式</p>
<p>为了实现 PHP 数组的有序性，PHP 底层的散列表在散列函数与元素数组之间加了一层映射表，这个映射表也是一个数组，大小和存储元素的数组相同，存储元素的类型为整型，用于保存元素在实际存储的有序数组中的下标 —— 元素按照先后顺序依次插入实际存储数组，然后将其数组下标按照散列函数散列出来的位置存储在新加的映射表中：</p>
<p>​    <img src="/images/youdao/6231.png" alt="0"></p>
<p>这样，就可以完成最终存储数据的有序性了。</p>
<p>PHP 数组底层结构中并没有显式标识这个中间映射表，而是与 arData 放到了一起，在数组初始化的时候并不仅仅分配用于存储 Bucket 的内存，还会分配相同数量的 uint32_t 大小的空间，这两块空间是一起分配的，然后将 arData 偏移到存储元素数组的位置，而这个中间映射表就可以通过 arData 向前访问到。</p>
<p>3：介绍下各个数据结构</p>
<p>HashTable 位于 Zend/zend_types.h</p>
<pre><code>            <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zend_array</span> &#123;</span></span><br><span class="line">    zend_refcounted_h gc;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    flags,</span><br><span class="line">                zend_uchar    nApplyCount,</span><br><span class="line">                zend_uchar    nIteratorsCount,</span><br><span class="line">                zend_uchar    consistency)</span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">    &#125; u;</span><br><span class="line">    <span class="comment">/* 非常有用 计算出来的hash值与此 进行 | 操作【h | ht-&gt;nTableMask】，计算出来存储映射表数组的下标位置。  */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableMask;</span><br><span class="line">    <span class="comment">/* 实际存储 数组元素的 指针开始地址*/</span></span><br><span class="line">    Bucket           *arData;</span><br><span class="line">    <span class="comment">/* 已使用数组数量，包括标记删除的，利用这个数字实现数组的有序插入*/</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumUsed;</span><br><span class="line">    <span class="comment">/* 实际有效元素数量 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nNumOfElements;</span><br><span class="line">    <span class="comment">/* 已申请的数组的总大小 */</span></span><br><span class="line">    <span class="keyword">uint32_t</span>          nTableSize;</span><br><span class="line">    <span class="keyword">uint32_t</span>          nInternalPointer;</span><br><span class="line">    zend_long         nNextFreeElement;</span><br><span class="line">    <span class="keyword">dtor_func_t</span>       pDestructor;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* Bucket：C数组实际存储的值位于 Zend/zend_types.h*/</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">Bucket</span> &#123;</span></span><br><span class="line">    <span class="comment">/* zval_struct 结构体 */</span></span><br><span class="line">    zval              val;</span><br><span class="line">    <span class="comment">/* hash值 */</span></span><br><span class="line">    zend_ulong        h;                <span class="comment">/* hash value (or numeric index)   */</span></span><br><span class="line">    <span class="comment">/* 字符串元素值，出现hash冲突时候，用来精确确认 是不是所查找的元素*/</span></span><br><span class="line">    zend_string      *key;              <span class="comment">/* string key or NULL for numerics */</span></span><br><span class="line">&#125; Bucket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*zval_struct：  Bucket的zval所指向的结构体  位于 Zend/zend_types.h</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">zval_struct</span> &#123;</span></span><br><span class="line">    <span class="comment">/* 实际值*/</span></span><br><span class="line">    zend_value        value;            <span class="comment">/* value */</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            ZEND_ENDIAN_LOHI_4(</span><br><span class="line">                zend_uchar    type,         <span class="comment">/* active type */</span></span><br><span class="line">                zend_uchar    type_flags,</span><br><span class="line">                zend_uchar    const_flags,</span><br><span class="line">                zend_uchar    reserved)     <span class="comment">/* call info for EX(This) */</span></span><br><span class="line">        &#125; v;</span><br><span class="line">        <span class="keyword">uint32_t</span> type_info;</span><br><span class="line">    &#125; u1;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="comment">/*重点 这个字段存储了，hash冲突时，他的上一个冲突的元素的数组的下标值*/</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     next;                 <span class="comment">/* hash collision chain */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     cache_slot;           <span class="comment">/* literal cache slot */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     lineno;               <span class="comment">/* line number (for ast nodes) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     num_args;             <span class="comment">/* arguments number for EX(This) */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_pos;               <span class="comment">/* foreach position */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     fe_iter_idx;          <span class="comment">/* foreach iterator index */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     access_flags;         <span class="comment">/* class constant access flags */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     property_guard;       <span class="comment">/* single property guard */</span></span><br><span class="line">        <span class="keyword">uint32_t</span>     extra;                <span class="comment">/* not further specified */</span></span><br><span class="line">    &#125; u2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>​              </p>
<p>4:PHP 数组的操作</p>
<p>添加操作： Zend/zend_hash.c ：797行左右</p>
<pre><code>           <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_to_hash:</span><br><span class="line">    <span class="comment">/* 已使用元素++*/</span></span><br><span class="line">    idx = ht-&gt;nNumUsed++;</span><br><span class="line">    <span class="comment">/* 有效元素++*/</span></span><br><span class="line">    ht-&gt;nNumOfElements++;</span><br><span class="line">    <span class="keyword">if</span> (ht-&gt;nInternalPointer == HT_INVALID_IDX) &#123;</span><br><span class="line">        ht-&gt;nInternalPointer = idx;</span><br><span class="line">    &#125;</span><br><span class="line">    zend_hash_iterators_update(ht, HT_INVALID_IDX, idx);</span><br><span class="line">    <span class="keyword">if</span> ((zend_long)h &gt;= (zend_long)ht-&gt;nNextFreeElement) &#123;</span><br><span class="line">        ht-&gt;nNextFreeElement = h &lt; ZEND_LONG_MAX ? h + <span class="number">1</span> : ZEND_LONG_MAX;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* 获取存储数组的下标地址，并且赋值*/</span></span><br><span class="line">    p = ht-&gt;arData + idx;</span><br><span class="line">    p-&gt;h = h;</span><br><span class="line">    p-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">/*计算出 与映射数组的下标值*/</span></span><br><span class="line">    nIndex = h | ht-&gt;nTableMask;</span><br><span class="line">    ZVAL_COPY_VALUE(&amp;p-&gt;val, pData);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    *PHP 数组底层的散列表采用链地址法解决哈希冲突，即将冲突的 Bucket 串成链表</span></span><br><span class="line"><span class="comment">    *下边的宏函数有四部操作</span></span><br><span class="line"><span class="comment">    * Z_NEXT(p-&gt;val) 主要是获取 zval.u2.next所指向的地址</span></span><br><span class="line"><span class="comment">    * HT_HASH(ht, nIndex) 是获取中间映射表里所存储的值，然后通过赋值语句赋值给zval.u2.next所指向的地址，用于解决hash冲突，串成链表。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    Z_NEXT(p-&gt;val) = HT_HASH(ht, nIndex);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 把最新数组下标值，存储于中间映射表中</span></span><br><span class="line"><span class="comment">     */</span> </span><br><span class="line">    HT_HASH(ht, nIndex) = HT_IDX_TO_HASH(idx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &amp;p-&gt;val;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>删除数据</p>
<p>​        关于数组数据删除前面我们在介绍散列表中的 nNumUsed 和 nNumOfElements 字段时已经提及过，从数组中删除元素时，并没有真正移除，并重新 rehash，而是当 arData 满了之后，才会移除无用的数据，从而提高性能。即数组在需要扩容的情况下才会真正删除元素：首先检查数组中已删除元素所占比例，如果比例达到阈值则触发重新构建索引的操作，这个过程会把已删除的 Bucket 移除，然后把后面的 Bucket 往前移动补上空位，如果还没有达到阈值则会分配一个原数组大小 2 倍的新数组，然后把原数组的元素复制到新数组上，最后重建索引，重建索引会将已删除的 Bucket 移除。</p>
<p>数组查找</p>
<p>​        清楚了 HashTable 的实现和哈希冲突的解决方式之后，查找的过程就比较简单了：首先根据 key 计算出的散列值与 nTableMask 计算得到最终散列值 nIndex，然后根据散列值从中间映射表中得到存储元素在有序存储数组中的位置 idx，接着根据 idx 从有序存储数组（即 arData）中取出 Bucket，遍历该 Bucket，判断 Bucket 的 key 是否是要查找的 key，如果是则终止遍历，否则继续根据 zval.u2.next 遍历比较。</p>
]]></content>
      <categories>
        <category>php</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title>skiplist</title>
    <url>/2021/04/20/skiplist/</url>
    <content><![CDATA[<p>跳跃表：是基于链表来是实现的。</p>
<p>我们可以先看看单链表的数据的结构。如下图<br><img src="/images/img/08-02/534d222a-d592-4a3b-8033-fd9d8aed0e3e.png"><br>在这样一个链表中，如果我们要查找某个数据，那么需要从头开始逐个进行比较，直到找到包含数据的那个节点，或者找到第一个比给定数据大的节点为止（没找到）。也就是说，时间复杂度为O(n)。同样，当我们要插入新数据的时候，也要经历同样的查找过程，从而确定插入位置。假如我们每相邻两个节点增加一个指针，让指针指向下下个节点，如下图：<span id="more"></span><br><img src="/images/img/08-02/debfa0a1-b863-4757-8f34-494bc3629183.png"><br>这样所有新增加的指针连成了一个新的链表，但它包含的节点个数只有原来的一半（上图中是7, 19, 26）。现在当我们想查找数据的时候，可以先沿着这个新链表进行查找。当碰到比待查数据大的节点时，再回到原来的链表中进行查找。比如，我们想查找23，查找的路径是沿着下图中标红的指针所指向的方向进行的：<br><img src="/images/img/08-02/28d09f18-8d83-4f20-ae8a-5a4fef012308.png"><br>23首先和7比较，再和19比较，比它们都大，继续向后比较。<br>但23和26比较的时候，比26要小，因此回到下面的链表（原链表），与22比较。<br>23比22要大，沿下面的指针继续向后和26比较。23比26小，说明待查数据23在原链表中不存在，而且它的插入位置应该在22和26之间。<br>在这个查找过程中，由于新增加的指针，我们不再需要与链表中每个节点逐个进行比较了。需要比较的节点数大概只有原来的一半。</p>
<p>skiplist正是受这种多层链表的想法的启发而设计出来的。实际上，按照上面生成链表的方式，上面每一层链表的节点个数，是下面一层的节点个数的一半，这样查找过程就非常类似于一个二分查找，使得查找的时间复杂度可以降低到O(log n)。但是，这种方法在插入数据的时候有很大的问题。新插入一个节点之后，就会打乱上下相邻两层链表上节点个数严格的2:1的对应关系。如果要维持这种对应关系，就必须把新插入的节点后面的所有节点（也包括新插入的节点）重新进行调整，这会让时间复杂度重新蜕化成O(n)。删除数据也有同样的问题。</p>
<p>skiplist为了避免这一问题，它不要求上下相邻两层链表之间的节点个数有严格的对应关系，而是为每个节点随机出一个层数(level)。比如，一个节点随机出的层数是3，那么就把它链入到第1层到第3层这三层链表中。为了表达清楚，下图展示了如何通过一步步的插入操作从而形成一个skiplist的过程：<br><img src="/images/img/08-02/5c861dec-955e-4c80-8cdf-79ca212e78cb.png"><br>从上面skiplist的创建和插入过程可以看出，每一个节点的层数（level）是随机出来的，而且新插入一个节点不会影响其它节点的层数。因此，插入操作只需要修改插入节点前后的指针，而不需要对很多节点都进行调整。这就降低了插入操作的复杂度。实际上，这是skiplist的一个很重要的特性，这让它在插入性能上明显优于平衡树的方案。这在后面我们还会提到。</p>
<p>根据上图中的skiplist结构，我们很容易理解这种数据结构的名字的由来。skiplist，翻译成中文，可以翻译成“跳表”或“跳跃表”，指的就是除了最下面第1层链表之外，它会产生若干层稀疏的链表，这些链表里面的指针故意跳过了一些节点（而且越高层的链表跳过的节点越多）。这就使得我们在查找数据的时候能够先在高层的链表中进行查找，然后逐层降低，最终降到第1层链表来精确地确定数据位置。在这个过程中，我们跳过了一些节点，从而也就加快了查找速度。</p>
<p>下面是使用PHP实现的跳跃表的一个例子</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 跳跃表</span></span><br><span class="line"><span class="comment"> * Head nodes          Index nodes</span></span><br><span class="line"><span class="comment"> * +-+    right        +-+                      +-+</span></span><br><span class="line"><span class="comment"> * |2|----------------&gt;| |---------------------&gt;| |-&gt;null</span></span><br><span class="line"><span class="comment"> * +-+                 +-+                      +-+</span></span><br><span class="line"><span class="comment"> *  | down              |                        |</span></span><br><span class="line"><span class="comment"> *  v                   v                        v</span></span><br><span class="line"><span class="comment"> * +-+            +-+  +-+       +-+            +-+       +-+</span></span><br><span class="line"><span class="comment"> * |1|-----------&gt;| |-&gt;| |------&gt;| |-----------&gt;| |------&gt;| |-&gt;null</span></span><br><span class="line"><span class="comment"> * +-+            +-+  +-+       +-+            +-+       +-+</span></span><br><span class="line"><span class="comment"> *  v              |    |         |              |         |</span></span><br><span class="line"><span class="comment"> * Nodes  next     v    v         v              v         v</span></span><br><span class="line"><span class="comment"> * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span></span><br><span class="line"><span class="comment"> * | |-&gt;|A|-&gt;|B|-&gt;|C|-&gt;|D|-&gt;|E|-&gt;|F|-&gt;|G|-&gt;|H|-&gt;|I|-&gt;|J|-&gt;|K|-&gt;null</span></span><br><span class="line"><span class="comment"> * +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+  +-+</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$nextNode</span>; <span class="comment">//指向下一个节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 索引值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$score</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$data</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;score = <span class="variable">$score</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setData</span>(<span class="params"><span class="variable">$val</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;data = <span class="variable">$val</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexNode</span> <span class="keyword">extends</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> IndexNode|Node</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$downNode</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int 当前的层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">   <span class="comment">// public $level = 0;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SkipList</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 跳跃表层高</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$level</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最高层头结点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> IndexNode</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="variable">$head</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">CONST</span> SKIPLIST_P = <span class="number">0.5</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 最大层数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">const</span> MAX_LEVEL  = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * SkipList constructor.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;head = <span class="keyword">new</span> IndexNode(<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *理论来讲，一级索引中元素个数应该占原始数据的 50%，二级索引中元素个数占 25%，三级索引12.5% ，一直到最顶层。</span></span><br><span class="line"><span class="comment">     * 因为这里每一层的晋升概率是 50%。对于每一个新插入的节点，都需要调用 randomLevel 生成一个合理的层数。</span></span><br><span class="line"><span class="comment">     *该 randomLevel 方法会随机生成 1~MAX_LEVEL 之间的数，且 ：</span></span><br><span class="line"><span class="comment">     *50%的概率返回 1</span></span><br><span class="line"><span class="comment">     *25%的概率返回 2</span></span><br><span class="line"><span class="comment">     *12.5%的概率返回 3 ...</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">randomLevel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$level</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (lcg_value() &lt; <span class="built_in">self</span>::SKIPLIST_P &amp;&amp; <span class="variable">$level</span> &lt; <span class="built_in">self</span>::MAX_LEVEL) &#123;</span><br><span class="line">            <span class="variable">$level</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$level</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $score</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findEntry</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> Node|IndexNode $list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> Node|IndexNode $list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="variable">$list</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$list</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$list</span>-&gt;nextNode &amp;&amp; <span class="variable">$list</span>-&gt;nextNode-&gt;score &lt; <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$list</span> = <span class="variable">$list</span>-&gt;nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$list</span>-&gt;downNode) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$list</span>-&gt;downNode)) &#123;</span><br><span class="line">                <span class="variable">$list</span> = <span class="variable">$list</span>-&gt;downNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$list</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $score</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">findEntry2</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> Node|IndexNode $list</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="variable">$list</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$list</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$list</span>-&gt;nextNode &amp;&amp; <span class="variable">$list</span>-&gt;nextNode-&gt;score &lt; <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$list</span> = <span class="variable">$list</span>-&gt;nextNode;</span><br><span class="line">                <span class="keyword">echo</span> <span class="string">&#x27;::&#x27;</span>.<span class="variable">$list</span>-&gt;score.<span class="string">&#x27;::&#x27;</span>.PHP_EOL;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$list</span>-&gt;downNode) &amp;&amp; !<span class="keyword">empty</span>(<span class="variable">$list</span>-&gt;downNode)) &#123;</span><br><span class="line">                <span class="variable">$list</span> = <span class="variable">$list</span>-&gt;downNode;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$list</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $score</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Node|null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;findEntry(<span class="variable">$score</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$node</span>-&gt;nextNode &amp;&amp; <span class="variable">$node</span>-&gt;nextNode-&gt;score == <span class="variable">$score</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$node</span>-&gt;nextNode;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">addNode</span>(<span class="params"><span class="variable">$score</span>,<span class="variable">$val</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">new</span> Node(<span class="variable">$score</span>);</span><br><span class="line">        <span class="variable">$node</span>-&gt;setData(<span class="variable">$val</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$entryNode</span> = <span class="keyword">$this</span>-&gt;findEntry(<span class="variable">$score</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$entryNode</span> &amp;&amp; <span class="variable">$entryNode</span>-&gt;score == <span class="variable">$score</span> &amp;&amp; <span class="variable">$entryNode</span>-&gt;data == <span class="variable">$val</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$node</span>-&gt;nextNode      = <span class="variable">$entryNode</span>-&gt;nextNode;</span><br><span class="line">        <span class="variable">$entryNode</span>-&gt;nextNode = <span class="variable">$node</span>;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$head</span> = <span class="variable">$down</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@var</span> IndexNode|Node $newIndex</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="variable">$newIndex</span> = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//因为不是双向链接指定，所以要在当前层，往下一层一层添加 索引节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="keyword">$this</span>-&gt;level; <span class="variable">$i</span>&gt;=<span class="number">1</span>;<span class="variable">$i</span>--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$down</span>-&gt;nextNode &amp;&amp; <span class="variable">$down</span>-&gt;nextNode-&gt;score &lt; <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$down</span> = <span class="variable">$down</span>-&gt;nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$down</span>-&gt;nextNode &amp;&amp; <span class="variable">$down</span>-&gt;nextNode-&gt;score == <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$newIndex</span>) &#123;</span><br><span class="line">                    <span class="variable">$newIndex</span>-&gt;downNode = <span class="variable">$down</span>-&gt;nextNode;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="variable">$upNewIndex</span> = <span class="variable">$newIndex</span> ? <span class="variable">$newIndex</span> : <span class="literal">null</span>;</span><br><span class="line">                <span class="variable">$newIndex</span> = <span class="keyword">new</span> IndexNode(<span class="variable">$score</span>);</span><br><span class="line">                <span class="variable">$newIndex</span>-&gt;nextNode = <span class="variable">$down</span>-&gt;nextNode;</span><br><span class="line">                <span class="variable">$down</span>-&gt;nextNode = <span class="variable">$newIndex</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$upNewIndex</span>) &#123;</span><br><span class="line">                    <span class="variable">$upNewIndex</span>-&gt;downNode = <span class="variable">$newIndex</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$down</span> = <span class="variable">$head</span>-&gt;downNode;</span><br><span class="line">            <span class="variable">$head</span> = <span class="variable">$head</span>-&gt;downNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$level</span> = <span class="keyword">$this</span>-&gt;randomLevel();</span><br><span class="line">        <span class="comment">//因为层数大于当前层，所以要在当前层，往上一层一层添加 索引节点，并建立索引节点的上下关系</span></span><br><span class="line">        <span class="variable">$up</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="keyword">$this</span>-&gt;level+<span class="number">1</span>;<span class="variable">$i</span>&lt;= <span class="variable">$level</span>;<span class="variable">$i</span>++) &#123;</span><br><span class="line">            <span class="variable">$downUp</span>       = <span class="variable">$up</span> ?? <span class="literal">null</span>;</span><br><span class="line">            <span class="variable">$up</span>           = <span class="keyword">new</span> IndexNode(<span class="literal">null</span>);</span><br><span class="line">            <span class="variable">$newIndex</span>     = <span class="keyword">new</span> IndexNode(<span class="variable">$score</span>);</span><br><span class="line">            <span class="variable">$up</span>-&gt;nextNode = <span class="variable">$newIndex</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$downUp</span>) &#123;</span><br><span class="line">                <span class="variable">$up</span>-&gt;downNode = <span class="variable">$downUp</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$downUp</span>-&gt;nextNode &amp;&amp; <span class="variable">$downUp</span>-&gt;nextNode-&gt;score &lt; <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$downUp</span> = <span class="variable">$downUp</span>-&gt;nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$down</span>-&gt;nextNode-&gt;score == <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$newIndex</span>-&gt;downNode = <span class="variable">$down</span>-&gt;nextNode;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">$this</span>-&gt;head = <span class="variable">$up</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;level = <span class="keyword">$this</span>-&gt;level &lt; <span class="variable">$level</span> ? <span class="variable">$level</span>:<span class="keyword">$this</span>-&gt;level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印跳跃表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">prinSkipList</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$down</span> = <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">while</span> (<span class="variable">$down</span>) &#123;</span><br><span class="line">            <span class="variable">$str</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$node</span>) &#123;</span><br><span class="line">                <span class="variable">$str</span> .= <span class="string">&#x27;[&#x27;</span>.<span class="variable">$node</span>-&gt;score.<span class="string">&#x27;][&#x27;</span>.(<span class="keyword">isset</span>(<span class="variable">$node</span>-&gt;downNode) ? <span class="variable">$node</span>-&gt;downNode-&gt;score : <span class="literal">null</span>).<span class="string">&#x27;][&#x27;</span>.(<span class="keyword">isset</span>(<span class="variable">$node</span>-&gt;nextNode) ? <span class="variable">$node</span>-&gt;nextNode-&gt;score : <span class="literal">null</span>).<span class="string">&#x27;]--&#x27;</span>;</span><br><span class="line">                <span class="variable">$node</span> = <span class="variable">$node</span>-&gt;nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="variable">$str</span>.PHP_EOL;</span><br><span class="line">            <span class="variable">$down</span> = <span class="variable">$node</span> = <span class="variable">$down</span>-&gt;downNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $score</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> bool</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"><span class="variable">$score</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$node</span> = <span class="keyword">$this</span>-&gt;get(<span class="variable">$score</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$node</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$head</span> = <span class="variable">$down</span> = <span class="keyword">$this</span>-&gt;head;</span><br><span class="line">        <span class="keyword">for</span> (<span class="variable">$i</span> = <span class="keyword">$this</span>-&gt;level;<span class="variable">$i</span>&gt;=<span class="number">1</span>;<span class="variable">$i</span>--) &#123;</span><br><span class="line">            <span class="variable">$nodeNum</span> = <span class="number">1</span>;</span><br><span class="line">            <span class="variable">$levelNode</span> = <span class="variable">$down</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="variable">$down</span>-&gt;nextNode &amp;&amp; <span class="variable">$down</span>-&gt;nextNode-&gt;score &lt; <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$nodeNum</span>++;</span><br><span class="line">                <span class="variable">$down</span> = <span class="variable">$down</span>-&gt;nextNode;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$down</span>-&gt;nextNode &amp;&amp; <span class="variable">$down</span>-&gt;nextNode-&gt;score == <span class="variable">$score</span>) &#123;</span><br><span class="line">                <span class="variable">$down</span>-&gt;nextNode = <span class="variable">$down</span>-&gt;nextNode-&gt;nextNode;</span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$nodeNum</span> &lt;= <span class="number">2</span> &amp;&amp; !<span class="variable">$down</span>-&gt;nextNode) &#123;</span><br><span class="line">                    <span class="keyword">$this</span>-&gt;level = <span class="keyword">$this</span>-&gt;level &gt; <span class="number">1</span> ? (<span class="keyword">$this</span>-&gt;level - <span class="number">1</span>) : <span class="keyword">$this</span>-&gt;level;</span><br><span class="line">                    <span class="variable">$head</span> = <span class="variable">$head</span>-&gt;downNode ? <span class="variable">$head</span>-&gt;downNode : <span class="variable">$head</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="variable">$down</span> = <span class="variable">$levelNode</span>-&gt;downNode ? <span class="variable">$levelNode</span>-&gt;downNode : <span class="variable">$levelNode</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;head = <span class="variable">$head</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">$skipList</span> = <span class="keyword">new</span> SkipList();</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">5</span>,<span class="string">&#x27;5&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">8</span>,<span class="string">&#x27;8&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">6</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">7</span>,<span class="string">&#x27;7&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">3</span>,<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">2</span>,<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">0</span>,<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;prinSkipList();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;-------------------------&quot;</span>.PHP_EOL;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Test 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="variable">$skipList</span> = <span class="keyword">new</span> SkipList();</span><br><span class="line"><span class="variable">$head2</span> = <span class="keyword">new</span> IndexNode(<span class="literal">null</span>);</span><br><span class="line"><span class="variable">$head1</span> = <span class="keyword">new</span> IndexNode(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$head2</span>-&gt;downNode = <span class="variable">$head1</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$data1</span> = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$data1</span>-&gt;setData(<span class="string">&#x27;1&#x27;</span>);</span><br><span class="line"><span class="variable">$index1</span> = <span class="keyword">new</span> IndexNode(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$index1</span>-&gt;downNode = <span class="variable">$data1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$index2</span> = <span class="keyword">new</span> IndexNode(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$data2</span> = <span class="keyword">new</span> Node(<span class="number">2</span>);</span><br><span class="line"><span class="variable">$data2</span>-&gt;setData(<span class="string">&#x27;2&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$index2</span>-&gt;downNode = <span class="variable">$data2</span>;</span><br><span class="line"><span class="variable">$index1</span>-&gt;nextNode = <span class="variable">$index2</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$data1</span>-&gt;nextNode = <span class="variable">$data2</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$data3</span> = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line"><span class="variable">$data3</span>-&gt;setData(<span class="string">&#x27;3&#x27;</span>);</span><br><span class="line"><span class="variable">$data2</span>-&gt;nextNode = <span class="variable">$data3</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$data4</span> = <span class="keyword">new</span> Node(<span class="number">4</span>);</span><br><span class="line"><span class="variable">$data4</span>-&gt;setData(<span class="string">&#x27;4&#x27;</span>);</span><br><span class="line"><span class="variable">$data3</span>-&gt;nextNode = <span class="variable">$data4</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$head1</span>-&gt;nextNode = <span class="variable">$data1</span>;</span><br><span class="line"><span class="variable">$head2</span>-&gt;nextNode = <span class="variable">$index1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$head3</span> = <span class="keyword">new</span> IndexNode(<span class="literal">null</span>);</span><br><span class="line"><span class="variable">$head3</span>-&gt;downNode = <span class="variable">$head2</span>;</span><br><span class="line"><span class="variable">$head3</span>-&gt;nextNode = <span class="keyword">new</span> IndexNode(<span class="number">1</span>);</span><br><span class="line"><span class="variable">$head3</span>-&gt;nextNode-&gt;downNode = <span class="variable">$index1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$skipList</span>-&gt;head  = <span class="variable">$head3</span>;</span><br><span class="line"><span class="variable">$skipList</span>-&gt;level = <span class="number">3</span>;</span><br><span class="line"><span class="variable">$skipList</span>-&gt;prinSkipList();</span><br><span class="line"><span class="variable">$skipList</span>-&gt;del(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;-------------------------&quot;</span>.PHP_EOL;</span><br><span class="line"><span class="variable">$skipList</span>-&gt;prinSkipList();</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;-------------------------&quot;</span>.PHP_EOL;</span><br><span class="line"><span class="variable">$skipList</span>-&gt;addNode(<span class="number">6</span>,<span class="string">&#x27;6&#x27;</span>);</span><br><span class="line"><span class="variable">$skipList</span>-&gt;prinSkipList();</span><br><span class="line"><span class="comment">//$node = $skipList-&gt;get(7);</span></span><br><span class="line"><span class="comment">//var_dump($node-&gt;score);</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>snowflake-雪花算法</title>
    <url>/2020/05/24/snowflake-%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>Snowflake 算法介绍<br>Snowflake 是由 Twitter 提出的一个分布式全局唯一 ID 生成算法，算法生成 ID 的结果是一个 64bit 大小的长整，标准算法下它的结构如下图：<br><img src="/images/img/08-02/2718f82d-82fe-4d68-9a4a-e3e2afc1020b.png"><br>1 位，不用。<br>   二进制中最高位为符号位，我们生成的 ID 一般都是正整数，所以这个最高位固定是 0。<br>41 位，用来记录时间戳（毫秒）。<br>   41 位 可以表示 2^41 - 1 个数字。<br>   也就是说 41 位 可以表示 2^41 - 1 个毫秒的值，转化成单位年则是 (2^41 - 1) / (1000 * 60 * 60 * 24 * 365) 约为 69 年。<br>10 位，用来记录工作机器 ID。<br>   可以部署在 2^10 共 1024 个节点，包括 5 位 DatacenterId 和 5 位 WorkerId。<br>12 位，序列号，用来记录同毫秒内产生的不同 id。<br>  12 位 可以表示的最大正整数是 2^12 - 1 共 4095 个数字，来表示同一机器同一时间截（毫秒)内产生的 4095 个 ID 序号。<br>Snowflake 可以保证：<br>      所有生成的 ID 按时间趋势递增。<br>      整个分布式系统内不会产生重复 ID（因为有 DatacenterId (5 bits) 和 WorkerId (5 bits) 来做区分）。</p>
<span id="more"></span>
<p>算法的PHP实现：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class IdWorker snowflake算法生成unique id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@package</span> Snowflake</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Snowflake</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//开始时间</span></span><br><span class="line">    <span class="keyword">const</span> EPOCH_OFFSET = <span class="number">1293811200000</span>;</span><br><span class="line">    <span class="comment">//首位</span></span><br><span class="line">    <span class="keyword">const</span> SIGN_BITS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//时间戳相减占用的位数</span></span><br><span class="line">    <span class="keyword">const</span> TIMESTAMP_BITS = <span class="number">41</span>;</span><br><span class="line">    <span class="comment">//数据中心位数</span></span><br><span class="line">    <span class="keyword">const</span> DATA_CENTER_BITS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//机器位数</span></span><br><span class="line">    <span class="keyword">const</span> MACHINE_ID_BITS = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//同一毫秒内自增的位数</span></span><br><span class="line">    <span class="keyword">const</span> SEQUENCE_BITS = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$dataCenterId</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> mixed</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$machineId</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> null|int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$lastTimestamp</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@var</span> int</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$sequence</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标志位需要位移的长度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$signLeftShift</span> = <span class="built_in">self</span>::TIMESTAMP_BITS + <span class="built_in">self</span>::DATA_CENTER_BITS + <span class="built_in">self</span>::MACHINE_ID_BITS + <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">    <span class="comment">//时间差值需要位移的长度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$timestampLeftShift</span> = <span class="built_in">self</span>::DATA_CENTER_BITS + <span class="built_in">self</span>::MACHINE_ID_BITS + <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">    <span class="comment">//数据中心需要位移的长度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$dataCenterLeftShift</span> = <span class="built_in">self</span>::MACHINE_ID_BITS + <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">    <span class="comment">//机器需要位移的长度</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$machineLeftShift</span> = <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">    <span class="comment">//最大自增数</span></span><br><span class="line">    <span class="comment">//下边语法执行效果 等于 (1 &lt;&lt; 12) - 1;</span></span><br><span class="line">    <span class="comment">//-1 &lt;&lt; self::SEQUENCE_BITS = 1111111111111111111111111111111111111111111111111111000000000000</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$maxSequenceId</span>   = ~ (-<span class="number">1</span> &lt;&lt; <span class="built_in">self</span>::SEQUENCE_BITS);</span><br><span class="line">    <span class="comment">//最大机器数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$maxMachineId</span>    = ~ (-<span class="number">1</span> &lt;&lt; <span class="built_in">self</span>::MACHINE_ID_BITS);</span><br><span class="line">    <span class="comment">//最大数据中心机器数</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$maxDataCenterId</span> = ~ (-<span class="number">1</span> &lt;&lt; <span class="built_in">self</span>::DATA_CENTER_BITS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * IdWorker constructor.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $dataCenter_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $machine_id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"><span class="variable">$dataCenter_id</span>, <span class="variable">$machine_id</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$dataCenter_id</span> &gt; <span class="keyword">$this</span>-&gt;maxDataCenterId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&#x27;data center id should between 0 and &#x27;</span> . <span class="keyword">$this</span>-&gt;maxDataCenterId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$machine_id</span> &gt; <span class="keyword">$this</span>-&gt;maxMachineId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&#x27;machine id should between 0 and &#x27;</span> . <span class="keyword">$this</span>-&gt;maxMachineId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;dataCenterId = <span class="variable">$dataCenter_id</span>;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;machineId = <span class="variable">$machine_id</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> string</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">id</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="variable">$sign</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="variable">$timestamp</span> = <span class="keyword">$this</span>-&gt;getUnixTimestamp();</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$timestamp</span> &lt; <span class="keyword">$this</span>-&gt;lastTimestamp) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> \<span class="built_in">Exception</span>(<span class="string">&#x27;Clock moved backwards!&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;lastTimestamp == <span class="variable">$timestamp</span>) &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sequence++;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">$this</span>-&gt;sequence &gt; <span class="keyword">$this</span>-&gt;maxSequenceId) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;id();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">$this</span>-&gt;sequence = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;lastTimestamp = <span class="variable">$timestamp</span>;</span><br><span class="line">        <span class="comment">//算出时间差值</span></span><br><span class="line">        <span class="variable">$time</span> = (<span class="keyword">int</span>)(<span class="variable">$timestamp</span> - <span class="built_in">self</span>::EPOCH_OFFSET);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//($sign &lt;&lt; $this-&gt;signLeftShift) =》  1 左移 63 位 : 1000000000000000000000000000000000000000000000000000000000000000</span></span><br><span class="line">        <span class="comment">//($time &lt;&lt; $this-&gt;timestampLeftShift) 时间左移 22 位</span></span><br><span class="line">        <span class="comment">// ($this-&gt;dataCenterId &lt;&lt; $this-&gt;dataCenterLeftShift) 数据中心 左移 17位</span></span><br><span class="line">        <span class="comment">// ($this-&gt;machineId &lt;&lt; $this-&gt;machineLeftShift) 机器中心左移 12 位</span></span><br><span class="line">        <span class="variable">$id</span> = (<span class="variable">$sign</span> &lt;&lt; <span class="keyword">$this</span>-&gt;signLeftShift) | (<span class="variable">$time</span> &lt;&lt; <span class="keyword">$this</span>-&gt;timestampLeftShift) | (<span class="keyword">$this</span>-&gt;dataCenterId &lt;&lt; <span class="keyword">$this</span>-&gt;dataCenterLeftShift) | (<span class="keyword">$this</span>-&gt;machineId &lt;&lt; <span class="keyword">$this</span>-&gt;machineLeftShift) | <span class="keyword">$this</span>-&gt;sequence;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">string</span>)<span class="variable">$id</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解析自增ID</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> $id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> array</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">parse</span>(<span class="params"><span class="variable">$id</span></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//转化为二进制字符串</span></span><br><span class="line">        <span class="variable">$binUuid</span> = decbin(<span class="variable">$id</span>);</span><br><span class="line">        <span class="variable">$len</span> = strlen(<span class="variable">$binUuid</span>);</span><br><span class="line">        <span class="variable">$sequenceStart</span> = <span class="variable">$len</span> - <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">        <span class="comment">//截取自增的二进制字符串</span></span><br><span class="line">        <span class="variable">$sequence</span> = substr(<span class="variable">$binUuid</span>, <span class="variable">$sequenceStart</span>, <span class="built_in">self</span>::SEQUENCE_BITS);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$machineIdStart</span> = <span class="variable">$len</span> - <span class="built_in">self</span>::MACHINE_ID_BITS - <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">        <span class="variable">$machineId</span> = substr(<span class="variable">$binUuid</span>, <span class="variable">$machineIdStart</span>, <span class="built_in">self</span>::MACHINE_ID_BITS);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$dataCenterIdStart</span> = <span class="variable">$len</span> - <span class="built_in">self</span>::DATA_CENTER_BITS - <span class="built_in">self</span>::MACHINE_ID_BITS - <span class="built_in">self</span>::SEQUENCE_BITS;</span><br><span class="line">        <span class="variable">$dataCenterId</span> = substr(<span class="variable">$binUuid</span>, <span class="variable">$dataCenterIdStart</span>, <span class="built_in">self</span>::DATA_CENTER_BITS);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$timestamp</span> = substr(<span class="variable">$binUuid</span>, <span class="number">0</span>, <span class="variable">$dataCenterIdStart</span>);</span><br><span class="line">        <span class="variable">$realTimestamp</span> = bindec(<span class="variable">$timestamp</span>) + <span class="built_in">self</span>::EPOCH_OFFSET;</span><br><span class="line">        <span class="variable">$timestamp</span> = substr(<span class="variable">$realTimestamp</span>, <span class="number">0</span>, -<span class="number">3</span>);</span><br><span class="line">        <span class="variable">$microSecond</span> = substr(<span class="variable">$realTimestamp</span>, -<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">return</span> [</span><br><span class="line">            <span class="string">&#x27;timestamp&#x27;</span> =&gt; date(<span class="string">&#x27;Y-m-d H:i:s&#x27;</span>, <span class="variable">$timestamp</span>) . <span class="string">&#x27;.&#x27;</span> . <span class="variable">$microSecond</span>,</span><br><span class="line">            <span class="string">&#x27;dataCenterId&#x27;</span> =&gt; bindec(<span class="variable">$dataCenterId</span>),</span><br><span class="line">            <span class="string">&#x27;machineId&#x27;</span> =&gt; bindec(<span class="variable">$machineId</span>),</span><br><span class="line">            <span class="string">&#x27;sequence&#x27;</span> =&gt; bindec(<span class="variable">$sequence</span>),</span><br><span class="line">        ];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">getUnixTimestamp</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> floor(microtime(<span class="literal">true</span>) * <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字解析</title>
    <url>/2021/04/20/volatile%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p>Java并发编程：volatile关键字解析</p>
<p>　　 volatile这个关键字可能很多朋友都听说过，或许也都用过。在Java 5之前，它是一个备受争议的关键字，因为在程序中使用它往往会导致出人意料的结果。在Java 5之后，volatile关键字才得以重获生机。</p>
<p>　　volatile关键字虽然从字面上理解起来比较简单，但是要用好不是一件容易的事情。由于volatile关键字是与Java的内存模型有关的，因此在讲述volatile关键之前，我们先来了解一下与内存模型相关的概念和知识，然后分析了volatile关键字的实现原理，最后给出了几个使用volatile关键字的场景。<span id="more"></span></p>
<p>　　以下是本文的目录大纲：</p>
<p>　　一.内存模型的相关概念</p>
<p>　　二.并发编程中的三个概念</p>
<p>　　三.Java内存模型</p>
<p>　　四..深入剖析volatile关键字</p>
<p>　　五.使用volatile关键字的场景</p>
<p>　　若有不正之处请多多谅解，并欢迎批评指正。</p>
<p>　　请尊重作者劳动成果，转载请标明原文链接：</p>
<p>　　<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
<p><strong>一.内存模型的相关概念</strong></p>
<p>　　大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。</p>
<p>　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; i + 1;</span><br></pre></td></tr></table></figure>



<p> 　当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中。</p>
<p>　　这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。</p>
<p>　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？</p>
<p>　　可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。</p>
<p>　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。</p>
<p>　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。</p>
<p>　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：</p>
<p>　　1）通过在总线加LOCK#锁的方式</p>
<p>　　2）通过缓存一致性协议</p>
<p>　　这2种方式都是硬件层面上提供的方式。</p>
<p>　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。</p>
<p>　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。</p>
<p>　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p>
<p>​    <img src="/images/youdao/6107.png" alt="0"></p>
<p><strong>二.并发编程中的三个概念</strong></p>
<p>　　在并发编程中，我们通常会遇到以下三个问题：原子性问题，可见性问题，有序性问题。我们先看具体看一下这三个概念：</p>
<p><strong>1.原子性</strong></p>
<p>　　原子性：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p>
<p>　　一个很经典的例子就是银行账户转账问题：</p>
<p>　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。</p>
<p>　　试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。</p>
<p>　　所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。</p>
<p>　　同样地反映到并发编程中会出现什么结果呢？</p>
<p>　　举个最简单的例子，大家想一下假如为一个32位的变量赋值过程不具备原子性的话，会发生什么后果？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 9;</span><br></pre></td></tr></table></figure>



<p> 　假若一个线程执行到这个语句时，我暂且假设为一个32位的变量赋值包括两个过程：为低16位赋值，为高16位赋值。</p>
<p>　　那么就可能发生一种情况：当将低16位数值写入之后，突然被中断，而此时又有一个线程去读取i的值，那么读取到的就是错误的数据。</p>
<p><strong>2.可见性</strong></p>
<p>　　可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p>
<p>　　举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1执行的代码</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">i = <span class="number">10</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2执行的代码</span></span><br><span class="line">j = i;</span><br></pre></td></tr></table></figure>



<p> 　假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行 i =10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中i的值变为10了，却没有立即写入到主存当中。</p>
<p>　　此时线程2执行 j = i，它会先去主存读取i的值并加载到CPU2的缓存当中，注意此时内存当中i的值还是0，那么就会使得j的值为0，而不是10.</p>
<p>　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。</p>
<p><strong>3.有序性</strong></p>
<p>　　有序性：即程序执行的顺序按照代码的先后顺序执行。举个简单的例子，看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;              </span><br><span class="line"><span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">i = <span class="number">1</span>;                <span class="comment">//语句1  </span></span><br><span class="line">flag = <span class="keyword">true</span>;          <span class="comment">//语句2</span></span><br></pre></td></tr></table></figure>



<p> 　上面代码定义了一个int型变量，定义了一个boolean类型变量，然后分别对两个变量进行赋值操作。从代码顺序上看，语句1是在语句2前面的，那么JVM在真正执行这段代码的时候会保证语句1一定会在语句2前面执行吗？不一定，为什么呢？这里可能会发生指令重排序（Instruction Reorder）。</p>
<p>　　下面解释一下什么是指令重排序，一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。</p>
<p>　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。</p>
<p>　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;    <span class="comment">//语句1</span></span><br><span class="line"><span class="keyword">int</span> r = <span class="number">2</span>;    <span class="comment">//语句2</span></span><br><span class="line">a = a + <span class="number">3</span>;    <span class="comment">//语句3</span></span><br><span class="line">r = a*a;     <span class="comment">//语句4</span></span><br></pre></td></tr></table></figure>



<p> 　这段代码有4个语句，那么可能的一个执行顺序是：</p>
<p>　　</p>
<p>​    <img src="/images/youdao/0.jpeg" alt="0"></p>
<p>　　</p>
<p>　　那么可不可能是这个执行顺序呢： 语句2  语句1  语句4  语句3</p>
<p>　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。</p>
<p>　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//线程1:</span></span><br><span class="line">context = loadContext();   <span class="comment">//语句1</span></span><br><span class="line">inited = <span class="keyword">true</span>;             <span class="comment">//语句2</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//线程2:</span></span><br><span class="line"><span class="keyword">while</span>(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>



<p> 　上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。</p>
<p> 　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。</p>
<p>　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。</p>
<p><strong>三.Java内存模型</strong></p>
<p>　　在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。</p>
<p>　　在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。</p>
<p>　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。</p>
<p>　　举个简单的例子：在java中，执行下面这个语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i &#x3D; 10;</span><br></pre></td></tr></table></figure>



<p> 　执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。</p>
<p>　　那么Java语言 本身对 原子性、可见性以及有序性提供了哪些保证呢？</p>
<p><strong>1.原子性</strong></p>
<p>　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</p>
<p>　　上面一句话虽然看起来简单，但是理解起来并不是那么容易。看下面一个例子i：</p>
<p>　　请分析以下哪些操作是原子性操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 10;         &#x2F;&#x2F;语句1</span><br><span class="line">y &#x3D; x;         &#x2F;&#x2F;语句2</span><br><span class="line">x++;           &#x2F;&#x2F;语句3</span><br><span class="line">x &#x3D; x + 1;     &#x2F;&#x2F;语句4</span><br></pre></td></tr></table></figure>



<p> 　咋一看，有些朋友可能会说上面的4个语句中的操作都是原子性操作。其实只有语句1是原子性操作，其他三个语句都不是原子性操作。</p>
<p>　　语句1是直接将数值10赋值给x，也就是说线程执行这个语句的会直接将数值10写入到工作内存中。</p>
<p>　　语句2实际上包含2个操作，它先要去读取x的值，再将x的值写入工作内存，虽然读取x的值以及 将x的值写入工作内存 这2个操作都是原子性操作，但是合起来就不是原子性操作了。</p>
<p>　　同样的，x++和 x = x+1包括3个操作：读取x的值，进行加1操作，写入新的值。</p>
<p> 　所以上面4个语句只有语句1的操作具备原子性。</p>
<p>　　也就是说，只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。</p>
<p>　　不过这里有一点需要注意：在32位平台下，对64位数据的读取和赋值是需要通过两个操作来完成的，不能保证其原子性。但是好像在最新的JDK中，JVM已经保证对64位数据的读取和赋值也是原子性操作了。</p>
<p>　　从上面可以看出，Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和Lock来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。</p>
<p><strong>2.可见性</strong></p>
<p>　　对于可见性，Java提供了volatile关键字来保证可见性。</p>
<p>　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。</p>
<p>　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。</p>
<p>　　另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p>
<p><strong>3.有序性</strong></p>
<p>　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p>
<p>　　在Java里面，可以通过volatile关键字来保证一定的“有序性”（具体原理在下一节讲述）。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p>
<p>　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
<p>　　下面就来具体介绍下happens-before原则（先行发生原则）：</p>
<ul>
<li>程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作</li>
<li>锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作</li>
<li>volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作</li>
<li>传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C</li>
<li>线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作</li>
<li>线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生</li>
<li>线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行</li>
<li>对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始</li>
</ul>
<p>　　这8条原则摘自《深入理解Java虚拟机》。</p>
<p>　　这8条规则中，前4条规则是比较重要的，后4条规则都是显而易见的。</p>
<p>　　下面我们来解释一下前4条规则：</p>
<p>　　对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，它只会对不存在数据依赖性的指令进行重排序。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。</p>
<p>　　第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果出于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。</p>
<p>　　第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。</p>
<p>　　第四条规则实际上就是体现happens-before原则具备传递性。</p>
<p><strong>四.深入剖析volatile关键字</strong></p>
<p>　　在前面讲述了很多东西，其实都是为讲述volatile关键字作铺垫，那么接下来我们就进入主题。</p>
<p><strong>1.volatile关键字的两层语义</strong></p>
<p>　　一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：</p>
<p>　　1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</p>
<p>　　2）禁止进行指令重排序。</p>
<p>　　先看一段代码，假如线程1先执行，线程2后执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1</span><br><span class="line">boolean stop &#x3D; false;</span><br><span class="line">while(!stop)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2</span><br><span class="line">stop &#x3D; true;</span><br></pre></td></tr></table></figure>



<p> 　这段代码是很典型的一段代码，很多人在中断线程时可能都会采用这种标记办法。但是事实上，这段代码会完全运行正确么？即一定会将线程中断么？不一定，也许在大多数时候，这个代码能够把线程中断，但是也有可能会导致无法中断线程（虽然这个可能性很小，但是只要一旦发生这种情况就会造成死循环了）。</p>
<p>　　下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。</p>
<p>　　那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。</p>
<p>　　但是用volatile修饰之后就变得不一样了：</p>
<p>　　第一：使用volatile关键字会强制将修改的值立即写入主存；</p>
<p>　　第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；</p>
<p>　　第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。</p>
<p>　　那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。</p>
<p>　　那么线程1读取到的就是最新的正确的值。</p>
<p><strong>2.volatile保证原子性吗？</strong></p>
<p>　　从上面知道volatile关键字保证了操作的可见性，但是volatile能保证对变量的操作是原子性吗？</p>
<p>　　下面看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 　大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。</p>
<p>　　可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。</p>
<p>　　这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。</p>
<p>　　在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：</p>
<p>　　假如某个时刻变量inc的值为10，</p>
<p>　　线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；</p>
<p>　　然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。</p>
<p>　　然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。</p>
<p>　　那么两个线程分别进行了一次自增操作后，inc只增加了1。</p>
<p>　　解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。</p>
<p>　　根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。</p>
<p>　　把上面的代码改成以下任何一种都可以达到效果：</p>
<p>　　采用synchronized：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>采用lock</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">int</span> inc = <span class="number">0</span>;</span><br><span class="line">    Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span>  <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            inc++;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Test test = <span class="keyword">new</span> Test();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread()&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">1000</span>;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(Thread.activeCount()&gt;<span class="number">1</span>)  <span class="comment">//保证前面的线程都执行完</span></span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　采用AtomicInteger</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public  AtomicInteger inc &#x3D; new AtomicInteger();</span><br><span class="line">     </span><br><span class="line">    public  void increase() &#123;</span><br><span class="line">        inc.getAndIncrement();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        final Test test &#x3D; new Test();</span><br><span class="line">        for(int i&#x3D;0;i&lt;10;i++)&#123;</span><br><span class="line">            new Thread()&#123;</span><br><span class="line">                public void run() &#123;</span><br><span class="line">                    for(int j&#x3D;0;j&lt;1000;j++)</span><br><span class="line">                        test.increase();</span><br><span class="line">                &#125;;</span><br><span class="line">            &#125;.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        while(Thread.activeCount()&gt;1)  &#x2F;&#x2F;保证前面的线程都执行完</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>   　　在java 1.5的java.util.concurrent.atomic包下提供了一些原子操作类，即对基本数据类型的 自增（加1操作），自减（减1操作）、以及加法操作（加一个数），减法操作（减一个数）进行了封装，保证这些操作是原子性操作。atomic是利用CAS来实现原子性操作的（Compare And Swap），CAS实际上是利用处理器提供的CMPXCHG指令实现的，而处理器执行CMPXCHG指令是一个原子性操作。</p>
<p><strong>3.volatile能保证有序性吗？</strong></p>
<p>　　在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。</p>
<p>　　volatile关键字禁止指令重排序有两层意思：</p>
<p>　　1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；</p>
<p>　　2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。</p>
<p>　　可能上面说的比较绕，举个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;x、y为非volatile变量</span><br><span class="line">&#x2F;&#x2F;flag为volatile变量</span><br><span class="line"> </span><br><span class="line">x &#x3D; 2;        &#x2F;&#x2F;语句1</span><br><span class="line">y &#x3D; 0;        &#x2F;&#x2F;语句2</span><br><span class="line">flag &#x3D; true;  &#x2F;&#x2F;语句3</span><br><span class="line">x &#x3D; 4;         &#x2F;&#x2F;语句4</span><br><span class="line">y &#x3D; -1;       &#x2F;&#x2F;语句5</span><br></pre></td></tr></table></figure>



<p> 　由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会讲语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序、语句4和语句5的顺序是不作任何保证的。</p>
<p>　　并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、语句4、语句5是可见的。</p>
<p>　　那么我们回到前面举的一个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();   &#x2F;&#x2F;语句1</span><br><span class="line">inited &#x3D; true;             &#x2F;&#x2F;语句2</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">  sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>



<p> 　前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么久可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。</p>
<p>　　这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。</p>
<p><strong>4.volatile的原理和实现机制</strong></p>
<p>　　前面讲述了源于volatile关键字的一些使用，下面我们来探讨一下volatile到底如何保证可见性和禁止指令重排序的。</p>
<p>　　下面这段话摘自《深入理解Java虚拟机》：</p>
<p>　　“观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p>
<p>　　lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p>
<p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</p>
<p>　　2）它会强制将对缓存的修改操作立即写入主存；</p>
<p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p>
<p><strong>五.使用volatile关键字的场景</strong></p>
<p>　　synchronized关键字是防止多个线程同时执行一段代码，那么就会很影响程序执行效率，而volatile关键字在某些情况下性能要优于synchronized，但是要注意volatile关键字是无法替代synchronized关键字的，因为volatile关键字无法保证操作的原子性。通常来说，使用volatile必须具备以下2个条件：</p>
<p>　　1）对变量的写操作不依赖于当前值</p>
<p>　　2）该变量没有包含在具有其他变量的不变式中</p>
<p>　　实际上，这些条件表明，可以被写入 volatile 变量的这些有效值独立于任何程序的状态，包括变量的当前状态。</p>
<p>　　事实上，我的理解就是上面的2个条件需要保证操作是原子性操作，才能保证使用volatile关键字的程序在并发时能够正确执行。</p>
<p>　　下面列举几个Java中使用volatile的几个场景。</p>
<p><strong>1.状态标记量</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean flag &#x3D; false;</span><br><span class="line"> </span><br><span class="line">while(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">public void setFlag() &#123;</span><br><span class="line">    flag &#x3D; true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean inited &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();  </span><br><span class="line">inited &#x3D; true;            </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br></pre></td></tr></table></figure>


<p><strong>2.double check</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">    private volatile static Singleton instance &#x3D; null;</span><br><span class="line">     </span><br><span class="line">    private Singleton() &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public static Singleton getInstance() &#123;</span><br><span class="line">        if(instance&#x3D;&#x3D;null) &#123;</span><br><span class="line">            synchronized (Singleton.class) &#123;</span><br><span class="line">                if(instance&#x3D;&#x3D;null)</span><br><span class="line">                    instance &#x3D; new Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p> 　至于为何需要这么写请参考：</p>
<p>　　《Java 中的双重检查（Double-Check）》<a href="http://blog.csdn.net/dl88250/article/details/5439024">http://blog.csdn.net/dl88250/article/details/5439024</a></p>
<p>　　和<a href="http://www.iteye.com/topic/652440">http://www.iteye.com/topic/652440</a></p>
<p>　　参考资料：</p>
<p>　　《Java编程思想》</p>
<p>　　《深入理解Java虚拟机》</p>
<p>　　<a href="http://jiangzhengjun.iteye.com/blog/652532">http://jiangzhengjun.iteye.com/blog/652532</a></p>
<p>　　<a href="http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html">http://blog.sina.com.cn/s/blog_7bee8dd50101fu8n.html</a></p>
<p>　　<a href="http://ifeve.com/volatile/">http://ifeve.com/volatile/</a></p>
<p>　　<a href="http://blog.csdn.net/ccit0519/article/details/11241403">http://blog.csdn.net/ccit0519/article/details/11241403</a></p>
<p>　　<a href="http://blog.csdn.net/ns_code/article/details/17101369">http://blog.csdn.net/ns_code/article/details/17101369</a></p>
<p>　　<a href="http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html">http://www.cnblogs.com/kevinwu/archive/2012/05/02/2479464.html</a></p>
<p>　　<a href="http://www.cppblog.com/elva/archive/2011/01/21/139019.html">http://www.cppblog.com/elva/archive/2011/01/21/139019.html</a></p>
<p>　　<a href="http://ifeve.com/volatile-array-visiblity/">http://ifeve.com/volatile-array-visiblity/</a></p>
<p>　　<a href="http://www.bdqn.cn/news/201312/12579.shtml">http://www.bdqn.cn/news/201312/12579.shtml</a></p>
<p>　　<a href="http://exploer.blog.51cto.com/7123589/1193399">http://exploer.blog.51cto.com/7123589/1193399</a></p>
<p>　　<a href="http://www.cnblogs.com/Mainz/p/3556430.html">http://www.cnblogs.com/Mainz/p/3556430.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title>redis-网络模型</title>
    <url>/2019/07/29/redis-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>当我们进行网络IO时，Linux给我提供的常用的有seelct 和epoll两个系统级函数，来进行IO操作。现在大部分高并发的网络模型都是基于epoll，比如nginx，redis等。先学习下Linux的网络模型<br><strong>Linux网络I/O模型简介</strong><br>   Linux的内核将所有外部设备都看做一个文件来操作,对一个文件的读写操作会调用内核提供的系统命令,返回一个file descriptor (fd,文件描述符)。而对一个socket的该写也会有相应的描述符,称为socketfd (socket描述符),描述符就是一个数字,它指向内核中的一个结构体(文件路径,数据区等一些属性)。<span id="more"></span><br>根据UNIX网络编程对I/O模型的分类, UNIX提供了5种I/O模型,分别如下。<br>(1)阻塞I/O模型:</p>
<p>​    最常用的I/O模型就是阻塞I/O模型,缺省情形下,所有文件操作都是阻塞的。我们以套接字接口为例来讲解此模型:在进程空间中调用recvfrom,其系统调用直到数据包到达且被复制到应用进程的缓冲区中或者发生错误时才返回,在此期间一直会等待,进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的,因此被秘为阻塞I/O模型,如图1-1所示。</p>
<p>   阻塞IO当使用accept会一直阻塞住，等待IO，然后read读取数据等待。当对已建立的链接进行读取的时候，应用进程被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。应该注意到，在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU 利用率会比较高。</p>
<p>(2)非阻塞I/O模型: </p>
<p>   recvfrom从应用层到内核的时候,如果该缓冲区没有数据的话,就直接返回一个EWOULDBLOCK错误,一般都对非阻塞I/O模型进行轮询检查这个状态,看内核是不是有数据到来。</p>
<p>   当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：如图1-2所示。</p>
<p><img src="/images/4615.png" alt="img"></p>
<p>(3) I/O复用模型（多路复用）: </p>
<p>   Linux提供select/poll,进程通过将一个或多个fd传递给select或poll系统调用,阻塞在select操作上,这样select/poll可以帮我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪,而且支持的fd数量有限,因此它的使用受到了一些制约。Linux还提供了一个epoll系统调用, epoll使用基于事件驱动方式代替顺序扫描,因此性能更高。当有fd就绪时,立即回调函数rollback,如图1-3所示。</p>
<p>   当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。linux下，可以通过设置socket使其变为non-blocking。当对一个non-blocking socket执行读操作时，流程是这个样子：如图1-2所示。</p>
<p>select和epoll都提供IO多路复用支持的，可以在一个进程内支持很多的网络链接。并且他们在读取数据的时候都是阻塞的模式【因为他们都需要在读写事件就绪后自己负责进行读写（把数据从内核态拷贝到当前用户进程态），也就是说这个读写过程是阻塞的】</p>
<p>(4)信号驱动I/O模型:</p>
<p>  首先开启套接口信号驱动I/O功能,并通过系统调用sigaction执行一个信号处理函数(此系统调用立即返回,进程继续工作,它是非阻塞的)。当数据准备就绪时,就为该进程生成一个SIGIO信号,通过信号回调通知应用程序调用recvfrom来读取数据,并通知主循环函数处理数据,如图1-4所示。</p>
<p><img src="/images/4616.png" alt="img"></p>
<p>(5)异步I/O:</p>
<p>   告知内核启动某个操作,并让内核在整个操作完成后(包括将数据从内核复制到用户自己的缓冲区,其它IO模型都的调用系统函数把数据从内核态拷贝到当前用户进程态，所以其他IO模型可以说是非阻塞同步IO或是阻塞同步IO。)通知我们。这种模型与信号驱动模型的主要区别是:信号驱动I/O由内核通知我们何时可以开始一个I/O操作;异步I/O模型由内核通知我们I/O操作何时已经完成,</p>
<p>如图1-5所示。</p>
<p>   用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p>
<p>如果想要了解更多的UNIX系统网络编程知识,可以阅读《UNIX网络编程》,里面有非常详细的原理和API介绍。</p>
<p><img src="/images/4614.png" alt="img"></p>
<p>IO多路复用：</p>
<p>  就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。当用户进程调用了select，那么整个进程会被block，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。所以，I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p>
<p><img src="/images/4458.png" alt="img"></p>
<p><strong>IO多路复用解决的问题：</strong></p>
<p>   非阻塞IO时的用户进程的一直轮询，而是告诉内核我当前所关注的IO事件是哪些，当内核检测到进程所关注的IO有事件的时候，内核会返回就绪的事件IO，这个时候还是需要阻塞的同步去把数据从内核态拷贝用户进程态（拷贝数据是阻塞，而异步IO是内核把数据拷贝好了后通知进程）。select 和epoll都支持IO多路复用,并且阻塞IO，非阻塞IO都属于同步IO。</p>
<p>select ：</p>
<p>  调用后select函数会阻塞(通过 socket -set设置成非阻塞模式就会一直轮询CPU,linux下使用fcntl函数设置)，直到有描述副就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p>
<p>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p>
<p>epoll:</p>
<p>  epoll没有IO的限制，而且底层使用红黑树结构，对于事件的添加和删除更高效。是之前的select和poll的增强版本。相对于select和poll来说，epoll更加灵活，没有描述符限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</p>
<p><strong>epoll相对于select的优势：</strong></p>
<p>1：支持一个进程打开的socket描述符(FD)不受限制(仅受限于操作系统的最大文到</p>
<p>件句柄数)。select最大的缺陷就是单个进程所打开的FD是有一定限制的,它由FD-SETSIZE设</p>
<p>的置,默认值是1024,对于那些需要支持上万个TCP连接的大型服务器来说显然太少了。</p>
<p>可以选择修改这个宏然后重新编译内核,不过这会带来网络效率的下降。我们也可以通过选择多进程的方案(传统的Apache方案)解决这个问题,不过虽然在Linux上创建进程的代价比较小,但仍旧是不可忽视的。另外,进程间的数据交换非常麻烦,对于Java来说,由于没有共享内存,需要通过Socket通信或者其他方式进行数据同步,这带来了额外的性能损耗,增加了程序复杂度,所以也不是一种完美的解决方案。值得庆幸的是, epoll并没有这个限制,它所支持的FD上限是操作系统的最大文件句柄数,这个数字远远大于1024,例如,在1GB内存的机器上大约是10万个句柄左右,具体的值可以通过cat/proc/sys/fs/file-max察看,通常情况下这个值跟系统的内存关系比较大。</p>
<p>2.：IO效率不会随着FD数目的增加而线性下降。</p>
<p>传统select/poll的另一个致命弱点,就是当你拥有一个很大的socket集合时,由于网络延时或者链路空闲,任一时刻只有少部分的socket是“活跃”的,但是selectpoll每次调用都会线性扫描全部的集合,导致效率呈现线性下降。epoll不存在这个问题,它只会对“活跃”的socket进行操作-这是因为在内核实现中, epoll是根据每个fd上面的callback函数实现的。那么,只有“活跃”的socket才会去主动调用callback函数,其他idle状态的socket则不会。在这点上, epoll实现了一个伪AIO。针对epoll和select性能对比的benchmark测试表明:如果所有的socket都处于活跃态-例如一个高速LAN环境, epol并不比select/poll效率高太多;相反,如果过多使用epollctl,效率相比还有稍微地降低但是一旦使用idle connections模拟WAN环境, epoll的效率就远在selectpoll之上了。</p>
<p>3： 使用mmap加速内核与用户空间的消息传递。</p>
<p>无论是select, poll还是epoll都需要内核把FD消息通知给用户空间,如何避免不必要的内存复制就显得非常重要, epoll是通过内核和用户空间mmap同一块内存来实现的。</p>
<p>4： epoll的API更加简单</p>
<p>包括创建一个epoll描述符、添加监听事件、阻塞等待所监听的事件发生、关闭epoll描述符等</p>
<p><strong>epoll操作过程需要三个接口，分别如下：</strong></p>
<p>int epoll_create(int size)；//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大 int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)； int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<p>\1. int epoll_create(int size);</p>
<p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</p>
<p>当创建好epoll句柄后，它就会占用一个fd值，在linux下如果查看/proc/进程id/fd/，是能够看到这个fd的，所以在使用完epoll后，必须调用close()关闭，否则可能导致fd被耗尽。</p>
<p>\2. int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</p>
<p>函数是对指定描述符fd执行op操作。</p>
<p>- epfd：是epoll_create()的返回值。</p>
<p>- op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</p>
<p>- fd：是需要监听的fd（文件描述符）</p>
<p>- epoll_event：是告诉内核需要监听什么事，struct epoll_event结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span>  </span><br><span class="line">    <span class="keyword">void</span> *ptr;  </span><br><span class="line">    <span class="keyword">int</span> fd;  </span><br><span class="line">    <span class="keyword">__uint32_t</span> u32;  </span><br><span class="line">    <span class="keyword">__uint64_t</span> u64;  </span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;  </span><br><span class="line"> <span class="comment">//感兴趣的事件和被触发的事件</span></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure>

<p>\3. int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</p>
<p>等待epfd上的io事件，最多返回maxevents个事件。</p>
<p>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p>
<h3 id="redis在网络模型结构"><a href="#redis在网络模型结构" class="headerlink" title="redis在网络模型结构"></a><strong>redis在网络模型结构</strong></h3><p>事件处理主要基于eventLoop结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* State of an event based program </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 事件处理器的状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeEventLoop</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已注册的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> maxfd;   <span class="comment">/* highest file descriptor currently registered */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 目前已追踪的最大描述符</span></span><br><span class="line">    <span class="keyword">int</span> setsize; <span class="comment">/* max number of file descriptors tracked */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用于生成时间事件 id</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> timeEventNextId;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 最后一次执行时间事件的时间</span></span><br><span class="line">    <span class="keyword">time_t</span> lastTime;     <span class="comment">/* Used to detect system clock skew */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已注册的文件事件</span></span><br><span class="line">    aeFileEvent *events; <span class="comment">/* Registered events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 已就绪的文件事件</span></span><br><span class="line">    aeFiredEvent *fired; <span class="comment">/* Fired events */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间事件</span></span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件处理器的开关</span></span><br><span class="line">    <span class="keyword">int</span> stop;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多路复用库的私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *apidata; <span class="comment">/* This is used for polling API specific data */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在处理事件前要执行的函数</span></span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line"></span><br><span class="line">&#125; aeEventLoop;</span><br></pre></td></tr></table></figure>

<p><img src="/images/img/12-01/5ba479c5-efd4-4dff-b7ab-aa4b19cbdc8d.png" alt="img"></p>
<p>1：对 epoll的封装，用来操作加入监听事件，删除事件和获取就绪事件 ae_apoll.c其中也有 ae_kqueue.c</p>
<p>定义这些主要是对外有统一的接口和访问方式，来屏蔽不同操作系统间的差异。并且对外提供一致的接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Linux epoll(2) based ae.c module</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2009-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   * Redistributions of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment"> *     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *   * Neither the name of Redis nor the names of its contributors may be used</span></span><br><span class="line"><span class="comment"> *     to endorse or promote products derived from this software without</span></span><br><span class="line"><span class="comment"> *     specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span></span><br><span class="line"><span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></span><br><span class="line"><span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></span><br><span class="line"><span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span></span><br><span class="line"><span class="comment"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></span><br><span class="line"><span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span></span><br><span class="line"><span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span></span><br><span class="line"><span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span></span><br><span class="line"><span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span></span><br><span class="line"><span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></span><br><span class="line"><span class="comment"> * POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">aeApiState</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// epoll_creat创建返回的ID</span></span><br><span class="line">    <span class="keyword">int</span> epfd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 事件槽,用来保存 epoll_wait返回的事件数组</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">events</span>;</span></span><br><span class="line"></span><br><span class="line">&#125; aeApiState;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建一个新的 epoll 实例，并将它赋值给 eventLoop</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiCreate</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存，并且创建 aeApiState变量</span></span><br><span class="line">    aeApiState *state = zmalloc(<span class="keyword">sizeof</span>(aeApiState));</span><br><span class="line">    <span class="comment">//类似 aeApiState *state = malloc(sizeof(aeApiState));</span></span><br><span class="line">    <span class="comment">//  创建失败 </span></span><br><span class="line">    <span class="keyword">if</span> (!state) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 初始化事件槽空间</span></span><br><span class="line">    <span class="comment">//malloc(sizeof(struct epoll_event)*eventLoop-&gt;setsize);</span></span><br><span class="line">    state-&gt;events = zmalloc(<span class="keyword">sizeof</span>(struct epoll_event)*eventLoop-&gt;setsize);</span><br><span class="line">    <span class="keyword">if</span> (!state-&gt;events) &#123;</span><br><span class="line">        <span class="comment">//free(state);</span></span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 epoll 实例</span></span><br><span class="line">    <span class="comment">//epoll_create的参数只是一个参考值，没有实质行的影响</span></span><br><span class="line">    state-&gt;epfd = epoll_create(<span class="number">1024</span>); <span class="comment">/* 1024 is just a hint for the kernel */</span></span><br><span class="line">    <span class="keyword">if</span> (state-&gt;epfd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">//free(state-&gt;events)</span></span><br><span class="line">        zfree(state-&gt;events);</span><br><span class="line">        <span class="comment">//free(state);</span></span><br><span class="line">        zfree(state);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 赋值给 eventLoop,作为epoll的记录</span></span><br><span class="line">    eventLoop-&gt;apidata = state;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 调整事件槽大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiResize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    state-&gt;events = zrealloc(state-&gt;events, <span class="keyword">sizeof</span>(struct epoll_event)*setsize);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 释放 epoll 实例和事件槽</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiFree</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line"></span><br><span class="line">    close(state-&gt;epfd);</span><br><span class="line">    zfree(state-&gt;events);</span><br><span class="line">    zfree(state);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 关联给定事件到 fd</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiAddEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="comment">//创建一个 epoll_event 结构体变量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the fd was already monitored for some event, we need a MOD</span></span><br><span class="line"><span class="comment">     * operation. Otherwise we need an ADD operation. </span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果 fd 没有关联任何事件，那么这是一个 ADD 操作。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 如果已经关联了某个/某些事件，那么这是一个 MOD 操作。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">int</span> op = eventLoop-&gt;events[fd].mask == AE_NONE ?</span><br><span class="line">            EPOLL_CTL_ADD : EPOLL_CTL_MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册事件到 epoll</span></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    mask |= eventLoop-&gt;events[fd].mask; <span class="comment">/* Merge old events */</span></span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="comment">//添加到 epoll事件里</span></span><br><span class="line">    <span class="keyword">if</span> (epoll_ctl(state-&gt;epfd,op,fd,&amp;ee) == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从 fd 中删除特定事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeApiDelEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> delmask)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ee</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> mask = eventLoop-&gt;events[fd].mask &amp; (~delmask);</span><br><span class="line"></span><br><span class="line">    ee.events = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) ee.events |= EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) ee.events |= EPOLLOUT;</span><br><span class="line">    ee.data.u64 = <span class="number">0</span>; <span class="comment">/* avoid valgrind warning */</span></span><br><span class="line">    ee.data.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (mask != AE_NONE) &#123;<span class="comment">//判断是否需要删除，如果还有事件，修改</span></span><br><span class="line">        epoll_ctl(state-&gt;epfd,EPOLL_CTL_MOD,fd,&amp;ee);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有事件从epoll里删除事件</span></span><br><span class="line">        <span class="comment">/* Note, Kernel &lt; 2.6.9 requires a non null event pointer even for</span></span><br><span class="line"><span class="comment">         * EPOLL_CTL_DEL. */</span></span><br><span class="line">        epoll_ctl(state-&gt;epfd,EPOLL_CTL_DEL,fd,&amp;ee);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取可执行事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">aeApiPoll</span><span class="params">(aeEventLoop *eventLoop, struct timeval *tvp)</span> </span>&#123;</span><br><span class="line">    aeApiState *state = eventLoop-&gt;apidata;</span><br><span class="line">    <span class="keyword">int</span> retval, numevents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待时间</span></span><br><span class="line">    <span class="comment">// 如果有事件，epoll会填充 state-&gt;events</span></span><br><span class="line">    <span class="comment">//state-&gt;events数组的大小要和 eventLoop-&gt;setsize数字值一致</span></span><br><span class="line">    retval = epoll_wait(state-&gt;epfd,state-&gt;events,eventLoop-&gt;setsize,</span><br><span class="line">            tvp ? (tvp-&gt;tv_sec*<span class="number">1000</span> + tvp-&gt;tv_usec/<span class="number">1000</span>) : <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有至少一个事件就绪？</span></span><br><span class="line">    <span class="keyword">if</span> (retval &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">// 为已就绪事件设置相应的模式</span></span><br><span class="line">        <span class="comment">// 并加入到 eventLoop 的 fired 数组中</span></span><br><span class="line">        numevents = retval;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> mask = <span class="number">0</span>;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> *<span class="title">e</span> =</span> state-&gt;events+j;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLIN) mask |= AE_READABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLOUT) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLERR) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="keyword">if</span> (e-&gt;events &amp; EPOLLHUP) mask |= AE_WRITABLE;</span><br><span class="line">            <span class="comment">//从 eventLoop-&gt;apiData-&gt;events里填充到 eventLoop-&gt;fired</span></span><br><span class="line">            eventLoop-&gt;fired[j].fd = e-&gt;data.fd;</span><br><span class="line">            eventLoop-&gt;fired[j].mask = mask;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回已就绪事件个数</span></span><br><span class="line">    <span class="keyword">return</span> numevents;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回当前正在使用的 poll 库的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">char</span> *<span class="title">aeApiName</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;epoll&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2:redis对事件模型做了一次封装 在ae.h和ae.c.其中ae.h定义一些头部文件和ae.c是是实现，并且会判断不同操作系统以便加载对应的系统文件，如linux下加载ae_epoll.c。ae.c会调用【ae_apoll,ae_kqueue.c，这些文件对外提供里统一的操作方式，对外提供里统一的接口】里的方法来操作系统提供的IO多路复用函数。</p>
<p>ae.h</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* A simple event-driven programming library. Originally I wrote this code</span><br><span class="line"> * for the Jim&#39;s event-loop (Jim is a Tcl interpreter) but later translated</span><br><span class="line"> * it in form of a library for easy reuse.</span><br><span class="line"> *</span><br><span class="line"> * Copyright (c) 2006-2012, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span><br><span class="line"> * All rights reserved.</span><br><span class="line"> *</span><br><span class="line"> * Redistribution and use in source and binary forms, with or without</span><br><span class="line"> * modification, are permitted provided that the following conditions are met:</span><br><span class="line"> *</span><br><span class="line"> *   * Redistributions of source code must retain the above copyright notice,</span><br><span class="line"> *     this list of conditions and the following disclaimer.</span><br><span class="line"> *   * Redistributions in binary form must reproduce the above copyright</span><br><span class="line"> *     notice, this list of conditions and the following disclaimer in the</span><br><span class="line"> *     documentation and&#x2F;or other materials provided with the distribution.</span><br><span class="line"> *   * Neither the name of Redis nor the names of its contributors may be used</span><br><span class="line"> *     to endorse or promote products derived from this software without</span><br><span class="line"> *     specific prior written permission.</span><br><span class="line"> *</span><br><span class="line"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span><br><span class="line"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span><br><span class="line"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span><br><span class="line"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span><br><span class="line"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span><br><span class="line"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span><br><span class="line"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span><br><span class="line"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span><br><span class="line"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span><br><span class="line"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span><br><span class="line"> * POSSIBILITY OF SUCH DAMAGE.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">#ifndef __AE_H__</span><br><span class="line">#define __AE_H__</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 事件执行状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 成功</span><br><span class="line">#define AE_OK 0</span><br><span class="line">&#x2F;&#x2F; 出错</span><br><span class="line">#define AE_ERR -1</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 文件事件状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 未设置</span><br><span class="line">#define AE_NONE 0</span><br><span class="line">&#x2F;&#x2F; 可读</span><br><span class="line">#define AE_READABLE 1</span><br><span class="line">&#x2F;&#x2F; 可写</span><br><span class="line">#define AE_WRITABLE 2</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 时间处理器的执行 flags</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F; 文件事件</span><br><span class="line">#define AE_FILE_EVENTS 1</span><br><span class="line">&#x2F;&#x2F; 时间事件</span><br><span class="line">#define AE_TIME_EVENTS 2</span><br><span class="line">&#x2F;&#x2F; 所有事件</span><br><span class="line">#define AE_ALL_EVENTS (AE_FILE_EVENTS|AE_TIME_EVENTS)</span><br><span class="line">&#x2F;&#x2F; 不阻塞，也不进行等待</span><br><span class="line">#define AE_DONT_WAIT 4</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 决定时间事件是否要持续执行的 flag</span><br><span class="line"> *&#x2F;</span><br><span class="line">#define AE_NOMORE -1</span><br><span class="line"></span><br><span class="line">&#x2F;* Macros *&#x2F;</span><br><span class="line">#define AE_NOTUSED(V) ((void) V)</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line"> * 事件处理器状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">struct aeEventLoop;</span><br><span class="line"></span><br><span class="line">&#x2F;* Types and data structures </span><br><span class="line"> *</span><br><span class="line"> * 事件接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;&#x2F;定义处理事件的接口函数</span><br><span class="line">typedef void aeFileProc(struct aeEventLoop *eventLoop, int fd, void *clientData, int mask);</span><br><span class="line">typedef int aeTimeProc(struct aeEventLoop *eventLoop, long long id, void *clientData);</span><br><span class="line">typedef void aeEventFinalizerProc(struct aeEventLoop *eventLoop, void *clientData);</span><br><span class="line">typedef void aeBeforeSleepProc(struct aeEventLoop *eventLoop);</span><br><span class="line"></span><br><span class="line">&#x2F;* File event structure</span><br><span class="line"> *</span><br><span class="line"> * 文件事件结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct aeFileEvent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 监听事件类型掩码，</span><br><span class="line">    &#x2F;&#x2F; 值可以是 AE_READABLE 或 AE_WRITABLE ，</span><br><span class="line">    &#x2F;&#x2F; 或者 AE_READABLE | AE_WRITABLE</span><br><span class="line">    int mask; &#x2F;* one of AE_(READABLE|WRITABLE) *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 读事件处理器</span><br><span class="line">    aeFileProc *rfileProc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 写事件处理器</span><br><span class="line">    aeFileProc *wfileProc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 多路复用库的私有数据</span><br><span class="line">    void *clientData;</span><br><span class="line"></span><br><span class="line">&#125; aeFileEvent;</span><br><span class="line"></span><br><span class="line">&#x2F;* Time event structure</span><br><span class="line"> *</span><br><span class="line"> * 时间事件结构</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct aeTimeEvent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 时间事件的唯一标识符</span><br><span class="line">    long long id; &#x2F;* time event identifier. *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 事件的到达时间</span><br><span class="line">    long when_sec; &#x2F;* seconds *&#x2F;</span><br><span class="line">    long when_ms; &#x2F;* milliseconds *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 事件处理函数</span><br><span class="line">    aeTimeProc *timeProc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 事件释放函数</span><br><span class="line">    aeEventFinalizerProc *finalizerProc;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 多路复用库的私有数据</span><br><span class="line">    void *clientData;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 指向下个时间事件结构，形成链表</span><br><span class="line">    struct aeTimeEvent *next;</span><br><span class="line"></span><br><span class="line">&#125; aeTimeEvent;</span><br><span class="line"></span><br><span class="line">&#x2F;* A fired event</span><br><span class="line"> *</span><br><span class="line"> * 已就绪事件</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct aeFiredEvent &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已就绪文件描述符</span><br><span class="line">    int fd;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 事件类型掩码，</span><br><span class="line">    &#x2F;&#x2F; 值可以是 AE_READABLE 或 AE_WRITABLE</span><br><span class="line">    &#x2F;&#x2F; 或者是两者的或</span><br><span class="line">    int mask;</span><br><span class="line"></span><br><span class="line">&#125; aeFiredEvent;</span><br><span class="line"></span><br><span class="line">&#x2F;* State of an event based program </span><br><span class="line"> *</span><br><span class="line"> * 事件处理器的状态</span><br><span class="line"> *&#x2F;</span><br><span class="line">typedef struct aeEventLoop &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 目前已注册的最大描述符</span><br><span class="line">    int maxfd;   &#x2F;* highest file descriptor currently registered *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 目前已追踪的最大描述符</span><br><span class="line">    int setsize; &#x2F;* max number of file descriptors tracked *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 用于生成时间事件 id</span><br><span class="line">    long long timeEventNextId;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 最后一次执行时间事件的时间</span><br><span class="line">    time_t lastTime;     &#x2F;* Used to detect system clock skew *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已注册的文件事件</span><br><span class="line">    aeFileEvent *events; &#x2F;* Registered events *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 已就绪的文件事件</span><br><span class="line">    aeFiredEvent *fired; &#x2F;* Fired events *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 时间事件</span><br><span class="line">    aeTimeEvent *timeEventHead;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 事件处理器的开关</span><br><span class="line">    int stop;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 多路复用库的私有数据</span><br><span class="line">    void *apidata; &#x2F;* This is used for polling API specific data *&#x2F;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 在处理事件前要执行的函数</span><br><span class="line">    aeBeforeSleepProc *beforesleep;</span><br><span class="line"></span><br><span class="line">&#125; aeEventLoop;</span><br><span class="line"></span><br><span class="line">&#x2F;* 定义函数模型 *&#x2F;</span><br><span class="line">aeEventLoop *aeCreateEventLoop(int setsize);</span><br><span class="line">void aeDeleteEventLoop(aeEventLoop *eventLoop);</span><br><span class="line">void aeStop(aeEventLoop *eventLoop);</span><br><span class="line">int aeCreateFileEvent(aeEventLoop *eventLoop, int fd, int mask,</span><br><span class="line">        aeFileProc *proc, void *clientData);</span><br><span class="line">void aeDeleteFileEvent(aeEventLoop *eventLoop, int fd, int mask);</span><br><span class="line">int aeGetFileEvents(aeEventLoop *eventLoop, int fd);</span><br><span class="line">long long aeCreateTimeEvent(aeEventLoop *eventLoop, long long milliseconds,</span><br><span class="line">        aeTimeProc *proc, void *clientData,</span><br><span class="line">        aeEventFinalizerProc *finalizerProc);</span><br><span class="line">int aeDeleteTimeEvent(aeEventLoop *eventLoop, long long id);</span><br><span class="line">int aeProcessEvents(aeEventLoop *eventLoop, int flags);</span><br><span class="line">int aeWait(int fd, int mask, long long milliseconds);</span><br><span class="line">void aeMain(aeEventLoop *eventLoop);</span><br><span class="line">char *aeGetApiName(void);</span><br><span class="line">void aeSetBeforeSleepProc(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep);</span><br><span class="line">int aeGetSetSize(aeEventLoop *eventLoop);</span><br><span class="line">int aeResizeSetSize(aeEventLoop *eventLoop, int setsize);</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>ae.c具体的实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* A simple event-driven programming library. Originally I wrote this code</span></span><br><span class="line"><span class="comment"> * for the Jim&#x27;s event-loop (Jim is a Tcl interpreter) but later translated</span></span><br><span class="line"><span class="comment"> * it in form of a library for easy reuse.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Copyright (c) 2006-2010, Salvatore Sanfilippo &lt;antirez at gmail dot com&gt;</span></span><br><span class="line"><span class="comment"> * All rights reserved.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Redistribution and use in source and binary forms, with or without</span></span><br><span class="line"><span class="comment"> * modification, are permitted provided that the following conditions are met:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *   * Redistributions of source code must retain the above copyright notice,</span></span><br><span class="line"><span class="comment"> *     this list of conditions and the following disclaimer.</span></span><br><span class="line"><span class="comment"> *   * Redistributions in binary form must reproduce the above copyright</span></span><br><span class="line"><span class="comment"> *     notice, this list of conditions and the following disclaimer in the</span></span><br><span class="line"><span class="comment"> *     documentation and/or other materials provided with the distribution.</span></span><br><span class="line"><span class="comment"> *   * Neither the name of Redis nor the names of its contributors may be used</span></span><br><span class="line"><span class="comment"> *     to endorse or promote products derived from this software without</span></span><br><span class="line"><span class="comment"> *     specific prior written permission.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span></span><br><span class="line"><span class="comment"> * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span></span><br><span class="line"><span class="comment"> * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE</span></span><br><span class="line"><span class="comment"> * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE</span></span><br><span class="line"><span class="comment"> * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR</span></span><br><span class="line"><span class="comment"> * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF</span></span><br><span class="line"><span class="comment"> * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS</span></span><br><span class="line"><span class="comment"> * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN</span></span><br><span class="line"><span class="comment"> * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)</span></span><br><span class="line"><span class="comment"> * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE</span></span><br><span class="line"><span class="comment"> * POSSIBILITY OF SUCH DAMAGE.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;zmalloc.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;config.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Include the best multiplexing layer supported by this system.</span></span><br><span class="line"><span class="comment"> * The following should be ordered by performances, descending. */</span></span><br><span class="line"> <span class="comment">//判断加载那个操作系统下的事件函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EVPORT</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_evport.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_EPOLL</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_epoll.c&quot;</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">ifdef</span> HAVE_KQUEUE</span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_kqueue.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae_select.c&quot;</span></span></span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 初始化事件处理器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">aeEventLoop *<span class="title">aeCreateEventLoop</span><span class="params">(<span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    aeEventLoop *eventLoop;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建事件状态结构</span></span><br><span class="line">    <span class="keyword">if</span> ((eventLoop = zmalloc(<span class="keyword">sizeof</span>(*eventLoop))) == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化文件事件结构和已就绪文件事件结构数组</span></span><br><span class="line">    eventLoop-&gt;events = zmalloc(<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zmalloc(<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;events == <span class="literal">NULL</span> || eventLoop-&gt;fired == <span class="literal">NULL</span>) <span class="keyword">goto</span> err;</span><br><span class="line">    <span class="comment">// 设置数组大小</span></span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line">    <span class="comment">// 初始化执行最近一次执行时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化时间事件结构</span></span><br><span class="line">    eventLoop-&gt;timeEventHead = <span class="literal">NULL</span>;</span><br><span class="line">    eventLoop-&gt;timeEventNextId = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line">    eventLoop-&gt;maxfd = <span class="number">-1</span>;</span><br><span class="line">    eventLoop-&gt;beforesleep = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (aeApiCreate(eventLoop) == <span class="number">-1</span>) <span class="keyword">goto</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Events with mask == AE_NONE are not set. So let&#x27;s initialize the</span></span><br><span class="line"><span class="comment">     * vector with it. */</span></span><br><span class="line">    <span class="comment">// 初始化监听事件</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回事件循环</span></span><br><span class="line">    <span class="keyword">return</span> eventLoop;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">    <span class="keyword">if</span> (eventLoop) &#123;</span><br><span class="line">        zfree(eventLoop-&gt;events);</span><br><span class="line">        zfree(eventLoop-&gt;fired);</span><br><span class="line">        zfree(eventLoop);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Return the current set size. */</span></span><br><span class="line"><span class="comment">// 返回当前事件槽大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetSetSize</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eventLoop-&gt;setsize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Resize the maximum set size of the event loop.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 调整事件槽的大小</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If the requested set size is smaller than the current set size, but</span></span><br><span class="line"><span class="comment"> * there is already a file descriptor in use that is &gt;= the requested</span></span><br><span class="line"><span class="comment"> * set size minus one, AE_ERR is returned and the operation is not</span></span><br><span class="line"><span class="comment"> * performed at all.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果尝试调整大小为 setsize ，但是有 &gt;= setsize 的文件描述符存在</span></span><br><span class="line"><span class="comment"> * 那么返回 AE_ERR ，不进行任何动作。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Otherwise AE_OK is returned and the operation is successful. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 否则，执行大小调整操作，并返回 AE_OK 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeResizeSetSize</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> setsize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (setsize == eventLoop-&gt;setsize) <span class="keyword">return</span> AE_OK;</span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd &gt;= setsize) <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    <span class="keyword">if</span> (aeApiResize(eventLoop,setsize) == <span class="number">-1</span>) <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;events = zrealloc(eventLoop-&gt;events,<span class="keyword">sizeof</span>(aeFileEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;fired = zrealloc(eventLoop-&gt;fired,<span class="keyword">sizeof</span>(aeFiredEvent)*setsize);</span><br><span class="line">    eventLoop-&gt;setsize = setsize;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure that if we created new slots, they are initialized with</span></span><br><span class="line"><span class="comment">     * an AE_NONE mask. */</span></span><br><span class="line">    <span class="keyword">for</span> (i = eventLoop-&gt;maxfd+<span class="number">1</span>; i &lt; setsize; i++)</span><br><span class="line">        eventLoop-&gt;events[i].mask = AE_NONE;</span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除事件处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteEventLoop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    aeApiFree(eventLoop);</span><br><span class="line">    zfree(eventLoop-&gt;events);</span><br><span class="line">    zfree(eventLoop-&gt;fired);</span><br><span class="line">    zfree(eventLoop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 停止事件处理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeStop</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;stop = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 根据 mask 参数的值，监听 fd 文件的状态，</span></span><br><span class="line"><span class="comment"> * 当 fd 可用时，执行 proc 函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeCreateFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeFileProc *proc, <span class="keyword">void</span> *clientData)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) &#123;</span><br><span class="line">        errno = ERANGE;</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出文件事件结构</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听指定 fd 的指定事件</span></span><br><span class="line">    <span class="keyword">if</span> (aeApiAddEvent(eventLoop, fd, mask) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置文件事件类型，以及事件的处理器</span></span><br><span class="line">    fe-&gt;mask |= mask;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) fe-&gt;rfileProc = proc;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) fe-&gt;wfileProc = proc;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    fe-&gt;clientData = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有需要，更新事件处理器的最大 fd</span></span><br><span class="line">    <span class="keyword">if</span> (fd &gt; eventLoop-&gt;maxfd)</span><br><span class="line">        eventLoop-&gt;maxfd = fd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AE_OK;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将 fd 从 mask 指定的监听队列中删除</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeDeleteFileEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd, <span class="keyword">int</span> mask)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出文件事件结构</span></span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 未设置监听的事件类型，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (fe-&gt;mask == AE_NONE) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算新掩码</span></span><br><span class="line">    fe-&gt;mask = fe-&gt;mask &amp; (~mask);</span><br><span class="line">    <span class="keyword">if</span> (fd == eventLoop-&gt;maxfd &amp;&amp; fe-&gt;mask == AE_NONE) &#123;</span><br><span class="line">        <span class="comment">/* Update the max fd */</span></span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (j = eventLoop-&gt;maxfd<span class="number">-1</span>; j &gt;= <span class="number">0</span>; j--)</span><br><span class="line">            <span class="keyword">if</span> (eventLoop-&gt;events[j].mask != AE_NONE) <span class="keyword">break</span>;</span><br><span class="line">        eventLoop-&gt;maxfd = j;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消对给定 fd 的给定事件的监视</span></span><br><span class="line">    aeApiDelEvent(eventLoop, fd, mask);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 获取给定 fd 正在监听的事件类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeGetFileEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (fd &gt;= eventLoop-&gt;setsize) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    aeFileEvent *fe = &amp;eventLoop-&gt;events[fd];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fe-&gt;mask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 取出当前时间的秒和毫秒，</span></span><br><span class="line"><span class="comment"> * 并分别将它们保存到 seconds 和 milliseconds 参数中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeGetTime</span><span class="params">(<span class="keyword">long</span> *seconds, <span class="keyword">long</span> *milliseconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"></span><br><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span><br><span class="line">    *seconds = tv.tv_sec;</span><br><span class="line">    *milliseconds = tv.tv_usec/<span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 在当前时间上加上 milliseconds 毫秒，</span></span><br><span class="line"><span class="comment"> * 并且将加上之后的秒数和毫秒数分别保存在 sec 和 ms 指针中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">aeAddMillisecondsToNow</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> milliseconds, <span class="keyword">long</span> *sec, <span class="keyword">long</span> *ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> cur_sec, cur_ms, when_sec, when_ms;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前时间</span></span><br><span class="line">    aeGetTime(&amp;cur_sec, &amp;cur_ms);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算增加 milliseconds 之后的秒数和毫秒数</span></span><br><span class="line">    when_sec = cur_sec + milliseconds/<span class="number">1000</span>;</span><br><span class="line">    when_ms = cur_ms + milliseconds%<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进位：</span></span><br><span class="line">    <span class="comment">// 如果 when_ms 大于等于 1000</span></span><br><span class="line">    <span class="comment">// 那么将 when_sec 增大一秒</span></span><br><span class="line">    <span class="keyword">if</span> (when_ms &gt;= <span class="number">1000</span>) &#123;</span><br><span class="line">        when_sec ++;</span><br><span class="line">        when_ms -= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保存到指针中</span></span><br><span class="line">    *sec = when_sec;</span><br><span class="line">    *ms = when_ms;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建时间事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">aeCreateTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeTimeProc *proc, <span class="keyword">void</span> *clientData,</span></span></span><br><span class="line"><span class="function"><span class="params">        aeEventFinalizerProc *finalizerProc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 更新时间计数器</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> id = eventLoop-&gt;timeEventNextId++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建时间事件结构</span></span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line"></span><br><span class="line">    te = zmalloc(<span class="keyword">sizeof</span>(*te));</span><br><span class="line">    <span class="keyword">if</span> (te == <span class="literal">NULL</span>) <span class="keyword">return</span> AE_ERR;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置 ID</span></span><br><span class="line">    te-&gt;id = id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设定处理事件的时间</span></span><br><span class="line">    aeAddMillisecondsToNow(milliseconds,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">    <span class="comment">// 设置事件处理器</span></span><br><span class="line">    te-&gt;timeProc = proc;</span><br><span class="line">    te-&gt;finalizerProc = finalizerProc;</span><br><span class="line">    <span class="comment">// 设置私有数据</span></span><br><span class="line">    te-&gt;clientData = clientData;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将新事件放入表头</span></span><br><span class="line">    te-&gt;next = eventLoop-&gt;timeEventHead;</span><br><span class="line">    eventLoop-&gt;timeEventHead = te;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 删除给定 id 的时间事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeDeleteTimeEvent</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">long</span> <span class="keyword">long</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aeTimeEvent *te, *prev = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 发现目标事件，删除</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id == id) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (prev == <span class="literal">NULL</span>)</span><br><span class="line">                eventLoop-&gt;timeEventHead = te-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                prev-&gt;next = te-&gt;next;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 执行清理处理器</span></span><br><span class="line">            <span class="keyword">if</span> (te-&gt;finalizerProc)</span><br><span class="line">                te-&gt;finalizerProc(eventLoop, te-&gt;clientData);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 释放时间事件</span></span><br><span class="line">            zfree(te);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> AE_OK;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> AE_ERR; <span class="comment">/* NO event with the specified ID found */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Search the first timer to fire.</span></span><br><span class="line"><span class="comment"> * This operation is useful to know how many time the select can be</span></span><br><span class="line"><span class="comment"> * put in sleep without to delay any event.</span></span><br><span class="line"><span class="comment"> * If there are no timers NULL is returned.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that&#x27;s O(N) since time events are unsorted.</span></span><br><span class="line"><span class="comment"> * Possible optimizations (not needed by Redis so far, but...):</span></span><br><span class="line"><span class="comment"> * 1) Insert the event in order, so that the nearest is just the head.</span></span><br><span class="line"><span class="comment"> *    Much better but still insertion or deletion of timers is O(N).</span></span><br><span class="line"><span class="comment"> * 2) Use a skiplist to have this operation as O(1) and insertion as O(log(N)).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 寻找里目前时间最近的时间事件</span></span><br><span class="line"><span class="comment">// 因为链表是乱序的，所以查找复杂度为 O（N）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> aeTimeEvent *<span class="title">aeSearchNearestTimer</span><span class="params">(aeEventLoop *eventLoop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    aeTimeEvent *te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    aeTimeEvent *nearest = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!nearest || te-&gt;when_sec &lt; nearest-&gt;when_sec ||</span><br><span class="line">                (te-&gt;when_sec == nearest-&gt;when_sec &amp;&amp;</span><br><span class="line">                 te-&gt;when_ms &lt; nearest-&gt;when_ms))</span><br><span class="line">            nearest = te;</span><br><span class="line">        te = te-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nearest;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process time events</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">processTimeEvents</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>;</span><br><span class="line">    aeTimeEvent *te;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> maxId;</span><br><span class="line">    <span class="keyword">time_t</span> now = time(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the system clock is moved to the future, and then set back to the</span></span><br><span class="line"><span class="comment">     * right value, time events may be delayed in a random way. Often this</span></span><br><span class="line"><span class="comment">     * means that scheduled operations will not be performed soon enough.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Here we try to detect system clock skews, and force all the time</span></span><br><span class="line"><span class="comment">     * events to be processed ASAP when this happens: the idea is that</span></span><br><span class="line"><span class="comment">     * processing events earlier is less dangerous than delaying them</span></span><br><span class="line"><span class="comment">     * indefinitely, and practice suggests it is. */</span></span><br><span class="line">    <span class="comment">// 通过重置事件的运行时间，</span></span><br><span class="line">    <span class="comment">// 防止因时间穿插（skew）而造成的事件处理混乱</span></span><br><span class="line">    <span class="keyword">if</span> (now &lt; eventLoop-&gt;lastTime) &#123;</span><br><span class="line">        te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        <span class="keyword">while</span>(te) &#123;</span><br><span class="line">            te-&gt;when_sec = <span class="number">0</span>;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新最后一次处理时间事件的时间</span></span><br><span class="line">    eventLoop-&gt;lastTime = now;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    <span class="comment">// 执行那些已经到达的事件</span></span><br><span class="line">    te = eventLoop-&gt;timeEventHead;</span><br><span class="line">    maxId = eventLoop-&gt;timeEventNextId<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(te) &#123;</span><br><span class="line">        <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> id;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跳过无效事件</span></span><br><span class="line">        <span class="keyword">if</span> (te-&gt;id &gt; maxId) &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前时间</span></span><br><span class="line">        aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果当前时间等于或等于事件的执行时间，那么说明事件已到达，执行这个事件</span></span><br><span class="line">        <span class="keyword">if</span> (now_sec &gt; te-&gt;when_sec ||</span><br><span class="line">            (now_sec == te-&gt;when_sec &amp;&amp; now_ms &gt;= te-&gt;when_ms))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> retval;</span><br><span class="line"></span><br><span class="line">            id = te-&gt;id;</span><br><span class="line">            <span class="comment">// 执行事件处理器，并获取返回值</span></span><br><span class="line">            retval = te-&gt;timeProc(eventLoop, id, te-&gt;clientData);</span><br><span class="line">            processed++;</span><br><span class="line">            <span class="comment">/* After an event is processed our time event list may</span></span><br><span class="line"><span class="comment">             * no longer be the same, so we restart from head.</span></span><br><span class="line"><span class="comment">             * Still we make sure to don&#x27;t process events registered</span></span><br><span class="line"><span class="comment">             * by event handlers itself in order to don&#x27;t loop forever.</span></span><br><span class="line"><span class="comment">             * To do so we saved the max ID we want to handle.</span></span><br><span class="line"><span class="comment">             *</span></span><br><span class="line"><span class="comment">             * FUTURE OPTIMIZATIONS:</span></span><br><span class="line"><span class="comment">             * Note that this is NOT great algorithmically. Redis uses</span></span><br><span class="line"><span class="comment">             * a single time event so it&#x27;s not a problem but the right</span></span><br><span class="line"><span class="comment">             * way to do this is to add the new elements on head, and</span></span><br><span class="line"><span class="comment">             * to flag deleted elements in a special way for later</span></span><br><span class="line"><span class="comment">             * deletion (putting references to the nodes to delete into</span></span><br><span class="line"><span class="comment">             * another linked list). */</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 记录是否有需要循环执行这个事件时间</span></span><br><span class="line">            <span class="keyword">if</span> (retval != AE_NOMORE) &#123;</span><br><span class="line">                <span class="comment">// 是的， retval 毫秒之后继续执行这个时间事件</span></span><br><span class="line">                aeAddMillisecondsToNow(retval,&amp;te-&gt;when_sec,&amp;te-&gt;when_ms);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 不，将这个事件删除</span></span><br><span class="line">                aeDeleteTimeEvent(eventLoop, id);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 因为执行事件之后，事件列表可能已经被改变了</span></span><br><span class="line">            <span class="comment">// 因此需要将 te 放回表头，继续开始执行事件</span></span><br><span class="line">            te = eventLoop-&gt;timeEventHead;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            te = te-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> processed;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Process every pending time event, then every pending file event</span></span><br><span class="line"><span class="comment"> * (that may be registered by time event callbacks just processed).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 处理所有已到达的时间事件，以及所有已就绪的文件事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Without special flags the function sleeps until some file event</span></span><br><span class="line"><span class="comment"> * fires, or when the next time event occurs (if any).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 如果不传入特殊 flags 的话，那么函数睡眠直到文件事件就绪，</span></span><br><span class="line"><span class="comment"> * 或者下个时间事件到达（如果有的话）。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * If flags is 0, the function does nothing and returns.</span></span><br><span class="line"><span class="comment"> * 如果 flags 为 0 ，那么函数不作动作，直接返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_ALL_EVENTS set, all the kind of events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_ALL_EVENTS ，所有类型的事件都会被处理。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_FILE_EVENTS set, file events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_FILE_EVENTS ，那么处理文件事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_TIME_EVENTS set, time events are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_TIME_EVENTS ，那么处理时间事件。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * if flags has AE_DONT_WAIT set the function returns ASAP until all</span></span><br><span class="line"><span class="comment"> * the events that&#x27;s possible to process without to wait are processed.</span></span><br><span class="line"><span class="comment"> * 如果 flags 包含 AE_DONT_WAIT ，</span></span><br><span class="line"><span class="comment"> * 那么函数在处理完所有不许阻塞的事件之后，即刻返回。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The function returns the number of events processed. </span></span><br><span class="line"><span class="comment"> * 函数的返回值为已处理事件的数量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeProcessEvents</span><span class="params">(aeEventLoop *eventLoop, <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> processed = <span class="number">0</span>, numevents;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Nothing to do? return ASAP */</span></span><br><span class="line">    <span class="keyword">if</span> (!(flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_FILE_EVENTS)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note that we want call select() even if there are no</span></span><br><span class="line"><span class="comment">     * file events to process as long as we want to process time</span></span><br><span class="line"><span class="comment">     * events, in order to sleep until the next time event is ready</span></span><br><span class="line"><span class="comment">     * to fire. */</span></span><br><span class="line">    <span class="keyword">if</span> (eventLoop-&gt;maxfd != <span class="number">-1</span> ||</span><br><span class="line">        ((flags &amp; AE_TIME_EVENTS) &amp;&amp; !(flags &amp; AE_DONT_WAIT))) &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        aeTimeEvent *shortest = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>, *<span class="title">tvp</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取最近的时间事件</span></span><br><span class="line">        <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS &amp;&amp; !(flags &amp; AE_DONT_WAIT))</span><br><span class="line">            shortest = aeSearchNearestTimer(eventLoop);</span><br><span class="line">        <span class="keyword">if</span> (shortest) &#123;</span><br><span class="line">            <span class="comment">// 如果时间事件存在的话</span></span><br><span class="line">            <span class="comment">// 那么根据最近可执行时间事件和现在时间的时间差来决定文件事件的阻塞时间</span></span><br><span class="line">            <span class="keyword">long</span> now_sec, now_ms;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* Calculate the time missing for the nearest</span></span><br><span class="line"><span class="comment">             * timer to fire. */</span></span><br><span class="line">            <span class="comment">// 计算距今最近的时间事件还要多久才能达到</span></span><br><span class="line">            <span class="comment">// 并将该时间距保存在 tv 结构中</span></span><br><span class="line">            aeGetTime(&amp;now_sec, &amp;now_ms);</span><br><span class="line">            tvp = &amp;tv;</span><br><span class="line">            tvp-&gt;tv_sec = shortest-&gt;when_sec - now_sec;</span><br><span class="line">            <span class="keyword">if</span> (shortest-&gt;when_ms &lt; now_ms) &#123;</span><br><span class="line">                tvp-&gt;tv_usec = ((shortest-&gt;when_ms+<span class="number">1000</span>) - now_ms)*<span class="number">1000</span>;</span><br><span class="line">                tvp-&gt;tv_sec --;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tvp-&gt;tv_usec = (shortest-&gt;when_ms - now_ms)*<span class="number">1000</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 时间差小于 0 ，说明事件已经可以执行了，将秒和毫秒设为 0 （不阻塞）</span></span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_sec &lt; <span class="number">0</span>) tvp-&gt;tv_sec = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (tvp-&gt;tv_usec &lt; <span class="number">0</span>) tvp-&gt;tv_usec = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 执行到这一步，说明没有时间事件</span></span><br><span class="line">            <span class="comment">// 那么根据 AE_DONT_WAIT 是否设置来决定是否阻塞，以及阻塞的时间长度</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">/* If we have to check for events but need to return</span></span><br><span class="line"><span class="comment">             * ASAP because of AE_DONT_WAIT we need to set the timeout</span></span><br><span class="line"><span class="comment">             * to zero */</span></span><br><span class="line">            <span class="keyword">if</span> (flags &amp; AE_DONT_WAIT) &#123;</span><br><span class="line">                <span class="comment">// 设置文件事件不阻塞</span></span><br><span class="line">                tv.tv_sec = tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">                tvp = &amp;tv;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* Otherwise we can block */</span></span><br><span class="line">                <span class="comment">// 文件事件可以阻塞直到有事件到达为止</span></span><br><span class="line">                tvp = <span class="literal">NULL</span>; <span class="comment">/* wait forever */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理文件事件，阻塞时间由 tvp 决定</span></span><br><span class="line">        numevents = aeApiPoll(eventLoop, tvp);</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; numevents; j++) &#123;</span><br><span class="line">            <span class="comment">// 从已就绪数组中获取事件</span></span><br><span class="line">            aeFileEvent *fe = &amp;eventLoop-&gt;events[eventLoop-&gt;fired[j].fd];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> mask = eventLoop-&gt;fired[j].mask;</span><br><span class="line">            <span class="keyword">int</span> fd = eventLoop-&gt;fired[j].fd;</span><br><span class="line">            <span class="keyword">int</span> rfired = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/* note the fe-&gt;mask &amp; mask &amp; ... code: maybe an already processed</span></span><br><span class="line"><span class="comment">             * event removed an element that fired and we still didn&#x27;t</span></span><br><span class="line"><span class="comment">             * processed, so we check if the event is still valid. */</span></span><br><span class="line">            <span class="comment">// 读事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_READABLE) &#123;</span><br><span class="line">                <span class="comment">// rfired 确保读/写事件只能执行其中一个</span></span><br><span class="line">                rfired = <span class="number">1</span>;</span><br><span class="line">                fe-&gt;rfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 写事件</span></span><br><span class="line">            <span class="keyword">if</span> (fe-&gt;mask &amp; mask &amp; AE_WRITABLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!rfired || fe-&gt;wfileProc != fe-&gt;rfileProc)</span><br><span class="line">                    fe-&gt;wfileProc(eventLoop,fd,fe-&gt;clientData,mask);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            processed++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Check time events */</span></span><br><span class="line">    <span class="comment">// 执行时间事件</span></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; AE_TIME_EVENTS)</span><br><span class="line">        processed += processTimeEvents(eventLoop);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> processed; <span class="comment">/* return the number of processed file/time events */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Wait for milliseconds until the given file descriptor becomes</span></span><br><span class="line"><span class="comment"> * writable/readable/exception </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 在给定毫秒内等待，直到 fd 变成可写、可读或异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">aeWait</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> mask, <span class="keyword">long</span> <span class="keyword">long</span> milliseconds)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> <span class="title">pfd</span>;</span></span><br><span class="line">    <span class="keyword">int</span> retmask = <span class="number">0</span>, retval;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;pfd, <span class="number">0</span>, <span class="keyword">sizeof</span>(pfd));</span><br><span class="line">    pfd.fd = fd;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_READABLE) pfd.events |= POLLIN;</span><br><span class="line">    <span class="keyword">if</span> (mask &amp; AE_WRITABLE) pfd.events |= POLLOUT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((retval = poll(&amp;pfd, <span class="number">1</span>, milliseconds))== <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pfd.revents &amp; POLLIN) retmask |= AE_READABLE;</span><br><span class="line">        <span class="keyword">if</span> (pfd.revents &amp; POLLOUT) retmask |= AE_WRITABLE;</span><br><span class="line">    <span class="keyword">if</span> (pfd.revents &amp; POLLERR) retmask |= AE_WRITABLE;</span><br><span class="line">        <span class="keyword">if</span> (pfd.revents &amp; POLLHUP) retmask |= AE_WRITABLE;</span><br><span class="line">        <span class="keyword">return</span> retmask;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 事件处理器的主循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeMain</span><span class="params">(aeEventLoop *eventLoop)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    eventLoop-&gt;stop = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!eventLoop-&gt;stop) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有需要在事件处理前执行的函数，那么运行它</span></span><br><span class="line">        <span class="keyword">if</span> (eventLoop-&gt;beforesleep != <span class="literal">NULL</span>)</span><br><span class="line">            eventLoop-&gt;beforesleep(eventLoop);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始处理事件</span></span><br><span class="line">        aeProcessEvents(eventLoop, AE_ALL_EVENTS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回所使用的多路复用库的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">aeGetApiName</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> aeApiName();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置处理事件前需要被执行的函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">aeSetBeforeSleepProc</span><span class="params">(aeEventLoop *eventLoop, aeBeforeSleepProc *beforesleep)</span> </span>&#123;</span><br><span class="line">    eventLoop-&gt;beforesleep = beforesleep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>3:我们可以自己写一些测试代码来测试上边的代码</p>
<p>比如接受tcp链接和监听端口的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">server</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> serLink;</span><br><span class="line">    <span class="keyword">int</span> port;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span> </span><br><span class="line">&#125; <span class="keyword">server_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpCreate</span><span class="params">(<span class="keyword">server_t</span> *ser)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//struct sockaddr_in serv_addr; // 保存服务器套接字地址信息</span></span><br><span class="line">     <span class="keyword">socklen_t</span> server_addr_size;</span><br><span class="line">     <span class="comment">//服务器端 句柄</span></span><br><span class="line">    <span class="keyword">int</span> serverHandler;</span><br><span class="line">      <span class="comment">// 创建一个TCP服务器套接字</span></span><br><span class="line">    serverHandler = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 配置套接字IP和端口信息</span></span><br><span class="line">    <span class="comment">//memset(&amp;serv_addr, 0, sizeof(serv_addr));</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;;;;;set nrtwork config\n&quot;</span>);</span><br><span class="line">    ser-&gt;serv_addr.sin_family      = AF_INET;</span><br><span class="line">    ser-&gt;serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    ser-&gt;serv_addr.sin_port        = htons(ser-&gt;port);</span><br><span class="line">    <span class="comment">// 绑定服务器套接字</span></span><br><span class="line">    server_addr_size = <span class="keyword">sizeof</span>(ser-&gt;serv_addr);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == bind(serverHandler, (struct sockaddr*) &amp;ser-&gt;serv_addr, server_addr_size ))&#123;</span><br><span class="line">         <span class="built_in">printf</span>(<span class="string">&quot;;;;;set nrtwork config fail\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听服务器套接字</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == listen(serverHandler, <span class="number">5</span>))&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;listen() error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ser-&gt;serLink = serverHandler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">TcpAccept</span><span class="params">(<span class="keyword">int</span> serLink)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clnt_addr</span>;</span> <span class="comment">// 保存客户端套接字地址信息 </span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_addr_size;   <span class="comment">// 客户端套接字地址变量的大小</span></span><br><span class="line">    clnt_addr_size = <span class="keyword">sizeof</span>(clnt_addr);</span><br><span class="line">    <span class="comment">//客户端句柄</span></span><br><span class="line">    <span class="keyword">int</span> clHandler;</span><br><span class="line">    clHandler = accept(serLink, (struct sockaddr*) &amp;clnt_addr, &amp;clnt_addr_size);</span><br><span class="line">    <span class="keyword">return</span> clHandler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建立一个test文件用来测试上边的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;tcp_connect.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ae.c&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Anti-warning macro... */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REDIS_NOTUSED(V) ((void) V)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_SIZE 1024</span></span><br><span class="line"></span><br><span class="line">aeEventLoop *eventLoop;</span><br><span class="line"><span class="keyword">server_t</span> *ser;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 读取客户端的查询缓冲区内容</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readQueryFromClient</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>]; <span class="comment">//缓存字符</span></span><br><span class="line">   <span class="keyword">int</span> nread = read(fd,buf,<span class="keyword">sizeof</span>(buf));</span><br><span class="line">   <span class="comment">// 读入出错</span></span><br><span class="line">    <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">0</span>) &#123;<span class="comment">//客户端断开链接</span></span><br><span class="line">        aeDeleteFileEvent(el, fd, AE_READABLE);</span><br><span class="line">        close(fd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接受客户端链接</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">acceptTcpHandler</span><span class="params">(aeEventLoop *el, <span class="keyword">int</span> fd, <span class="keyword">void</span> *privdata, <span class="keyword">int</span> mask)</span> </span>&#123;</span><br><span class="line">    REDIS_NOTUSED(el);</span><br><span class="line">    REDIS_NOTUSED(mask);</span><br><span class="line">    REDIS_NOTUSED(privdata);</span><br><span class="line">    <span class="keyword">int</span> clientFd;</span><br><span class="line">    clientFd = TcpAccept(fd);</span><br><span class="line">    aeCreateFileEvent(eventLoop, clientFd, AE_READABLE, readQueryFromClient, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    eventLoop = aeCreateEventLoop(MAX_SIZE);</span><br><span class="line">    ser = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">server_t</span>));</span><br><span class="line">    <span class="built_in">memset</span>(&amp;ser-&gt;serv_addr, <span class="number">0</span>, <span class="keyword">sizeof</span>(ser-&gt;serv_addr));</span><br><span class="line">    ser-&gt;port = <span class="number">3336</span>;</span><br><span class="line">    TcpCreate(ser);</span><br><span class="line">    aeCreateFileEvent(eventLoop, ser-&gt;serLink, AE_READABLE, acceptTcpHandler, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;端口开启%d&quot;</span>,ser-&gt;port);</span><br><span class="line">    aeMain(eventLoop);</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    start();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用gcc编译过后，可以连接到监听的端口。使用telnet命令链接测试</p>
]]></content>
      <categories>
        <category>cache</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁</title>
    <url>/2019/04/21/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/</url>
    <content><![CDATA[<p><strong>分布式锁解决并发的三种实现方式</strong></p>
<ul>
<li>在很多场景中，我们为了保证数据的最终一致性，需要很多的技术方案来支持，比如分布式事务、分布式锁等。有的时候，我们需要保证一个方法在同 一时间内只能被同一个线程执行。在单机环境中，Java中其实提供了很多并发处理相关的API，但是这些API在分布式场景中就无能为力了。也就是说单纯的Java Api并不能提供分布式锁的能力。所以针对分布式锁的实现目前有多种方案：</li>
</ul>
<p>分布式锁一般有三种实现方式：</p>
<ul>
<li><ul>
<li>1、 <strong>数据库锁</strong></li>
<li>2、<strong>基于Redis的分布式锁</strong></li>
<li>3、<strong>基于ZooKeeper的分布式锁</strong></li>
</ul>
</li>
</ul>
<p>分布式锁应该是怎么样的<span id="more"></span></p>
<ul>
<li>互斥性 可以保证在分布式部署的应用集群中，同一个方法在同一时间只能被一台机器上的一个线程执行。</li>
<li>这把锁要是一把可重入锁（避免死锁）</li>
<li>不会发生死锁：有一个客户端在持有锁的过程中崩溃而没有解锁，也能保证其他客户端能够加锁</li>
<li>这把锁最好是一把阻塞锁（根据业务需求考虑要不要这条）</li>
<li>有高可用的获取锁和释放锁功能</li>
<li>获取锁和释放锁的性能要好</li>
</ul>
<p><strong>1、数据库锁</strong></p>
<ul>
<li><p>基于数据库表</p>
</li>
<li><ul>
<li>要实现分布式锁，最简单的方式可能就是直接创建一张锁表，然后通过操作该表中的数据来实现了。</li>
<li>当我们要锁住某个方法或资源时，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。</li>
</ul>
</li>
</ul>
<p>​    <img src="/images/youdao/2036.png" alt="0"></p>
<p>当我们想要锁住某个方法时，执行以下SQL：</p>
<p>​    <img src="/images/youdao/2038.png" alt="0"></p>
<p>因为我们对method_name做了唯一性约束，这里如果有多个请求同时提交到数据库的话，数据库会保证只有一个操作可以成功，那么我们就可以认为</p>
<p>操作成功的那个线程获得了该方法的锁，可以执行方法体内容。</p>
<p>当方法执行完毕之后，想要释放锁的话，需要执行以下Sql:</p>
<p>​    <img src="/images/youdao/2040.png" alt="0"></p>
<ul>
<li><ul>
<li>上面这种简单的实现有以下几个问题：</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>1、这把锁强依赖数据库的可用性，数据库是一个单点，一旦数据库挂掉，会导致业务系统不可用。</li>
<li>2、这把锁没有失效时间，一旦解锁操作失败，就会导致锁记录一直在数据库中，其他线程无法再获得到锁。</li>
<li>3、这把锁只能是非阻塞的，因为数据的insert操作，一旦插入失败就会直接报错。没有获得锁的线程并不会进入排队队列，要想再次获得锁就要再次触发获得锁操作。</li>
<li>4、这把锁是非重入的，同一个线程在没有释放锁之前无法再次获得该锁。因为数据中数据已经存在了。</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li>当然，我们也可以有其他方式解决上面的问题。</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>数据库是单点？搞两个数据库，数据之前双向同步。一旦挂掉快速切换到备库上。</li>
<li>没有失效时间？只要做一个定时任务，每隔一定时间把数据库中的超时数据清理一遍。</li>
<li>非阻塞的？搞一个while循环，直到insert成功再返回成功。</li>
<li>非重入的？在数据库表中加个字段，记录当前获得锁的机器的主机信息和线程信息，那么下次再获取锁的时候先查询数据库，如果当前机器的主机信息和线程信息在数据库可以查到的话，直接把锁分配给他就可以了。</li>
</ul>
</li>
</ul>
</li>
<li><p>基于数据库的排它锁</p>
</li>
</ul>
<p>除了可以通过增删操作数据表中的记录以外，其实还可以借助数据库中自带的锁来实现分布式的锁。</p>
<p>我们还用刚刚创建的那张数据库表。可以通过数据库的排他锁来实现分布式锁。</p>
<p>在查询语句后面增加for update，数据库会在查询过程中给数据库表增加排他锁。当某条记录被加上排他锁之后，其他线程无法再在该行记录上增加排他锁。</p>
<p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<p>我们可以认为获得排它锁的线程即可获得分布式锁，当获取到锁之后，可以执行方法的业务逻辑，执行完方法之后，再通过以下方法解锁：</p>
<p>public void unlock(){      connection.commit(); }</p>
<p>通过connection.commit()操作来释放锁。</p>
<p>这种方法可以有效的解决上面提到的无法释放锁和阻塞锁的问题。</p>
<ul>
<li><ul>
<li>阻塞锁？ for update语句会在执行成功后立即返回，在执行失败时一直处于阻塞状态，直到成功。</li>
<li>锁定之后服务宕机，无法释放？使用这种方式，服务宕机之后数据库会自己把锁释放掉。</li>
</ul>
</li>
</ul>
<p>但是还是无法直接解决数据库单点和可重入问题。</p>
<ul>
<li><p>总结：</p>
</li>
<li><ul>
<li>总结一下使用数据库来实现分布式锁的方式，这两种方式都是依赖数据库的一张表，一种是通过表中的记录的存在情况确定当前是否有锁存在，另外一种是通过数据库的排他锁来实现分布式锁。</li>
<li>数据库实现分布式锁的优点: 直接借助数据库，容易理解。</li>
<li>数据库实现分布式锁的缺点: 会有各种各样的问题，在解决问题的过程中会使整个方案变得越来越复杂。</li>
<li>操作数据库需要一定的开销，性能问题需要考虑。</li>
</ul>
</li>
</ul>
<p><strong>1.1、乐观锁</strong></p>
<ul>
<li><p>乐观锁假设认为数据一般情况下不会造成冲突，只有在进行数据的提交更新时，才会检测数据的冲突情况，如果发现冲突了，则返回错误信息</p>
</li>
<li><p>实现方式：</p>
</li>
<li><ul>
<li>时间戳（timestamp）记录机制实现：给数据库表增加一个时间戳字段类型的字段，当读取数据时，将timestamp字段的值一同读出，数据每更新一次，timestamp也同步更新。当对数据做提交更新操作时，检查当前数据库中数据的时间戳和自己更新前取到的时间戳进行对比，若相等，则更新，否则认为是失效数据。</li>
<li>若出现更新冲突，则需要上层逻辑修改，启动重试机制</li>
<li>同样也可以使用version的方式。</li>
</ul>
</li>
<li><p>性能对比</p>
</li>
<li><ul>
<li>1、悲观锁实现方式是独占数据，其它线程需要等待，不会出现修改的冲突，能够保证数据的一致性，但是依赖数据库的实现，且在线程较多时出现等待造成效率降低的问题。一般情况下，对于数据很敏感且读取频率较低的场景，可以采用悲观锁的方式</li>
<li>2、 乐观锁可以多线程同时读取数据，若出现冲突，也可以依赖上层逻辑修改，能够保证高并发下的读取，适用于读取频率很高而修改频率较少的场景</li>
<li>3、 由于库存回写数据属于敏感数据且读取频率适中，所以建议使用悲观锁优化</li>
</ul>
</li>
</ul>
<p><strong>2、基于redis的分布式锁</strong></p>
<ul>
<li>相比较于基于数据库实现分布式锁的方案来说，基于缓存来实现在性能方面会表现的更好一点。而且很多缓存是可以集群部署的，可以解决单点问题。</li>
</ul>
<p>-首先，为了确保分布式锁可用，我们至少要确保锁的实现同时满足以下四个条件：</p>
<ul>
<li>互斥性。在任意时刻，只有一个客户端能持有锁。</li>
<li>不会发生死锁。即使有一个客户端在持有锁的期间崩溃而没有主动解锁，也能保证后续其他客户端能加锁。</li>
<li>具有容错性。只要大部分的Redis节点正常运行，客户端就可以加锁和解锁。</li>
<li>解铃还须系铃人。加锁和解锁必须是同一个客户端，客户端自己不能把别人加的锁给解了。</li>
</ul>
<p>可以看到，我们加锁就一行代码：==jedis.set(String key, String value, String nxxx, String expx, int time)==，这个set()方法一共有五个形参：</p>
<ul>
<li>第一个为key，我们使用key来当锁，因为key是唯一的。</li>
<li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li>
<li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li>
<li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li>
<li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li>
</ul>
<p>总的来说，执行上面的set()方法就只会导致两种结果：1. 当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。2. 已有锁存在，不做任何操作。</p>
<p>加锁代码满足我们可靠性里描述的三个条件。首先，set()加入了NX参数，可以保证如果已有key存在，则函数不会调用成功，也就是只有一个客户端能持有锁，满足互斥性。其次，由于我们对锁设置了过期时间，即使锁的持有者后续发生崩溃而没有解锁，锁也会因为到了过期时间而自动解锁（即key被删除），不会发生死锁。最后，因为我们将value赋值为requestId，代表加锁的客户端请求标识，那么在客户端在解锁的时候就可以进行校验是否是同一个客户端。由于我们只考虑Redis单机部署的场景，所以容错性我们暂不考虑。</p>
<p><strong>错误实例</strong></p>
<ul>
<li>使用jedis.setnx()和jedis.expire()组合实现加锁</li>
</ul>
<p>​    <img src="/images/youdao/2042.png" alt="0"></p>
<p>image</p>
<p>setnx()方法作用就是SET IF NOT EXIST，expire()方法就是给锁加一个过期时间。乍一看好像和前面的set()方法结果一样，然而由于这是两条Redis命令，不具有原子性，如果程序在执行完setnx()之后突然崩溃，导致锁没有设置过期时间。那么将会发生死锁。网上之所以有人这样实现，是因为低版本的jedis并不支持多参数的set()方法。</p>
<ul>
<li><p>解锁：</p>
</li>
<li><ul>
<li>首先获取锁对应的value值，检查是否与requestId相等，如果相等则删除锁（解锁）</li>
<li>使用缓存实现分布式锁的优点</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>性能好，实现起来较为方便。</li>
<li>使用缓存实现分布式锁的缺点</li>
<li>通过超时时间来控制锁的失效时间并不是十分的靠谱。</li>
</ul>
</li>
</ul>
</li>
<li><p>总结：</p>
</li>
<li><ul>
<li>可以使用缓存来代替数据库来实现分布式锁，这个可以提供更好的性能，同时，很多缓存服务都是集群部署的，可以避免单点问题。并且很多缓存服务都提供了可以用来实现分布式锁的方法，比如redis的setnx方法等。并且，这些缓存服务也都提供了对数据的过期自动删除的支持，可以直接设置超时时间来控制锁的释放。</li>
</ul>
</li>
</ul>
<p><strong>3、基于Zookeeper实现分布式锁</strong></p>
<ul>
<li><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想即为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。</p>
</li>
<li><p>完成业务流程后，删除对应的子节点释放锁。</p>
</li>
<li><p>来看下Zookeeper能不能解决前面提到的问题。</p>
</li>
<li><ul>
<li><strong>锁无法释放</strong>？使用Zookeeper可以有效的解决锁无法释放的问题，因为在创建锁的时候，客户端会在ZK中创建一个临时节点，一旦客户端获取到锁之后突然挂掉（Session连接断开），那么这个临时节点就会自动删除掉。其他客户端就可以再次获得锁。</li>
<li><strong>非阻塞锁</strong>？使用Zookeeper可以实现阻塞的锁，客户端可以通过在ZK中创建顺序节点，并且在节点上绑定监听器，一旦节点有变化，Zookeeper会通知客户端，客户端可以检查自己创建的节点是不是当前所有节点中序号最小的，如果是，那么自己就获取到锁，便可以执行业务逻辑了。</li>
<li><strong>不可重入</strong>？使用Zookeeper也可以有效的解决不可重入的问题，客户端在创建节点的时候，把当前客户端的主机信息和线程信息直接写入到节点中，下次想要获取锁的时候和当前最小的节点中的数据比对一下就可以了。如果和自己的信息一样，那么自己直接获取到锁，如果不一样就再创建一个临时的顺序节点，参与排队。</li>
<li><strong>单点问题</strong>？使用Zookeeper可以有效的解决单点问题，ZK是集群部署的，只要集群中有半数以上的机器存活，就可以对外提供服务。</li>
</ul>
</li>
<li><p>可以直接使用zookeeper第三方库Curator客户端，这个客户端中封装了一个可重入的锁服务。</p>
</li>
<li><p>Zookeeper实现的分布式锁其实存在一个缺点，那就是性能上可能并没有缓存服务那么高。</p>
</li>
<li><ul>
<li>因为每次在创建锁和释放锁的过程中，都要动态创建、销毁瞬时节点来实现锁功能。ZK中创建和删除节点只能通过Leader服务器来执行，然后将数据同不到所有的Follower机器上。</li>
</ul>
</li>
<li><p>使用Zookeeper实现分布式锁的优点: 有效的解决单点问题，不可重入问题，非阻塞问题以及锁无法释放的问题。实现起来较为简单。</p>
</li>
<li><p>使用Zookeeper实现分布式锁的缺点 : 性能上不如使用缓存实现分布式锁。 需要对ZK的原理有所了解。</p>
</li>
</ul>
<p>​    <img src="/images/youdao/2044.png" alt="0"></p>
<p><strong>4、三种方案的比较</strong></p>
<ul>
<li>从理解的难易程度角度（从低到高）: 数据库 &gt; 缓存 &gt; Zookeeper</li>
<li>从实现的复杂性角度（从低到高）: Zookeeper &gt;= 缓存 &gt; 数据库</li>
<li>从性能角度（从高到低）: 缓存 &gt; Zookeeper &gt;= 数据库</li>
<li>从可靠性角度（从高到低）: Zookeeper &gt; 缓存 &gt; 数据库</li>
</ul>
<p><strong>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</strong></p>
]]></content>
      <categories>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>事务及事务隔离性</title>
    <url>/2021/04/20/%E4%BA%8B%E5%8A%A1%E5%8F%8A%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%80%A7/</url>
    <content><![CDATA[<p>事务的几个概念：</p>
<p>​    A（atomicity）原子性</p>
<p>​        是指，一个事务里的多条SQL命令要么全部执行，要么全部不执行。</p>
<p>   C（consistency）一致性</p>
<p>​         数据更改状态：及如果数据更新成功，要和预期值一致，如果失败要保持到更新之前的状态不变。</p>
<p>   I (isolation) 隔离性</p>
<p>​        事务的隔离性要求每个读写事务的对象对其他事务的操作对象能相互分离，即该事务提交前对其他事务都不可见，通常这使用锁来实现</p>
<p>   D(isolation)持久性</p>
<span id="more"></span>
<p>​        事务一旦提交，其结果就是永久性的。即使发生宕机等故障，数据库也能将数据恢复。需要注意的是，只能从事务本身的角度来保证结果的永久性。例如，在事务提交后，所有的变化都是永久的。即使当数据库因为崩溃而需要恢复时，也能保证恢复后提交的数据都不会丢失。但若不是数据库本身发生故障，而是一些外部的原因，如RAID卡损坏、自然灾害等原因导致数据库发生问题，那么所有提交的数据可能都会丢失。因此持久性保证事务系统的高可靠性（High Reliability），而不是高可用性（High Availability）。对于高可用性的实现，事务本身并不能保证，需要一些系统共同配合来完成。<!--more--></p>
<p>伴随事务产生的几个概念：（通过锁定机制可以实现事务的隔离性要求，使得事务可以并发地工作。锁也带来问题。）</p>
<p>​    脏读：是指一个事务读取到了另外一个事务未提交的数据【也称为脏数据】则显然违反了数据库的隔离性。</p>
<p>   幻读：在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL语句可能会返回之前不存在的行。既是，一个事务读取到另外一个事务提交的数据。导致记录数不一致，这种问题在read-commited提交读下会产生，在MySQL的REPEATABLE READ下一般不会产生，InnoDB存储引擎采用Next-Key Locking的算法避免Phantom Problem。对于上述的SQL语句SELECT*FROM t WHERE a＞2 FOR UPDATE，其锁住的不是5这单个值，而是对（2，+∞）这个范围加了X锁。因此任何对于这个范围的插入都是不被允许的，从而避免了部分Phantom Problem。</p>
<p>   不可重复读：不可重复读是指在一个事务内多次读取同一数据集合。在这个事务还没有结束时，另外一个事务也访问该同一数据集合，并做了一些DML操作。因此，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的情况，这种情况称为不可重复读。违反了事务隔离性。</p>
<p>PS：从《MySQL技术内幕：InnoDB存储引擎》 一书看，不可重复读和幻读应该是一个意思。网上有资料说：幻读能读取到新的记录（多次读取一个范围内的记录，记录可能增加减少】，不可能重复读特指，同一行【或者同一集合内的数据多次读取，值会不一样】。</p>
<p>​        </p>
<p>​        </p>
<p>事务的4种隔离级别：</p>
<p>read uncommitted：未提交读。会产生脏读【是指未提交的数据，如果读到了脏数据，即一个事务可以读到另外一个事务中未提交的数据，则显然违反了数据库的隔离性。】，不可重复读问题。</p>
<p>​       既是，一个事务能获取到另外一个事务未提交的数据。违反了事务的隔离性.</p>
<p>​       需要注意的一点事，即使在未提交读级别下，对于同一行的修改，多个事务之间也会对行加锁，先获得锁先执行，后续执行，不会造成事务之间的丢失更新问题。</p>
<table>
<thead>
<tr>
<th>1:设置为未提交读隔离级别</th>
<th>事务1：set @@tx_isolation=’read-uncommitted’;</th>
<th>事务2：set @@tx_isolation=’read-uncommitted’;</th>
</tr>
</thead>
<tbody><tr>
<td>2:</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 13   |    1 |+—-+——+——+</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4</td>
<td></td>
<td>update user set name=14 where id=1;</td>
</tr>
<tr>
<td>5:此时事务1读取到了事务2未提交的修改，违反了事务隔离性原则</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 14   |    1 |+—-+——+——+</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>COMMIT;</td>
<td>COMMIT;</td>
</tr>
</tbody></table>
<p>read committed：提交读。避免了脏读，会产生不可重复读和幻读问题。</p>
<p>​       既是，一个事务能获取到另外一个事务提交的数据。</p>
<table>
<thead>
<tr>
<th>1:设置为未提交读隔离级别</th>
<th>事务1：set @@tx_isolation=’read-committed’;</th>
<th>事务2：set @@tx_isolation=’read-committed’;</th>
</tr>
</thead>
<tbody><tr>
<td>2:</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 13   |    1 |+—-+——+——+</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4：更新并且提交数据</td>
<td></td>
<td>update user set name=14 where id=1;COMMIT;</td>
</tr>
<tr>
<td>5:此时事务1读取到了事务2提交的修改，违反了事务隔离性原则</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 14   |    1 |+—-+——+——+</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>COMMIT;</td>
<td></td>
</tr>
</tbody></table>
<p>REPEATABLE READ：可重复读。避免了脏读，不可重复读，【MySQL可以说避免了幻读】</p>
<p>​      既另外一个事务对数据的更新及提交，不会造成现有事务多次读取的状态变化。</p>
<table>
<thead>
<tr>
<th>1:设置为未提交读隔离级别</th>
<th>事务1：set @@tx_isolation=’ REPEATABLE-READ’;</th>
<th>事务2：set @@tx_isolation=’ REPEATABLE-READ’;</th>
</tr>
</thead>
<tbody><tr>
<td>2:</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 15   |    1 |+—-+——+——+</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4：更新并且提交数据</td>
<td></td>
<td>update user set name=name+1 where id=1;COMMIT;</td>
</tr>
<tr>
<td>5:此时事务1读取的数据状态不变</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 15   |    1 |+—-+——+——+</td>
<td></td>
</tr>
<tr>
<td>6：事务1:进行数据更新</td>
<td>update user set name=name+1 where id=1;</td>
<td></td>
</tr>
<tr>
<td>7：事务1再次查询:值变为17，说明值的更新是依据两外一个事务已提交的数据更新，不会造成更新丢失。</td>
<td>select * from user where id=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 17   |    1 |+—-+——+——+</td>
<td></td>
</tr>
<tr>
<td></td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>  MySQL在此级别可以避免幻读的出现。</p>
<table>
<thead>
<tr>
<th>1:设置为未提交读隔离级别</th>
<th>事务1：set @@tx_isolation=’ REPEATABLE-READ’;</th>
<th>事务2：set @@tx_isolation=’ REPEATABLE-READ’;</th>
</tr>
</thead>
<tbody><tr>
<td>2:</td>
<td>BEGIN;</td>
<td></td>
</tr>
<tr>
<td>3</td>
<td>select * from user where sex=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 18   |    1 ||  2 | 22   |    1 |+—-+——+——+</td>
<td>BEGIN;</td>
</tr>
<tr>
<td>4：更新并且提交数据</td>
<td></td>
<td>insert user (id,name,sex) values (4,’22’,1);COMMIT;</td>
</tr>
<tr>
<td>5:此时事务1读取的数据条数不变</td>
<td>select * from user where sex=1;+—-+——+——+| id | name | sex  |+—-+——+——+|  1 | 18   |    1 ||  2 | 22   |    1 |+—-+——+——+</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>commit;</td>
<td></td>
</tr>
</tbody></table>
<p>SERIALIABLE：序列化</p>
<p>在SERIALIABLE的事务隔离级别，InnoDB存储引擎会对每个SELECT语句后自动加上LOCK IN SHARE MODE，即为每个读取操作加一个共享锁。因此在这个事务隔离级别下，读占用了锁，对一致性的非锁定读不再予以支持。这时，事务隔离级别SERIALIZABLE符合数据库理论上的要求，即事务是well-formed的，并且是two-phrased的。</p>
<!--more-->
]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>线程同步</title>
    <url>/2021/04/20/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<p>一个进程是一个独立的程序运行单位【如运行的QQ程序等】：包括了运行是的一切资源如内存，编译好的二进制代码，寄存器，堆践等等。在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>
<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程。<span id="more"></span></p>
<p>线程是最小的逻辑执行单元，只有在运行的时候才会有自身的寄存器【CPU缓存区】等等。一个进程可以拥有多个线程。这些线程调度有系统调度执行，所以访问共享资源的时候都要加锁。</p>
<ul>
<li>读：当一个线程修改变量的时候，另外一个变量读取变量就可能会造成数据不一致。因为在写操作需要两个存储器周期时间，需要先把数据写到寄存器，然后刷新到内存区域。如果另外的线程在写操作区间就会出现数据不一致【一个新值，一个老的值】。</li>
</ul>
<p><img src="/images/youdao/6370.png"> </p>
<ul>
<li>写：当多个线程在同一时间修改同一个变量的时候也是需要进行同步。</li>
</ul>
<p>​         一个变量的增值操作：</p>
<p>​             1：从内存读取到寄存器</p>
<p>​             2：在寄存器进行变量的增值操作</p>
<p>​             3：把变量写入到内存区域</p>
<p><img src="/images/youdao/6377.png"></p>
<p>而线程同步的本质是保证一个线程顺序执行，不被中断。线程的同步需要</p>
<p><strong>线程同步的一些方法：</strong></p>
<p>   1： Pthread提供的互斥量：互斥量本质来说是一把锁，保证在同一时间内容只有以线程可以访问数据。在访问共享资源之前加锁，访问之后解锁。加锁后，任何其他试图再次加锁的线程会被阻塞。直到当前线程解锁：</p>
<p>​           使用时会造成死锁。【<strong>死锁是指一个资源被多次调用，而多次调用方都未能释放该资源就会造成一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁。</strong>】</p>
<p>​           1.1：同一个线程对于同一个互斥量不能加锁两次【必须是加锁解锁操作，不能是加锁加锁操作】，否则会造成死锁。</p>
<p>​           1.2：多互斥量下的互相等待：既线程A锁住了互斥量A此时要锁住互斥量B，线程B锁住了互斥量B，想要锁住互斥量A，造成线程间的互相等待。</p>
<p>​          1.3：Java 的 synchronized 重量级锁依赖于操作系统的互斥量（mutex） 实现</p>
<p>​          Java死锁的例子：</p>
<pre><code>            <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">        <span class="keyword">this</span>.value += m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">            <span class="keyword">this</span>.another += m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dec</span><span class="params">(<span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(lockB) &#123; <span class="comment">// 获得lockB的锁</span></span><br><span class="line">        <span class="keyword">this</span>.another -= m;</span><br><span class="line">        <span class="keyword">synchronized</span>(lockA) &#123; <span class="comment">// 获得lockA的锁</span></span><br><span class="line">            <span class="keyword">this</span>.value -= m;</span><br><span class="line">        &#125; <span class="comment">// 释放lockA的锁</span></span><br><span class="line">    &#125; <span class="comment">// 释放lockB的锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
<p>​            </p>
<p>​         在获取多个锁的时候，不同线程获取多个不同对象的锁可能导致死锁。对于上述代码，线程1和线程2如果分别执行add()和dec()方法时：</p>
<ul>
<li>线程1：进入add()，获得lockA；</li>
<li>线程2：进入dec()，获得lockB。</li>
</ul>
<p>随后：</p>
<ul>
<li>线程1：准备获得lockB，失败，等待中；</li>
<li>线程2：准备获得lockA，失败，等待中。</li>
</ul>
<p>此时，两个线程各自持有不同的锁，然后各自试图获取对方手里的锁，造成了双方无限等待下去，这就是死锁。</p>
<p>死锁发生后，没有任何机制能解除死锁，只能强制结束JVM进程。</p>
<p>因此，在编写多线程应用时，要特别注意防止死锁。因为死锁一旦形成，就只能强制结束进程。</p>
<p>那么我们应该如何避免死锁呢？答案是：线程获取锁的顺序要一致。即严格按照先获取lockA，再获取lockB的顺序，改写dec()方法如下：</p>
<pre><code>           <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void dec(int m) &#123;</span><br><span class="line">    synchronized(lockA) &#123; &#x2F;&#x2F; 获得lockA的锁</span><br><span class="line">        this.value -&#x3D; m;</span><br><span class="line">        synchronized(lockB) &#123; &#x2F;&#x2F; 获得lockB的锁</span><br><span class="line">            this.another -&#x3D; m;</span><br><span class="line">        &#125; &#x2F;&#x2F; 释放lockB的锁</span><br><span class="line">    &#125; &#x2F;&#x2F; 释放lockA的锁</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</code></pre>
<p>2： 自旋锁</p>
<p>自旋锁的主要特征是使用者在想要获得临界区执行权限时，如果临界区已经被加锁，那么自旋锁并不会阻塞睡眠【互斥量会阻塞】，等待系统来主动唤醒，而是原地忙轮询资源是否被释放加锁，自旋就是自我旋转，这个名字还是很形象的。自旋锁有它的优点就是避免了系统的唤醒，自己来执行轮询，如果在临界区的资源代码非常短且是原子的，那么使用起来是非常方便的，避免了各种上下文切换，开销非常小，因此在内核的一些数据结构中自旋锁被广泛的使用。</p>
<p>​         1：自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>​        </p>
<p><img src="/images/youdao/6431.png"></p>
<p>3：读写锁rwlock</p>
<p>读写锁也叫共享互斥锁：读模式共享和写模式互斥，本质上这种非常合理，因为在数据没有被写的前提下，多个使用者读取时完全不需要加锁的。读写锁有读加锁状态、写加锁状态和不加锁状态三种状态，当读写锁在写加锁模式下，任何试图对这个锁进行加锁的线程都会被阻塞，直到写进程对其解锁。</p>
<p><em>读优先的读写锁</em>：读写锁rwlock默认的也是读优先，也就是:当读写锁在读加锁模式先，任何线程都可以对其进行读加锁操作，但是所有试图进行写加锁操作的线程都会被阻塞，直到所有的读线程都解锁，因此读写锁很适合读次数远远大于写的情况。这种情况需要考虑写饥饿问题，也就是大量的读一直轮不到写，因此需要设置公平的读写策略。在一次面试中曾经问到实现一个写优先级的读写锁，感兴趣的可以想想如何实现。</p>
<p>4：可重入锁和不可重入锁</p>
<p>​      Mutex可以分为递归锁（recursive mutex）【可重入锁】和非递归锁（non-recursive mutex）【不可重入锁】。 递归锁也叫可重入锁（reentrant mutex），非递归锁也叫不可重入锁（non-reentrant mutex）。</p>
<p>   二者唯一的<strong>区别</strong>是：</p>
<p>​      同一个线程可以多次获取同一个递归锁，不会产生死锁。</p>
<p>​      如果一个线程多次获取同一个非递归锁，则会产生死锁。</p>
<p>   Windows下的Mutex和Critical Section是可递归的。 </p>
<p>   Linux下的pthread_mutex_t锁是默认是非递归的。可以通过设置PTHREAD_MUTEX_RECURSIVE属性，将pthread_mutex_t锁设置为递归锁。</p>
<p>关于锁常见的名词的概念解锁：</p>
<p>​     1：悲观锁和乐观锁</p>
<p>乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。</p>
<p>先说概念。对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。Java中，synchronized关键字和Lock的实现类都是悲观锁。</p>
<p>而乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。如果这个数据没有被更新，当前线程将自己修改的数据成功写入。如果数据已经被其他线程更新，则根据不同的实现方式执行不同的操作（例如报错或者自动重试）。</p>
<p>乐观锁在Java中是通过使用无锁编程来实现，最常采用的是CAS算法，Java原子类中的递增操作就通过CAS自旋实现的 </p>
<p><img src="/images/youdao/6461.png"></p>
<p>2：</p>
<p>3:参考</p>
<p><a href="https://zhuanlan.zhihu.com/p/88241719">https://zhuanlan.zhihu.com/p/88241719</a> 锁概述</p>
<p><a href="https://www.xuebuyuan.com/3255731.html">https://www.xuebuyuan.com/3255731.html</a> Linux互斥锁 概述</p>
<p><a href="https://www.cnblogs.com/bigberg/p/7910024.html">https://www.cnblogs.com/bigberg/p/7910024.html</a></p>
<p><a href="https://tech.meituan.com/2018/11/15/java-lock.html">https://tech.meituan.com/2018/11/15/java-lock.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>联合索引的排序</title>
    <url>/2021/04/20/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E7%9A%84%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>联合索引的多字段排序的时候，是不可以夸字段排序，首字段也不能取范围的值。</p>
<span id="more"></span>
<p>表结构:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `rank` (</span><br><span class="line">  `fetch_hour` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;0&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `times` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;1&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `uid` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `live_id` <span class="type">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `reward` <span class="type">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `rank` <span class="type">int</span>(<span class="number">10</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `shop_tags` <span class="type">varchar</span>(<span class="number">255</span>) <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `rank_type` tinyint(<span class="number">4</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;12&#x27;</span> COMMENT <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">  `created_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  `updated_at` <span class="type">timestamp</span> <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> UPDATE <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`rank_type`,`fetch_hour`,`times`,`uid`),</span><br><span class="line">  KEY `rank_type_fetch_hour` (`rank_type`,`fetch_hour`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>执行：explain select * from <code>rank where </code>fetch_hour<code>= &#39;2021022511&#39; and rank_type=12 order by </code>times<code>,</code>uid` desc limit 1;</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">	<span class="attr">&quot;data&quot;</span>:</span><br><span class="line">	[</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="attr">&quot;id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">			<span class="attr">&quot;select_type&quot;</span>: <span class="string">&quot;SIMPLE&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;table&quot;</span>: <span class="string">&quot;rank&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;partitions&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">			<span class="attr">&quot;type&quot;</span>: <span class="string">&quot;ref&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;possible_keys&quot;</span>: <span class="string">&quot;PRIMARY,rank_type_fetch_hour&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;key&quot;</span>: <span class="string">&quot;PRIMARY&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;key_len&quot;</span>: <span class="string">&quot;5&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;ref&quot;</span>: <span class="string">&quot;const,const&quot;</span>,</span><br><span class="line">			<span class="attr">&quot;rows&quot;</span>: <span class="number">693</span>,</span><br><span class="line">			<span class="attr">&quot;filtered&quot;</span>: <span class="number">100</span>,</span><br><span class="line">			<span class="attr">&quot;Extra&quot;</span>: <span class="string">&quot;Using where; Using filesort&quot;</span></span><br><span class="line">		&#125;</span><br><span class="line">	]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Using filesort表示为内存排序，而没有使用到索引。因为联合索引都是一个一个分离的B+树索引。比方说联合索引 (col1, col2,col3)，我知道在逻辑上是先按照col1进行排序再按照col2进行排序最后再按照col3进行排序。引文使用了两个字段排序，虽然排序顺序一样，但是因为第一个字段是个范围值，MySQL需要聚合到所有数据在内存排序，也就是能保证times是顺序的，但是又要按照uid排序需要组合后在排序。同理能看出如果是排序是按照最左原则，<strong>在最后一个字段排序，且只是用一个字段排序是有效的，且不能夸字段</strong>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col1 <span class="operator">&lt;</span> xx <span class="keyword">order</span> <span class="keyword">by</span> col可以索引使用排序。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col1 <span class="operator">&lt;</span> xx <span class="keyword">order</span> <span class="keyword">by</span> col2 不可以使用索引排序。</span><br><span class="line">但是前边是定值的是可以排序：【MySQL在存储的按照col1进行排序再按照col2进行排序最后再按照col3进行排序】</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col1 <span class="operator">=</span><span class="operator">=</span> xx <span class="keyword">order</span> <span class="keyword">by</span> col2 可以使用索引排序。</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="keyword">table</span> <span class="keyword">where</span> col1 <span class="operator">=</span><span class="operator">=</span> xx <span class="keyword">order</span> <span class="keyword">by</span> col2,clo3 不可以使用索引排序【需要组合col2,clo3数据后排序】。</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>db</category>
      </categories>
      <tags>
        <tag>db</tag>
      </tags>
  </entry>
  <entry>
    <title>进程和线程</title>
    <url>/2021/04/20/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>进程</p>
<p>在计算机中，我们把一个任务称为一个进程，浏览器就是一个进程，视频播放器是另一个进程，类似的，音乐播放器和Word都是进程。</p>
<p>某些进程内部还需要同时执行多个子任务。例如，我们在使用Word时，Word可以让我们一边打字，一边进行拼写检查，同时还可以在后台进行打印，我们把子任务称为线程。</p>
<p>进程和线程的关系就是：一个进程可以包含一个或多个线程，但至少会有一个线程。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">                        ┌──────────┐</span><br><span class="line">                        │Process   │</span><br><span class="line">                        │┌────────┐│</span><br><span class="line">            ┌──────────┐││ Thread ││┌──────────┐</span><br><span class="line">            │Process   ││└────────┘││Process   │</span><br><span class="line">            │┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">┌──────────┐││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│Process   ││└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘└──────────┘</span><br><span class="line">┌──────────────────────────────────────────────┐</span><br><span class="line">│               Operating System               │</span><br><span class="line">└──────────────────────────────────────────────┘</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>操作系统调度的最小任务单位其实不是进程，而是线程。常用的Windows、Linux等操作系统都采用抢占式多任务，如何调度线程完全由操作系统决定，程序自己不能决定什么时候执行，以及执行多长时间。</p>
<p>因为同一个应用程序，既可以有多个进程，也可以有多个线程，因此，实现多任务的方法，有以下几种：</p>
<p>多进程模式（每个进程只有一个线程）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐ ┌──────────┐ ┌──────────┐</span><br><span class="line">│Process   │ │Process   │ │Process   │</span><br><span class="line">│┌────────┐│ │┌────────┐│ │┌────────┐│</span><br><span class="line">││ Thread ││ ││ Thread ││ ││ Thread ││</span><br><span class="line">│└────────┘│ │└────────┘│ │└────────┘│</span><br><span class="line">└──────────┘ └──────────┘ └──────────┘</span><br></pre></td></tr></table></figure>



<p>多线程模式（一个进程有多个线程）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────────────────────┐</span><br><span class="line">│Process             │</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">│┌────────┐┌────────┐│</span><br><span class="line">││ Thread ││ Thread ││</span><br><span class="line">│└────────┘└────────┘│</span><br><span class="line">└────────────────────┘</span><br></pre></td></tr></table></figure>



<p>多进程＋多线程模式（复杂度最高）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌──────────┐┌──────────┐┌──────────┐</span><br><span class="line">│Process   ││Process   ││Process   │</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">│┌────────┐││┌────────┐││┌────────┐│</span><br><span class="line">││ Thread ││││ Thread ││││ Thread ││</span><br><span class="line">│└────────┘││└────────┘││└────────┘│</span><br><span class="line">└──────────┘└──────────┘└──────────┘</span><br></pre></td></tr></table></figure>



<p>进程 vs 线程</p>
<p>进程和线程是包含关系，但是多任务既可以由多进程实现，也可以由单进程内的多线程实现，还可以混合多进程＋多线程。</p>
<p>具体采用哪种方式，要考虑到进程和线程的特点。</p>
<p>和多线程相比，多进程的缺点在于：</p>
<ul>
<li>创建进程比创建线程开销大，尤其是在Windows系统上；</li>
<li>进程间通信比线程间通信要慢，因为线程间通信就是读写同一个变量，速度很快。</li>
</ul>
<p>而多进程的优点在于：</p>
<p>多进程稳定性比多线程高，因为在多进程的情况下，一个进程崩溃不会影响其他进程，而在多线程的情况下，任何一个线程崩溃会直接导致整个进程崩溃。<!---more--></p>
<p>多线程</p>
<p>Java语言内置了多线程支持：一个Java程序实际上是一个JVM进程，JVM进程用一个主线程来执行main()方法，在main()方法内部，我们又可以启动多个线程。此外，JVM还有负责垃圾回收的其他工作线程等。</p>
<p>因此，对于大多数Java程序来说，我们说多任务，实际上是说如何使用多线程实现多任务。</p>
<p>和单线程相比，多线程编程的特点在于：多线程经常需要读写共享数据，并且需要同步。例如，播放电影时，就必须由一个线程播放视频，另一个线程播放音频，两个线程需要协调运行，否则画面和声音就不同步。因此，多线程编程的复杂度高，调试更困难。</p>
<p>Java多线程编程的特点又在于：</p>
<ul>
<li>多线程模型是Java程序最基本的并发模型；</li>
<li>后续读写网络、数据库、Web开发等都依赖Java多线程模型。</li>
</ul>
<p>因此，必须掌握Java多线程编程才能继续深入学习其他内容</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>线程</tag>
        <tag>linux</tag>
        <tag>进程</tag>
      </tags>
  </entry>
  <entry>
    <title>fasthttp-workerpool</title>
    <url>/2022/05/25/fasthttp-workerpool/</url>
    <content><![CDATA[<h2 id="记fasthttp-workerpool的实现方式"><a href="#记fasthttp-workerpool的实现方式" class="headerlink" title="记fasthttp-workerpool的实现方式"></a>记fasthttp-workerpool的实现方式</h2><p>golang中官方自带的net/http 默认处理请求的方式，对于一个http请求会单独的新起一个协程去做处理。在请求量大的时候，会使goroutine数量巨大，会增加runtime层的上下文切换成本，调度负担。而fasthttp 使用了workerpool规避这些问题。</p>
<h3 id="fastHTTP的请求流程的处理"><a href="#fastHTTP的请求流程的处理" class="headerlink" title="fastHTTP的请求流程的处理"></a>fastHTTP的请求流程的处理</h3><p>fasthttp的server启动时候，主要做了  </p>
<ol>
<li>监听端口</li>
<li>启动wokerpool</li>
<li>把真正处理链接的workFun注册到协程池里</li>
<li>循环接受HTTP链接，然后调用wp.Serve去处理HTTP链接<br><img src="/images/fasthttp-server.png"><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">Serve</span><span class="params">(ln net.Listener)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> lastOverflowErrorTime time.Time</span><br><span class="line">	<span class="keyword">var</span> lastPerIPErrorTime time.Time</span><br><span class="line">	<span class="keyword">var</span> c net.Conn</span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 协程池大小</span></span><br><span class="line">	maxWorkersCount := s.getConcurrency()</span><br><span class="line"></span><br><span class="line">	s.mu.Lock()</span><br><span class="line">	&#123;</span><br><span class="line">		s.ln = <span class="built_in">append</span>(s.ln, ln)</span><br><span class="line">		<span class="keyword">if</span> s.done == <span class="literal">nil</span> &#123;</span><br><span class="line">			s.done = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> s.concurrencyCh == <span class="literal">nil</span> &#123;</span><br><span class="line">			s.concurrencyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, maxWorkersCount)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	s.mu.Unlock()</span><br><span class="line"></span><br><span class="line">	wp := &amp;workerPool&#123;</span><br><span class="line">		WorkerFunc:            s.serveConn, <span class="comment">// 注册真正处理HTTP链接的函数</span></span><br><span class="line">		MaxWorkersCount:       maxWorkersCount,</span><br><span class="line">		LogAllErrors:          s.LogAllErrors,</span><br><span class="line">		MaxIdleWorkerDuration: s.MaxIdleWorkerDuration,</span><br><span class="line">		Logger:                s.logger(),</span><br><span class="line">		connState:             s.setState,</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 启动协程池管理，start函数里会触发一个单独的协程用来清理那些过期的协程</span></span><br><span class="line">	wp.Start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	atomic.AddInt32(&amp;s.open, <span class="number">1</span>)</span><br><span class="line">	<span class="keyword">defer</span> atomic.AddInt32(&amp;s.open, <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> c, err = acceptConn(s, ln, &amp;lastPerIPErrorTime); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			wp.Stop()</span><br><span class="line">			<span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> err</span><br><span class="line">		&#125;</span><br><span class="line">		s.setState(c, StateNew)</span><br><span class="line">		atomic.AddInt32(&amp;s.open, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">//wp.Serve 里会从协程池里获取协程worker，然后去处理HTTP链接</span></span><br><span class="line">		<span class="keyword">if</span> !wp.Serve(c) &#123;</span><br><span class="line">			atomic.AddInt32(&amp;s.open, <span class="number">-1</span>)</span><br><span class="line">			s.writeFastError(c, StatusServiceUnavailable,</span><br><span class="line">				<span class="string">&quot;The connection cannot be served because Server.Concurrency limit exceeded&quot;</span>)</span><br><span class="line">			c.Close()</span><br><span class="line">			s.setState(c, StateClosed)</span><br><span class="line">			<span class="keyword">if</span> time.Since(lastOverflowErrorTime) &gt; time.Minute &#123;</span><br><span class="line">				s.logger().Printf(<span class="string">&quot;The incoming connection cannot be served, because %d concurrent connections are served. &quot;</span>+</span><br><span class="line">					<span class="string">&quot;Try increasing Server.Concurrency&quot;</span>, maxWorkersCount)</span><br><span class="line">				lastOverflowErrorTime = time.Now()</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> s.SleepWhenConcurrencyLimitsExceeded &gt; <span class="number">0</span> &#123;</span><br><span class="line">				time.Sleep(s.SleepWhenConcurrencyLimitsExceeded)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		c = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="workerpool主要的作用逻辑"><a href="#workerpool主要的作用逻辑" class="headerlink" title="workerpool主要的作用逻辑"></a>workerpool主要的作用逻辑</h3>wokerpool主要做了以下这些事情</li>
<li>管理协程worker，清楚过去的worker</li>
<li>使用自身的属性read来存储 worker</li>
<li>HTTP链接和worker使用channel来传递</li>
<li>接受来自server注册的真正处理链接的函数workFun<br>自身主要结构如下图<br><img src="/images/workerpool-struct.png"><br>处理流程如下图<br><img src="/images/fasthttp-wokerpool.png"><h4 id="workerpool主要函数及属性分析"><a href="#workerpool主要函数及属性分析" class="headerlink" title="workerpool主要函数及属性分析"></a>workerpool主要函数及属性分析</h4></li>
<li>start函数<br>主要单独起一个协程处理过期的worker，并且初始化了sync.pool的新增worker的方法<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">Start</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> wp.stopCh != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="built_in">panic</span>(<span class="string">&quot;BUG: workerPool already started&quot;</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	wp.stopCh = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">	stopCh := wp.stopCh</span><br><span class="line">  <span class="comment">// 使用sync.pool 来复用workerChan</span></span><br><span class="line">	wp.workerChanPool.New = <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">		<span class="keyword">return</span> &amp;workerChan&#123;</span><br><span class="line">			ch: <span class="built_in">make</span>(<span class="keyword">chan</span> net.Conn, workerChanCap),</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 主要单独起一个协程处理过期的worker</span></span><br><span class="line">	<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">		<span class="keyword">var</span> scratch []*workerChan</span><br><span class="line">		<span class="keyword">for</span> &#123;</span><br><span class="line">			wp.clean(&amp;scratch)</span><br><span class="line">			<span class="keyword">select</span> &#123;</span><br><span class="line">			<span class="keyword">case</span> &lt;-stopCh:</span><br><span class="line">				<span class="keyword">return</span></span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				time.Sleep(wp.getMaxIdleWorkerDuration())</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>clean 主要是清理过期的worker<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">clean</span><span class="params">(scratch *[]*workerChan)</span></span> &#123;</span><br><span class="line">	maxIdleWorkerDuration := wp.getMaxIdleWorkerDuration()</span><br><span class="line">	criticalTime := time.Now().Add(-maxIdleWorkerDuration)</span><br><span class="line"></span><br><span class="line">	wp.lock.Lock()</span><br><span class="line">	ready := wp.ready</span><br><span class="line">	n := <span class="built_in">len</span>(ready)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 使用二分查找，发现过期的worker</span></span><br><span class="line">	l, r, mid := <span class="number">0</span>, n<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> l &lt;= r &#123;</span><br><span class="line">		mid = (l + r) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> criticalTime.After(wp.ready[mid].lastUseTime) &#123;</span><br><span class="line">			l = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	i := r</span><br><span class="line">	<span class="keyword">if</span> i == <span class="number">-1</span> &#123;</span><br><span class="line">		wp.lock.Unlock()</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	*scratch = <span class="built_in">append</span>((*scratch)[:<span class="number">0</span>], ready[:i+<span class="number">1</span>]...)</span><br><span class="line">	m := <span class="built_in">copy</span>(ready, ready[i+<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">for</span> i = m; i &lt; n; i++ &#123;</span><br><span class="line">		ready[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	wp.ready = ready[:m]</span><br><span class="line">	wp.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	tmp := *scratch</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> tmp &#123;</span><br><span class="line">		tmp[i].ch &lt;- <span class="literal">nil</span></span><br><span class="line">		tmp[i] = <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>serve 接受HTTP请求的入口<br>从连接池里获取worker，然后让worker去处理，如果是新建的worker会起一个协程。<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">Serve</span><span class="params">(c net.Conn)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">  <span class="comment">// getCh会获取协程worker，如果是新建的worker会起一个协程。</span></span><br><span class="line">	ch := wp.getCh()</span><br><span class="line">	<span class="keyword">if</span> ch == <span class="literal">nil</span> &#123; <span class="comment">//说明worker达到最大数目</span></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">  <span class="comment">// 这里使用channel,与worker里的协程通信</span></span><br><span class="line">	ch.ch &lt;- c</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取worker</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">getCh</span><span class="params">()</span> *<span class="title">workerChan</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> ch *workerChan</span><br><span class="line">	createWorker := <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">	wp.lock.Lock()</span><br><span class="line">	ready := wp.ready</span><br><span class="line">	n := <span class="built_in">len</span>(ready) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> wp.workersCount &lt; wp.MaxWorkersCount &#123;</span><br><span class="line">			createWorker = <span class="literal">true</span></span><br><span class="line">			wp.workersCount++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		ch = ready[n]</span><br><span class="line">		ready[n] = <span class="literal">nil</span></span><br><span class="line">		wp.ready = ready[:n]</span><br><span class="line">	&#125;</span><br><span class="line">	wp.lock.Unlock()</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ch == <span class="literal">nil</span> &#123; <span class="comment">// read取不到，且未达到最大，则新建worker</span></span><br><span class="line">		<span class="keyword">if</span> !createWorker &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		vch := wp.workerChanPool.Get()</span><br><span class="line">		ch = vch.(*workerChan)</span><br><span class="line">		<span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			wp.workerFunc(ch) <span class="comment">// 在协程里处理链接，通过channel接受HTTP链接</span></span><br><span class="line">			wp.workerChanPool.Put(vch)</span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>workerFunc 真正处理链接的地方<br>主要是一直for循环等channel里出现新的HTTP链接，然后接受HTTP链接去处理<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wp *workerPool)</span> <span class="title">workerFunc</span><span class="params">(ch *workerChan)</span></span> &#123;</span><br><span class="line">	<span class="keyword">var</span> c net.Conn</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> err error</span><br><span class="line">	<span class="keyword">for</span> c = <span class="keyword">range</span> ch.ch &#123;</span><br><span class="line">		<span class="keyword">if</span> c == <span class="literal">nil</span> &#123; <span class="comment">// 说明，自身长时间未获取到新的HTTP请求导致超时被关闭或者workerpool停止。</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用Server注册的WorkerFunc真正处理HTTP链接</span></span><br><span class="line">		<span class="keyword">if</span> err = wp.WorkerFunc(c); err != <span class="literal">nil</span> &amp;&amp; err != errHijacked &#123;</span><br><span class="line">			errStr := err.Error()</span><br><span class="line">			<span class="keyword">if</span> wp.LogAllErrors || !(strings.Contains(errStr, <span class="string">&quot;broken pipe&quot;</span>) ||</span><br><span class="line">				strings.Contains(errStr, <span class="string">&quot;reset by peer&quot;</span>) ||</span><br><span class="line">				strings.Contains(errStr, <span class="string">&quot;request headers: small read buffer&quot;</span>) ||</span><br><span class="line">				strings.Contains(errStr, <span class="string">&quot;unexpected EOF&quot;</span>) ||</span><br><span class="line">				strings.Contains(errStr, <span class="string">&quot;i/o timeout&quot;</span>) ||</span><br><span class="line">				errors.Is(err, ErrBadTrailer)) &#123;</span><br><span class="line">				wp.Logger.Printf(<span class="string">&quot;error when serving connection %q&lt;-&gt;%q: %v&quot;</span>, c.LocalAddr(), c.RemoteAddr(), err)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> err == errHijacked &#123;</span><br><span class="line">			wp.connState(c, StateHijacked)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			_ = c.Close()</span><br><span class="line">			wp.connState(c, StateClosed)</span><br><span class="line">		&#125;</span><br><span class="line">		c = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理完一个请求后，把自身归返到read里去</span></span><br><span class="line">		<span class="keyword">if</span> !wp.release(ch) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wp.lock.Lock()</span><br><span class="line">	wp.workersCount--</span><br><span class="line">	wp.lock.Unlock()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>缓存一致性</title>
    <url>/2022/06/04/%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7/</url>
    <content><![CDATA[<h3 id="缓存的使用"><a href="#缓存的使用" class="headerlink" title="缓存的使用"></a>缓存的使用</h3><p>从系统层面看，使用缓存的目的无外乎缓解 DB 压力（主要是读压力），提升服务响应速度。<br>引入缓存，就不可避免地引入了缓存与业务 DB 数据的一致性问题，而不同的业务场景，对数据一致性的要求也不同。<br>因为redis和db毕竟是两套系统，数据的一致性想要达到何种程度要根据业务场景来取舍：</p>
<ul>
<li>最终一致性分布式缓存场景<br> 对于业务场景对数据一致性要求不是那么高的情况下，我们可以通过队列，binlog等手段达到最终一致性的效果。</li>
<li>强一致性分布式缓存场景<br> 数据库跟缓存，以Mysql跟Redis举例，毕竟是两套系统，如果要保证强一致性，势必要引入2PC或Paxos等分布式一致性协议，或者是分布式锁等等，这个在实现上是有难度的，而且一定会对性能有影响。<br> 而且如果真的对数据的一致性要求这么高，我们需要考虑 缓存是否真的有必要，直接读写数据库不是更好？以何种模式做到数据库跟缓存的数据强一致性，并且对系统是有提升的。</li>
</ul>
<h4 id="数据库和缓存的读写顺序"><a href="#数据库和缓存的读写顺序" class="headerlink" title="数据库和缓存的读写顺序"></a>数据库和缓存的读写顺序</h4><p>一般我们在操作数据库和缓存的时候，都是先读缓存，缓存没有了，去读数据库，然后写入缓存。大致步骤情况如下。</p>
<ul>
<li>过期数据：程序先从缓存中读取数据，如果没有命中，则从数据库中读取，成功之后将数据放到缓存中</li>
<li>命中缓存：程序先从缓存中读取数据，如果命中，则直接返回</li>
<li>更新数据：程序先更新数据库，在删除缓存</li>
</ul>
<p>再这里，不过多讨论，更新的数据的其他方式。如<br>先更新缓存，在更新数据，【数据库可能回滚，这个时候还是要删除缓存】<br>先更新数据，在更新缓存。【两个线程同时更新的情况，有可能时序上出现错乱，导致不是最新数据】<br>先删除缓存，在更新数据。【数据未更新完成的情况，会有老数据写入缓存】</p>
<p>然而，我们在执行 更新数据和过期数据重新设置缓存的，在并发情况下会出现时序问题，造成缓存写入的不一定是最新数据。</p>
<ul>
<li>当缓存失效时，同时有一个读请求和写请求或者读请求在写未完毕的过程中，此时读到的是old数据，并且由于时序原因【网络等各种情况导致的】，导致写入的操作在删除操作之后，会写入老数据。<br><img src="/images/rw-cache.png"><br><img src="/images/rw-cache2.png"><br><img src="/images/rw-cache3.png"></li>
</ul>
<p>对于此种情况，如果对数据一致性没那么敏感的情况下，我们可以考虑设置的缓存时间短一些，<br>在有从库情况下考虑监听binlog下情况，在数据同步后在执行一次删除缓存的操作。</p>
<h4 id="数据库和缓存的一致性"><a href="#数据库和缓存的一致性" class="headerlink" title="数据库和缓存的一致性"></a>数据库和缓存的一致性</h4><p>如果想达到强一致的情况，我们必须考虑加锁降请求串行化执行，在设置缓存的过程中，会降低一定的系统负载。<br>而且删除和设置缓存都需要加锁。如下图<br><img src="/images/rw-cache4.png"></p>
<p>当更新数据或者更新缓存的时候：<br>  在更新时候先尝试进行加锁，若当前有锁说明当前有 DB 或缓存正在更新，则进行等待和重试，从而可避免查询到 DB 中的老数据更新到缓存中。这种方案适合写并发低的场景。</p>
<p>读的并发操作控制：<br>   在进行读的时候，先查验锁，如果锁不存在。说明无更新缓存和更新DB的操作。此时如果缓存有数据直接读取，无数据加锁重新设置缓存即可。<br>在有锁的时候。说明有更新数据或者设置缓存的操作正在执行。不能直接查询缓存，可以系统 配置在查询 DB 后返回数据或者检测到有锁后可进行短暂的等待和重试，好处是可进一步增加缓存的命中率，但是多一次锁等待，可能会影响到查询接口的性能。</p>
<p>锁在DB操作中的粒度：<br><img src="/images/rw-cache6.png"></p>
<ul>
<li>方案一：事务提交后加锁，只锁定删除缓存操作。对原事务无任何额外影响，但是在事务提交后到删除缓存之间存在与查询的并发可能性。</li>
<li>方案二：在事务提交前加锁，删除缓存后解锁。在满足一致性要求的前提下，锁的粒度可以做到最小，但是增加了 DB 事务的范围，若 redis 出现超时则可能导致事务时间拉长，进而影响 DB 操作性能。</li>
<li>方案三：在事务开始前加锁，删除缓存后解锁。锁的范围较大，但是能满足我们一致性要求，对单个 DB 事务也基本无影响。且对同一个用户来说，贷前数据的更新并不频繁，锁范围稍大一些是我们可以接受的。</li>
</ul>
<p>此外还需要考虑如果有从库的情况下的主从延迟情况，如果延迟过大，在db更新后，需要标记下数据在多长时间下是从主库读取。</p>
]]></content>
  </entry>
</search>
